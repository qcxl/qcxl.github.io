<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>FFmpeg和libyuv的基本使用(五) | Mobile Development</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="FFmpeg 和 libyuv的基本使用万能视频播放器实现的基本过程:
将任意格式的视频文件统一解码成YUV格式,然后将解码后的帧数据绘制到本地ANativeWindow里的Surface上. 这里的Surface由SurfaceView提供">
<meta property="og:type" content="article">
<meta property="og:title" content="FFmpeg和libyuv的基本使用(五)">
<meta property="og:url" content="http://yoursite.com/2017/08/04/android_ffmpeg_4/index.html">
<meta property="og:site_name" content="Mobile Development">
<meta property="og:description" content="FFmpeg 和 libyuv的基本使用万能视频播放器实现的基本过程:
将任意格式的视频文件统一解码成YUV格式,然后将解码后的帧数据绘制到本地ANativeWindow里的Surface上. 这里的Surface由SurfaceView提供">
<meta property="og:updated_time" content="2017-08-04T14:14:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FFmpeg和libyuv的基本使用(五)">
<meta name="twitter:description" content="FFmpeg 和 libyuv的基本使用万能视频播放器实现的基本过程:
将任意格式的视频文件统一解码成YUV格式,然后将解码后的帧数据绘制到本地ANativeWindow里的Surface上. 这里的Surface由SurfaceView提供">
  
    <link rel="alternative" href="/atom.xml" title="Mobile Development" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://img0.imgtn.bdimg.com/it/u=781933599,3526596667&amp;fm=21&amp;gp=0.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">weifeng</a></h1>
		</hgroup>

		
		<p class="header-subtitle">移动开发</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://android-arsenal.com/">Android Arsenal</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.androiddevtools.cn/">AndroidDevTools</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://androidweekly.net/">Android Weekly</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://android-libs.com/">AndroidLibs</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://xjanker.github.io/akita/">Akita</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://dusunboy.github.io/android-nice-repo/">Android 开源项目</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://hmkcode.com/">HMKCode</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://weekly.manong.io/issues/">码农周刊</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://toutiao.io/">开发者头条</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.androidweekly.cn/">Android开发技术周报</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.devtf.cn/">开发技术前线</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://gank.io/">干货集中营</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.androidchina.net/">AndroidChina</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.codeceo.com/">码农网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jcodecraeer.com/">泡在网上的日子</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jobbole.com/">伯乐在线</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.kuqin.com/">酷勤网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.akaifa.com/">爱开发</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://androidperformance.com/">Performance Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.lightskystreet.com/">lightSky Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.guolingfa.cn/">GuoBlog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://yanshi.name/">Kinney&#39;s Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.inferjay.com/">脉脉不得语的技术博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://droidyue.com/">技术小黑屋</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://sunjiajia.com/">安卓猴Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.race604.com/">Jlog博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.apkdv.com/">LengYue&#39;s Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://wuyexiong.github.io/">Wuyexiong de Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.25xt.com/">25学堂</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://get.jobdeer.com/">Get社区</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://evis.me/tag/app/">壹维思_EVIS</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://weirss.me/">WeiRSS</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://next.36kr.com/posts">NEXT</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">Android 开发</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">weifeng</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://img0.imgtn.bdimg.com/it/u=781933599,3526596667&amp;fm=21&amp;gp=0.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">weifeng</h1>
			</hgroup>
			
			<p class="header-subtitle">移动开发</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-android_ffmpeg_4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/08/04/android_ffmpeg_4/" class="article-date">
  	<time datetime="2017-08-04T14:10:19.000Z" itemprop="datePublished">2017-08-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      FFmpeg和libyuv的基本使用(五)
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="FFmpeg_和_libyuv的基本使用">FFmpeg 和 libyuv的基本使用</h3><h4 id="万能视频播放器">万能视频播放器</h4><p>实现的基本过程:</p>
<p>将任意格式的视频文件统一解码成YUV格式,然后将解码后的帧数据绘制到本地ANativeWindow里的Surface上. 这里的Surface由SurfaceView提供</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SurfaceHolder holder = surfaceView.getHolder();</span><br><span class="line"><span class="comment">//Surface 传入到Native函数中,用于绘制</span></span><br><span class="line">Surface surface = holder.getSurface();</span><br></pre></td></tr></table></figure>
<p>具体实现代码如下:</p>
<ul>
<li>自定义SurfaceView类 VideoView.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoView</span> <span class="keyword">extends</span> <span class="title">SurfaceView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SurfaceHolder holder = getHolder();</span><br><span class="line">        holder.setFormat(PixelFormat.RGBA_8888);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>新建音视频播放工具类 VideoPlayer.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(String input, Surface surface)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sound</span><span class="params">(String input, String output)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">playSoud</span><span class="params">(String input)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">readAndPlaySound</span><span class="params">(String input, String output)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 创建一个AudioTrac对象，用于播放</span><br><span class="line">     * <span class="doctag">@param</span> nb_channels</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AudioTrack <span class="title">createAudioTrack</span><span class="params">(<span class="keyword">int</span> sampleRateInHz, <span class="keyword">int</span> nb_channels)</span></span>&#123;</span><br><span class="line">        <span class="comment">//固定格式的音频码流</span></span><br><span class="line">        <span class="keyword">int</span> audioFormat = AudioFormat.ENCODING_PCM_16BIT;</span><br><span class="line">        Log.i(<span class="string">"jason"</span>, <span class="string">"nb_channels:"</span>+nb_channels);</span><br><span class="line">        <span class="comment">//声道布局</span></span><br><span class="line">        <span class="keyword">int</span> channelConfig;</span><br><span class="line">        <span class="keyword">if</span>(nb_channels == <span class="number">1</span>)&#123;</span><br><span class="line">            channelConfig = android.media.AudioFormat.CHANNEL_OUT_MONO;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nb_channels == <span class="number">2</span>)&#123;</span><br><span class="line">            channelConfig = android.media.AudioFormat.CHANNEL_OUT_STEREO;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            channelConfig = android.media.AudioFormat.CHANNEL_OUT_STEREO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bufferSizeInBytes = AudioTrack.getMinBufferSize(sampleRateInHz, channelConfig, audioFormat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AudioTrack audioTrack = <span class="keyword">new</span> AudioTrack(</span><br><span class="line">                AudioManager.STREAM_MUSIC,</span><br><span class="line">                sampleRateInHz, channelConfig,</span><br><span class="line">                audioFormat,</span><br><span class="line">                bufferSizeInBytes, AudioTrack.MODE_STREAM);</span><br><span class="line">        <span class="comment">//播放</span></span><br><span class="line">        <span class="comment">//audioTrack.play();</span></span><br><span class="line">        <span class="comment">//写入PCM</span></span><br><span class="line">        <span class="comment">//audioTrack.write(audioData, offsetInBytes, sizeInBytes);</span></span><br><span class="line">        <span class="keyword">return</span> audioTrack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体Native代码实现如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;jni.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="comment">//C/C++混编 extern: 指示编译器按照C语言进行编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;libyuv.h&gt;</span></span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;libavcodec/avcodec.h&gt;</span></span><br><span class="line"><span class="comment">//封装格式处理</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;libavformat/avformat.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;libavfilter/avfilter.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;libswscale/swscale.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;android/log.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;android/native_window_jni.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;android/native_window.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unistd.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> libyuv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//重采样</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;libswresample/swresample.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LOGI(FORMAT, ...) __android_log_print(ANDROID_LOG_INFO,"jason",FORMAT,##__VA_ARGS__);</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LOGE(FORMAT, ...) __android_log_print(ANDROID_LOG_ERROR,"jason",FORMAT,##__VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>  MAX_AUDIO_FRAME_SIZE 48000 * 4</span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_MainActivity_avcodecinfo</span><span class="params">(JNIEnv *env, jobject instance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">    <span class="keyword">char</span> info[<span class="number">40000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    av_register_all();</span><br><span class="line">    AVCodec *<span class="keyword">c_t</span>emp = av_codec_next(NULL);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">c_t</span>emp != NULL)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">c_t</span>emp-&gt;decode != NULL)&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(info, <span class="string">"%sdecode:"</span>, info);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(info, <span class="string">"%sencode:"</span>, info);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">c_t</span>emp-&gt;type)&#123;</span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">                <span class="built_in">sprintf</span>(info, <span class="string">"%s(video):"</span>, info);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">                <span class="built_in">sprintf</span>(info, <span class="string">"%s(audio):"</span>, info);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">sprintf</span>(info, <span class="string">"%s(other):"</span>, info);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sprintf</span>(info, <span class="string">"%s[%10s]\n"</span>, info, <span class="keyword">c_t</span>emp-&gt;name);</span><br><span class="line">        <span class="keyword">c_t</span>emp = <span class="keyword">c_t</span>emp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_VideoPlayer_readAndPlaySound</span><span class="params">(JNIEnv *env, jobject jthiz,</span><br><span class="line">                                                        jstring input_, jstring output_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input_cstr = env-&gt;GetStringUTFChars(input_, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *output_cstr = env-&gt;GetStringUTFChars(output_, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    LOGI(<span class="string">"%s"</span>,<span class="string">"sound"</span>);</span><br><span class="line">    <span class="comment">//注册组件</span></span><br><span class="line">    av_register_all();</span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line">    <span class="comment">//打开音频文件</span></span><br><span class="line">    <span class="keyword">if</span>(avformat_open_input(&amp;pFormatCtx,input_cstr,NULL,NULL) != <span class="number">0</span>)&#123;</span><br><span class="line">        LOGI(<span class="string">"%s"</span>,<span class="string">"无法打开音频文件"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取输入文件信息</span></span><br><span class="line">    <span class="keyword">if</span>(avformat_find_stream_info(pFormatCtx,NULL) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        LOGI(<span class="string">"%s"</span>,<span class="string">"无法获取输入文件信息"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取音频流索引位置</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, audio_stream_idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; pFormatCtx-&gt;nb_streams;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;<span class="keyword">codec_t</span>ype == AVMEDIA_TYPE_AUDIO)&#123;</span><br><span class="line">            audio_stream_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取解码器</span></span><br><span class="line">    AVCodecContext *codecCtx = pFormatCtx-&gt;streams[audio_stream_idx]-&gt;codec;</span><br><span class="line">    AVCodec *codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span>(codec == NULL)&#123;</span><br><span class="line">        LOGI(<span class="string">"%s"</span>,<span class="string">"无法获取解码器"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开解码器</span></span><br><span class="line">    <span class="keyword">if</span>(avcodec_open2(codecCtx,codec,NULL) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        LOGI(<span class="string">"%s"</span>,<span class="string">"无法打开解码器"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压缩数据</span></span><br><span class="line">    AVPacket *packet = (AVPacket *)av_malloc(<span class="keyword">sizeof</span>(AVPacket));</span><br><span class="line">    <span class="comment">//解压缩数据</span></span><br><span class="line">    AVFrame *frame = av_frame_alloc();</span><br><span class="line">    <span class="comment">//frame-&gt;16bit 44100 PCM 统一音频采样格式与采样率</span></span><br><span class="line">    SwrContext *swrCtx = swr_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重采样设置参数-------------start</span></span><br><span class="line">    <span class="comment">//输入的采样格式</span></span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat in_sample_fmt = codecCtx-&gt;sample_fmt;</span><br><span class="line">    <span class="comment">//输出采样格式16bit PCM</span></span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">    <span class="comment">//输入采样率</span></span><br><span class="line">    <span class="keyword">int</span> in_sample_rate = codecCtx-&gt;sample_rate;</span><br><span class="line">    <span class="comment">//输出采样率</span></span><br><span class="line">    <span class="keyword">int</span> out_sample_rate = in_sample_rate;</span><br><span class="line">    <span class="comment">//获取输入的声道布局</span></span><br><span class="line">    <span class="comment">//根据声道个数获取默认的声道布局（2个声道，默认立体声stereo）</span></span><br><span class="line">    <span class="comment">//av_get_default_channel_layout(codecCtx-&gt;channels);</span></span><br><span class="line">    <span class="keyword">uint64_t</span> in_ch_layout = codecCtx-&gt;channel_layout;</span><br><span class="line">    <span class="comment">//输出的声道布局（立体声）</span></span><br><span class="line">    <span class="keyword">uint64_t</span> out_ch_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line"></span><br><span class="line">    swr_alloc_set_opts(swrCtx,</span><br><span class="line">                       out_ch_layout,out_sample_fmt,out_sample_rate,</span><br><span class="line">                       in_ch_layout,in_sample_fmt,in_sample_rate,</span><br><span class="line">                       <span class="number">0</span>, NULL);</span><br><span class="line">    swr_init(swrCtx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出的声道个数</span></span><br><span class="line">    <span class="keyword">int</span> out_channel_nb = av_get_channel_layout_nb_channels(out_ch_layout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重采样设置参数-------------end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//JNI begin------------------</span></span><br><span class="line">    <span class="comment">//JasonPlayer</span></span><br><span class="line">    jclass player_class = env-&gt;GetObjectClass(jthiz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AudioTrack对象</span></span><br><span class="line">    jmethodID <span class="keyword">create_audio_t</span>rack_mid = env-&gt;GetMethodID(player_class,<span class="string">"createAudioTrack"</span>,<span class="string">"(II)Landroid/media/AudioTrack;"</span>);</span><br><span class="line">    jobject <span class="keyword">audio_t</span>rack = env-&gt;CallObjectMethod(jthiz,<span class="keyword">create_audio_t</span>rack_mid,out_sample_rate,out_channel_nb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用AudioTrack.play方法</span></span><br><span class="line">    jclass <span class="keyword">audio_t</span>rack_class = env-&gt;GetObjectClass(<span class="keyword">audio_t</span>rack);</span><br><span class="line">    jmethodID <span class="keyword">audio_t</span>rack_play_mid = env-&gt;GetMethodID(<span class="keyword">audio_t</span>rack_class,<span class="string">"play"</span>,<span class="string">"()V"</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(<span class="keyword">audio_t</span>rack,<span class="keyword">audio_t</span>rack_play_mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AudioTrack.write</span></span><br><span class="line">    jmethodID <span class="keyword">audio_t</span>rack_write_mid = env-&gt;GetMethodID(<span class="keyword">audio_t</span>rack_class,<span class="string">"write"</span>,<span class="string">"([BII)I"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JNI end------------------</span></span><br><span class="line">    FILE *fp_pcm = fopen(output_cstr,<span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//16bit 44100 PCM 数据</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *out_buffer = (<span class="keyword">uint8_t</span> *)av_malloc(MAX_AUDIO_FRAME_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> got_frame = <span class="number">0</span>,index = <span class="number">0</span>, ret;</span><br><span class="line">    <span class="comment">//不断读取压缩数据</span></span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(pFormatCtx,packet) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//解码音频类型的Packet</span></span><br><span class="line">        <span class="keyword">if</span>(packet-&gt;stream_index == audio_stream_idx)&#123;</span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            ret = avcodec_decode_audio4(codecCtx,frame,&amp;got_frame,packet);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                LOGI(<span class="string">"%s"</span>,<span class="string">"解码完成"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解码一帧成功</span></span><br><span class="line">            <span class="keyword">if</span>(got_frame &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                LOGI(<span class="string">"解码：%d"</span>,index++);</span><br><span class="line">                swr_convert(swrCtx, &amp;out_buffer, MAX_AUDIO_FRAME_SIZE,(<span class="keyword">const</span> <span class="keyword">uint8_t</span> **)frame-&gt;data,frame-&gt;nb_samples);</span><br><span class="line">                <span class="comment">//获取sample的size</span></span><br><span class="line">                <span class="keyword">int</span> out_buffer_size = av_samples_get_buffer_size(NULL, out_channel_nb,</span><br><span class="line">                                                                 frame-&gt;nb_samples, out_sample_fmt, <span class="number">1</span>);</span><br><span class="line">                fwrite(out_buffer,<span class="number">1</span>,out_buffer_size,fp_pcm);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//out_buffer缓冲区数据，转成byte数组</span></span><br><span class="line">                jbyteArray audio_sample_array = env-&gt;NewByteArray(out_buffer_size);</span><br><span class="line">                jbyte* sample_bytep = env-&gt;GetByteArrayElements(audio_sample_array,NULL);</span><br><span class="line">                <span class="comment">//out_buffer的数据复制到sampe_bytep</span></span><br><span class="line">                <span class="built_in">memcpy</span>(sample_bytep,out_buffer,out_buffer_size);</span><br><span class="line">                <span class="comment">//同步</span></span><br><span class="line">                env-&gt;ReleaseByteArrayElements(audio_sample_array,sample_bytep,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//AudioTrack.write PCM数据</span></span><br><span class="line">                env-&gt;CallIntMethod(<span class="keyword">audio_t</span>rack,<span class="keyword">audio_t</span>rack_write_mid,</span><br><span class="line">                                      audio_sample_array,<span class="number">0</span>,out_buffer_size);</span><br><span class="line">                <span class="comment">//释放局部引用</span></span><br><span class="line">                env-&gt;DeleteLocalRef(audio_sample_array);</span><br><span class="line">                usleep(<span class="number">1000</span> * <span class="number">16</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_free_packet(packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">    av_free(out_buffer);</span><br><span class="line"></span><br><span class="line">    swr_free(&amp;swrCtx);</span><br><span class="line">    avcodec_close(codecCtx);</span><br><span class="line">    avformat_close_input(&amp;pFormatCtx);</span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(input_, input_cstr);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(output_, output_cstr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_VideoPlayer_playSoud</span><span class="params">(JNIEnv *env, jobject instance, jstring input_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input = env-&gt;GetStringUTFChars(input_, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">    <span class="comment">//1.注册所有组件</span></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装格式上下文，统领全局的结构体，保存了音视频文件封装格式的相关信息</span></span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.打开音频文件</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx, input, NULL, NULL) != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法打开音频文件"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取音频文件信息</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(pFormatCtx, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法获取音频文件信息"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取音频流的索引位置</span></span><br><span class="line">    <span class="comment">//遍历所有类型的流（音频流、视频流、字幕流），找到音频流</span></span><br><span class="line">    <span class="keyword">int</span> audio_stream_idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//number of streams</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="comment">//流的类型</span></span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;<span class="keyword">codec_t</span>ype == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            audio_stream_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio_stream_idx == -<span class="number">1</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到音频流\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取音频流中的编解码上下文</span></span><br><span class="line">    AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[audio_stream_idx]-&gt;codec;</span><br><span class="line">    <span class="comment">//4.根据编解码上下文中的编码id查找对应的解码</span></span><br><span class="line">    AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">    <span class="comment">//（迅雷看看，找不到解码器，临时下载一个解码器）</span></span><br><span class="line">    <span class="keyword">if</span> (pCodec == NULL) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到解码器\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.打开解码器</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"解码器无法打开\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出音频信息</span></span><br><span class="line">    LOGI(<span class="string">"音频的文件格式：%s"</span>, pFormatCtx-&gt;iformat-&gt;name);</span><br><span class="line">    LOGI(<span class="string">"音频时长：%lld"</span>, (pFormatCtx-&gt;duration) / <span class="number">1000000</span>);</span><br><span class="line">    LOGI(<span class="string">"音频的宽高：%d,%d"</span>, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line">    LOGI(<span class="string">"解码器的名称：%s"</span>, pCodec-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压缩数据</span></span><br><span class="line">    AVPacket *packet = (AVPacket *)av_malloc(<span class="keyword">sizeof</span>(AVPacket));</span><br><span class="line">    <span class="comment">//解压缩数据</span></span><br><span class="line">    AVFrame *frame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//frame-&gt;16bit  44100 PCM 统一音频采样格式与采样率</span></span><br><span class="line"></span><br><span class="line">    SwrContext *swrContext = swr_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重采样设置参数</span></span><br><span class="line">    <span class="comment">//输入的采样格式</span></span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat  in_sample_fmt = pCodecCtx-&gt;sample_fmt;</span><br><span class="line">    <span class="comment">//输出的采样格式</span></span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">    <span class="comment">//输入采样率</span></span><br><span class="line">    <span class="keyword">int</span> in_sample_rate = pCodecCtx-&gt;sample_rate;</span><br><span class="line">    <span class="comment">//输出采样率</span></span><br><span class="line">    <span class="keyword">int</span> out_sample_rate = in_sample_rate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取输入的声道布局 参加AudioFormat.java  286行</span></span><br><span class="line">    <span class="comment">//根据声道个数获取默认的声道布局(2个声道,默认立体声CHANNEL_OUT_STEREO)</span></span><br><span class="line">    <span class="comment">//CHANNEL_OUT_5POINT1 为5.1环绕声</span></span><br><span class="line">    <span class="comment">//av_get_default_channel_layout(pCodecCtx-&gt;channels);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span>  in_ch_layout = pCodecCtx-&gt;channel_layout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出的声道布局</span></span><br><span class="line">    <span class="keyword">int64_t</span> out_ch_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出声道个数</span></span><br><span class="line">    <span class="keyword">int</span> out_channel_nb = av_get_channel_layout_nb_channels(out_ch_layout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> log_offset = <span class="number">0</span>; <span class="comment">// 不偏移</span></span><br><span class="line"></span><br><span class="line">    swr_alloc_set_opts(swrContext,</span><br><span class="line">                       out_ch_layout, out_sample_fmt, out_sample_rate,</span><br><span class="line">                       in_ch_layout, in_sample_fmt, in_sample_rate,</span><br><span class="line">                       log_offset, NULL);</span><br><span class="line"></span><br><span class="line">    swr_init(swrContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//VideoPlayer</span></span><br><span class="line">    jclass player_class = env-&gt;GetObjectClass(instance);</span><br><span class="line">    <span class="comment">//AudioTrack对象</span></span><br><span class="line">    <span class="comment">//cd  cd /Users/vobile/AndroidStudioProjects/FFmpegDemo/app/build/intermediates/classes/debug/com/vobile/ffmpegdemo/</span></span><br><span class="line">    <span class="comment">//javap -s VideoPlayer.class</span></span><br><span class="line">    jmethodID <span class="keyword">create_audio_t</span>rack_mid = env-&gt;GetMethodID(player_class,<span class="string">"createAudioTrack"</span>,<span class="string">"(II)Landroid/media/AudioTrack;"</span>);</span><br><span class="line">    jobject <span class="keyword">audio_t</span>rack = env-&gt;CallObjectMethod(instance,<span class="keyword">create_audio_t</span>rack_mid,out_sample_rate,out_channel_nb);</span><br><span class="line">    <span class="comment">//调用AudioTrack.play()方法</span></span><br><span class="line">    jclass <span class="keyword">audio_t</span>rack_class = env-&gt;GetObjectClass(<span class="keyword">audio_t</span>rack);</span><br><span class="line">    jmethodID <span class="keyword">audio_t</span>rack_play_mid = env-&gt;GetMethodID(<span class="keyword">audio_t</span>rack_class,<span class="string">"play"</span>,<span class="string">"()V"</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(<span class="keyword">audio_t</span>rack,<span class="keyword">audio_t</span>rack_play_mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AudioTrack.write</span></span><br><span class="line">    jmethodID <span class="keyword">audio_t</span>rack_write_mid = env-&gt;GetMethodID(<span class="keyword">audio_t</span>rack_class,<span class="string">"write"</span>,<span class="string">"([BII)I"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存了16bit  44100 PCM 采样数据</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *out_buffer = (<span class="keyword">uint8_t</span> *)av_malloc(MAX_AUDIO_FRAME_SIZE); <span class="comment">//unsigned char</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> got_frame = <span class="number">0</span>, frame_count = <span class="number">0</span>, ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不断读取压缩数据</span></span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(pFormatCtx,packet) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//解码音频类型的Packet</span></span><br><span class="line">        <span class="keyword">if</span>(packet-&gt;stream_index == audio_stream_idx)&#123;</span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            ret = avcodec_decode_audio4(pCodecCtx, frame,&amp;got_frame,packet);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                LOGE(<span class="string">"%s"</span>, <span class="string">"解码错误"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解码一帧成功</span></span><br><span class="line">            <span class="keyword">if</span> (got_frame &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                LOGI(<span class="string">"解码: %d"</span>,frame_count++);</span><br><span class="line">                swr_convert(swrContext, &amp;out_buffer, MAX_AUDIO_FRAME_SIZE,</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) frame-&gt;data, frame-&gt;nb_samples);</span><br><span class="line">                <span class="comment">//获取sample的大小</span></span><br><span class="line">                <span class="keyword">int</span> out_buffer_size = av_samples_get_buffer_size(NULL,out_channel_nb,frame-&gt;nb_samples,out_sample_fmt,<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//AudioTrack.writePCM数据</span></span><br><span class="line">                <span class="comment">//out_buffer缓冲区数据,转成byte数组</span></span><br><span class="line">                jbyteArray  audio_sample_array = env-&gt;NewByteArray(out_buffer_size);</span><br><span class="line">                jbyte* sample_bytep = env-&gt;GetByteArrayElements(audio_sample_array,NULL);</span><br><span class="line">                <span class="comment">//out_buffer的数据复制到sample_bytep</span></span><br><span class="line">                <span class="built_in">memcpy</span>(sample_bytep,out_buffer,out_buffer_size);</span><br><span class="line">                <span class="comment">//同步</span></span><br><span class="line">                env-&gt;ReleaseByteArrayElements(audio_sample_array,sample_bytep,<span class="number">0</span>);</span><br><span class="line">                env-&gt;CallIntMethod(<span class="keyword">audio_t</span>rack,<span class="keyword">audio_t</span>rack_write_mid,</span><br><span class="line">                                   audio_sample_array,<span class="number">0</span>,out_buffer_size);</span><br><span class="line">                <span class="comment">//释放局部引用</span></span><br><span class="line">                env-&gt;DeleteLocalRef(audio_sample_array);</span><br><span class="line">                usleep(<span class="number">1000</span> * <span class="number">16</span>);<span class="comment">//16毫秒</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_free_packet(packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">    av_free(out_buffer);</span><br><span class="line"></span><br><span class="line">    swr_free(&amp;swrContext);</span><br><span class="line">    avcodec_close(pCodecCtx);</span><br><span class="line">    avformat_close_input(&amp;pFormatCtx);</span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(input_, input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_VideoPlayer_sound</span><span class="params">(JNIEnv *env, jobject instance, jstring input_,</span><br><span class="line">                                             jstring output_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input = env-&gt;GetStringUTFChars(input_, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *output = env-&gt;GetStringUTFChars(output_, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">    <span class="comment">//1.注册所有组件</span></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装格式上下文，统领全局的结构体，保存了音视频文件封装格式的相关信息</span></span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.打开音频文件</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx, input, NULL, NULL) != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法打开音频文件"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取音频文件信息</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(pFormatCtx, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法获输入文件信息"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取音频流的索引位置</span></span><br><span class="line">    <span class="comment">//遍历所有类型的流（音频流、视频流、字幕流），找到音频流</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, audio_stream_idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//number of streams</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="comment">//流的类型</span></span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;<span class="keyword">codec_t</span>ype == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            audio_stream_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio_stream_idx == -<span class="number">1</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到音频流\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取音频流中的编解码上下文</span></span><br><span class="line">    AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[audio_stream_idx]-&gt;codec;</span><br><span class="line">    <span class="comment">//4.根据编解码上下文中的编码id查找对应的解码</span></span><br><span class="line">    AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">    <span class="comment">//（迅雷看看，找不到解码器，临时下载一个解码器）</span></span><br><span class="line">    <span class="keyword">if</span> (pCodec == NULL) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到解码器\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.打开解码器</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法打开解码器\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出音频信息</span></span><br><span class="line">    LOGI(<span class="string">"音频的文件格式：%s"</span>, pFormatCtx-&gt;iformat-&gt;name);</span><br><span class="line">    LOGI(<span class="string">"音频时长：%lld"</span>, (pFormatCtx-&gt;duration) / <span class="number">1000000</span>);</span><br><span class="line">    LOGI(<span class="string">"音频的宽高：%d,%d"</span>, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line">    LOGI(<span class="string">"解码器的名称：%s"</span>, pCodec-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压缩数据</span></span><br><span class="line">    AVPacket *packet = (AVPacket *)av_malloc(<span class="keyword">sizeof</span>(AVPacket));</span><br><span class="line">    <span class="comment">//解压缩数据</span></span><br><span class="line">    AVFrame *frame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//frame-&gt;16bit  44100 PCM 统一音频采样格式与采样率</span></span><br><span class="line"></span><br><span class="line">    SwrContext *swrContext = swr_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重采样设置参数</span></span><br><span class="line">    <span class="comment">//输入的采样格式</span></span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat  in_sample_fmt = pCodecCtx-&gt;sample_fmt;</span><br><span class="line">    <span class="comment">//输出的采样格式16bit PCM</span></span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">    <span class="comment">//输入采样率</span></span><br><span class="line">    <span class="keyword">int</span> in_sample_rate = pCodecCtx-&gt;sample_rate;</span><br><span class="line">    <span class="comment">//输出采样率</span></span><br><span class="line">    <span class="keyword">int</span> out_sample_rate = in_sample_rate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取输入的声道布局 参加AudioFormat.java  286行</span></span><br><span class="line">    <span class="comment">//根据声道个数获取默认的声道布局(2个声道,默认立体声CHANNEL_OUT_STEREO)</span></span><br><span class="line">    <span class="comment">//CHANNEL_OUT_5POINT1 为5.1环绕声</span></span><br><span class="line">    <span class="comment">//av_get_default_channel_layout(pCodecCtx-&gt;channels);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span>  in_ch_layout = pCodecCtx-&gt;channel_layout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出的声道布局</span></span><br><span class="line">    <span class="keyword">int64_t</span> out_ch_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出的声道个数</span></span><br><span class="line">    <span class="keyword">int</span> out_channel_nb = av_get_channel_layout_nb_channels(out_ch_layout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> log_offset = <span class="number">0</span>; <span class="comment">// 不偏移</span></span><br><span class="line"></span><br><span class="line">    swr_alloc_set_opts(swrContext,</span><br><span class="line">                       out_ch_layout, out_sample_fmt, out_sample_rate,</span><br><span class="line">                       in_ch_layout, in_sample_fmt, in_sample_rate,</span><br><span class="line">                       log_offset, NULL);</span><br><span class="line">    swr_init(swrContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存了16bit  44100 PCM 采样数据</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *out_buffer = (<span class="keyword">uint8_t</span> *)av_malloc(MAX_AUDIO_FRAME_SIZE); <span class="comment">//unsigned char</span></span><br><span class="line"></span><br><span class="line">    FILE *fp_pcm = fopen(output, <span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> got_frame = <span class="number">0</span>, frame_count = <span class="number">0</span>, ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不断读取压缩数据</span></span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(pFormatCtx,packet) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//解码音频类型的Packet</span></span><br><span class="line">        <span class="keyword">if</span>(packet-&gt;stream_index == audio_stream_idx)&#123;</span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            ret = avcodec_decode_audio4(pCodecCtx, frame,&amp;got_frame,packet);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                LOGE(<span class="string">"%s"</span>, <span class="string">"解码错误"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解码一帧成功</span></span><br><span class="line">            <span class="keyword">if</span> (got_frame &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                LOGI(<span class="string">"解码: %d"</span>,frame_count++);</span><br><span class="line">                swr_convert(swrContext, &amp;out_buffer, MAX_AUDIO_FRAME_SIZE,</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) frame-&gt;data, frame-&gt;nb_samples);</span><br><span class="line">                <span class="comment">//获取sample的大小</span></span><br><span class="line">                <span class="keyword">int</span> out_buffer_size = av_samples_get_buffer_size(NULL,out_channel_nb,frame-&gt;nb_samples,out_sample_fmt,<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//uint8_t *out_buffer---unsigned char--1</span></span><br><span class="line">                fwrite(out_buffer,<span class="number">1</span>,out_buffer_size,fp_pcm);</span><br><span class="line">            &#125;</span><br><span class="line">            av_free_packet(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGI(<span class="string">"解码完成"</span>);</span><br><span class="line">    fclose(fp_pcm);</span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">    av_free(out_buffer);</span><br><span class="line">    swr_free(&amp;swrContext);</span><br><span class="line">    avcodec_close(pCodecCtx);</span><br><span class="line">    avformat_close_input(&amp;pFormatCtx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(input_, input);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(output_, output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_VideoPlayer_render</span><span class="params">(JNIEnv *env, jobject instance, jstring input_,</span><br><span class="line">                                              jobject surface)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要转码的视频文件(输入的视频文件)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input_cstr = env-&gt;GetStringUTFChars(input_, NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">    <span class="comment">//1.注册所有组件</span></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装格式上下文，统领全局的结构体，保存了视频文件封装格式的相关信息</span></span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.打开输入视频文件</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx, input_cstr, NULL, NULL) != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法打开输入视频文件"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取视频文件信息</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(pFormatCtx, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法获取视频文件信息"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取视频流的索引位置</span></span><br><span class="line">    <span class="comment">//遍历所有类型的流（音频流、视频流、字幕流），找到视频流</span></span><br><span class="line">    <span class="keyword">int</span> v_stream_idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//number of streams</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="comment">//流的类型</span></span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;<span class="keyword">codec_t</span>ype == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">            v_stream_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v_stream_idx == -<span class="number">1</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到视频流\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有知道视频的编码方式，才能够根据编码方式去找到解码器</span></span><br><span class="line">    <span class="comment">//获取视频流中的编解码上下文</span></span><br><span class="line">    AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[v_stream_idx]-&gt;codec;</span><br><span class="line">    <span class="comment">//4.根据编解码上下文中的编码id查找对应的解码</span></span><br><span class="line">    AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">    <span class="comment">//（迅雷看看，找不到解码器，临时下载一个解码器）</span></span><br><span class="line">    <span class="keyword">if</span> (pCodec == NULL) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到解码器\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.打开解码器</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"解码器无法打开\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出视频信息</span></span><br><span class="line">    LOGI(<span class="string">"视频的文件格式：%s"</span>, pFormatCtx-&gt;iformat-&gt;name);</span><br><span class="line">    LOGI(<span class="string">"视频时长：%lld"</span>, (pFormatCtx-&gt;duration) / <span class="number">1000000</span>);</span><br><span class="line">    LOGI(<span class="string">"视频的宽高：%d,%d"</span>, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line">    LOGI(<span class="string">"解码器的名称：%s"</span>, pCodec-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备读取</span></span><br><span class="line">    <span class="comment">//AVPacket用于存储一帧一帧的压缩数据（H264）</span></span><br><span class="line">    <span class="comment">//缓冲区，开辟空间</span></span><br><span class="line">    <span class="comment">//AVPacket *packet; //编码数据</span></span><br><span class="line">    <span class="comment">//av_init_packet(packet);</span></span><br><span class="line">    AVPacket *packet = (AVPacket *) av_malloc(<span class="keyword">sizeof</span>(AVPacket));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AVFrame用于存储解码后的像素数据(YUV)</span></span><br><span class="line">    <span class="comment">//内存分配</span></span><br><span class="line">    AVFrame *yuv_frame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    AVFrame *rgb_frame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//native绘制</span></span><br><span class="line">    <span class="comment">//窗体</span></span><br><span class="line">    ANativeWindow*  nativeWindow = ANativeWindow_fromSurface(env, surface);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制时的缓冲区</span></span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> got_picture, ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> frame_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.一帧一帧的读取压缩数据</span></span><br><span class="line">    <span class="keyword">while</span> (av_read_frame(pFormatCtx, packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//只要视频压缩数据（根据流的索引位置判断）</span></span><br><span class="line">        <span class="keyword">if</span> (packet-&gt;stream_index == v_stream_idx) &#123;</span><br><span class="line">            <span class="comment">//7.解码一帧视频压缩数据，得到视频像素数据</span></span><br><span class="line">            <span class="comment">//解码 AVPacket-&gt;AVFrame</span></span><br><span class="line">            ret = avcodec_decode_video2(pCodecCtx, yuv_frame, &amp;got_picture, packet);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                LOGE(<span class="string">"%s"</span>, <span class="string">"解码错误"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为0说明解码完成，非0正在解码</span></span><br><span class="line">            <span class="keyword">if</span> (got_picture) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//lock</span></span><br><span class="line">                <span class="comment">//设置缓冲区的属性(宽、高、像素格式)  这里应该和SurfaceView上指定的format一致</span></span><br><span class="line">                ANativeWindow_setBuffersGeometry(nativeWindow,</span><br><span class="line">                                                         pCodecCtx-&gt;width, pCodecCtx-&gt;height, WINDOW_FORMAT_RGBA_8888);</span><br><span class="line">                ANativeWindow_lock(nativeWindow,&amp;outBuffer,NULL);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//YUV-&gt;RGBA_8888</span></span><br><span class="line">                <span class="comment">//pCodecCtx-&gt;pix_fmt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置rgb_frame的属性(像素格式、宽高)和缓冲区</span></span><br><span class="line">                avpicture_fill((AVPicture *)rgb_frame, (<span class="keyword">uint8_t</span> *)outBuffer.bits, AV_PIX_FMT_RGBA,pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//fill buffer   data[0] 是Y 的数据, linesize[0]是Y的一行的大小</span></span><br><span class="line">                <span class="comment">//rgb_frame的缓冲区与outBuffer.bits是同一块内存</span></span><br><span class="line">                I420ToARGB(yuv_frame-&gt;data[<span class="number">0</span>],yuv_frame-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                           yuv_frame-&gt;data[<span class="number">2</span>],yuv_frame-&gt;linesize[<span class="number">2</span>],</span><br><span class="line">                           yuv_frame-&gt;data[<span class="number">1</span>],yuv_frame-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">                           rgb_frame-&gt;data[<span class="number">0</span>], rgb_frame-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                           pCodecCtx-&gt;width,pCodecCtx-&gt;height</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//unlock</span></span><br><span class="line">                ANativeWindow_unlockAndPost(nativeWindow);</span><br><span class="line"></span><br><span class="line">                frame_count++;</span><br><span class="line">                LOGI(<span class="string">"解码第%d帧"</span>, frame_count);</span><br><span class="line"></span><br><span class="line">                usleep(<span class="number">1000</span> * <span class="number">16</span>);<span class="comment">//16毫秒</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        av_free_packet(packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    ANativeWindow_release(nativeWindow);</span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(input_, input_cstr);</span><br><span class="line"></span><br><span class="line">    av_frame_free(&amp;yuv_frame);</span><br><span class="line"></span><br><span class="line">    avcodec_close(pCodecCtx);</span><br><span class="line"></span><br><span class="line">    avformat_free_context(pFormatCtx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_MainActivity_decode</span><span class="params">(JNIEnv *env, jclass type, jstring input_,</span><br><span class="line">                                               jstring output_)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要转码的视频文件(输入的视频文件)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input_cstr = env-&gt;GetStringUTFChars(input_, NULL);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *output_cstr = env-&gt;GetStringUTFChars(output_, NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">    <span class="comment">//1.注册所有组件</span></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装格式上下文，统领全局的结构体，保存了视频文件封装格式的相关信息</span></span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.打开输入视频文件</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx, input_cstr, NULL, NULL) != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法打开输入视频文件"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取视频文件信息</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(pFormatCtx, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法获取视频文件信息"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取视频流的索引位置</span></span><br><span class="line">    <span class="comment">//遍历所有类型的流（音频流、视频流、字幕流），找到视频流</span></span><br><span class="line">    <span class="keyword">int</span> v_stream_idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//number of streams</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="comment">//流的类型</span></span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;<span class="keyword">codec_t</span>ype == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">            v_stream_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v_stream_idx == -<span class="number">1</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到视频流\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有知道视频的编码方式，才能够根据编码方式去找到解码器</span></span><br><span class="line">    <span class="comment">//获取视频流中的编解码上下文</span></span><br><span class="line">    AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[v_stream_idx]-&gt;codec;</span><br><span class="line">    <span class="comment">//4.根据编解码上下文中的编码id查找对应的解码</span></span><br><span class="line">    AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">    <span class="comment">//（迅雷看看，找不到解码器，临时下载一个解码器）</span></span><br><span class="line">    <span class="keyword">if</span> (pCodec == NULL) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到解码器\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.打开解码器</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"解码器无法打开\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出视频信息</span></span><br><span class="line">    LOGI(<span class="string">"视频的文件格式：%s"</span>, pFormatCtx-&gt;iformat-&gt;name);</span><br><span class="line">    LOGI(<span class="string">"视频时长：%lld"</span>, (pFormatCtx-&gt;duration) / <span class="number">1000000</span>);</span><br><span class="line">    LOGI(<span class="string">"视频的宽高：%d,%d"</span>, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line">    LOGI(<span class="string">"解码器的名称：%s"</span>, pCodec-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备读取</span></span><br><span class="line">    <span class="comment">//AVPacket用于存储一帧一帧的压缩数据（H264）</span></span><br><span class="line">    <span class="comment">//缓冲区，开辟空间</span></span><br><span class="line">    <span class="comment">//AVPacket *packet; //编码数据</span></span><br><span class="line">    <span class="comment">//av_init_packet(packet);</span></span><br><span class="line">    AVPacket *packet = (AVPacket *) av_malloc(<span class="keyword">sizeof</span>(AVPacket));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AVFrame用于存储解码后的像素数据(YUV)</span></span><br><span class="line">    <span class="comment">//内存分配</span></span><br><span class="line">    AVFrame *pFrame = av_frame_alloc();</span><br><span class="line">    <span class="comment">//YUV420 像素数据(解码数据)</span></span><br><span class="line">    AVFrame *pFrameYUV = av_frame_alloc();</span><br><span class="line">    <span class="comment">//只有指定了AVFrame的像素格式、画面大小才能真正分配内存</span></span><br><span class="line">    <span class="comment">//缓冲区分配内存</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *out_buffer = (<span class="keyword">uint8_t</span> *) av_malloc(</span><br><span class="line">            avpicture_get_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height));</span><br><span class="line">    <span class="comment">//初始化缓冲区</span></span><br><span class="line">    avpicture_fill((AVPicture *) pFrameYUV, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width,</span><br><span class="line">                   pCodecCtx-&gt;height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于转码（缩放）的参数，转之前的宽高，转之后的宽高，格式等</span></span><br><span class="line">    <span class="keyword">struct</span> SwsContext *sws_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class="line">                                                pCodecCtx-&gt;pix_fmt,</span><br><span class="line">                                                pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class="line">                                                AV_PIX_FMT_YUV420P,</span><br><span class="line">                                                SWS_BICUBIC, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> got_picture, ret;</span><br><span class="line"></span><br><span class="line">    FILE *fp_yuv = fopen(output_cstr, <span class="string">"wb+"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> frame_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.一帧一帧的读取压缩数据</span></span><br><span class="line">    <span class="keyword">while</span> (av_read_frame(pFormatCtx, packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//只要视频压缩数据（根据流的索引位置判断）</span></span><br><span class="line">        <span class="keyword">if</span> (packet-&gt;stream_index == v_stream_idx) &#123;</span><br><span class="line">            <span class="comment">//7.解码一帧视频压缩数据，得到视频像素数据</span></span><br><span class="line">            ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                LOGE(<span class="string">"%s"</span>, <span class="string">"解码错误"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为0说明解码完成，非0正在解码</span></span><br><span class="line">            <span class="keyword">if</span> (got_picture) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//AVFrame转为像素格式YUV420，宽高</span></span><br><span class="line">                <span class="comment">//2 6输入、输出数据</span></span><br><span class="line">                <span class="comment">//3 7输入、输出画面一行的数据的大小 AVFrame 转换是一行一行转换的</span></span><br><span class="line">                <span class="comment">//4 输入数据第一列要转码的位置 从0开始</span></span><br><span class="line">                <span class="comment">//5 输入画面的高度</span></span><br><span class="line">                sws_scale(sws_ctx, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **)pFrame-&gt;data, pFrame-&gt;linesize, <span class="number">0</span>, pCodecCtx-&gt;height,</span><br><span class="line">                          pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//输出到YUV文件</span></span><br><span class="line">                <span class="comment">//AVFrame像素帧写入文件</span></span><br><span class="line">                <span class="comment">//data解码后的图像像素数据（音频采样数据）</span></span><br><span class="line">                <span class="comment">//Y 亮度 UV 色度（压缩了） 人对亮度更加敏感</span></span><br><span class="line">                <span class="comment">//U V 个数是Y的1/4</span></span><br><span class="line">                <span class="keyword">int</span> y_size = pCodecCtx-&gt;width * pCodecCtx-&gt;height;</span><br><span class="line">                fwrite(pFrameYUV-&gt;data[<span class="number">0</span>], <span class="number">1</span>, y_size, fp_yuv);</span><br><span class="line">                fwrite(pFrameYUV-&gt;data[<span class="number">1</span>], <span class="number">1</span>, y_size / <span class="number">4</span>, fp_yuv);</span><br><span class="line">                fwrite(pFrameYUV-&gt;data[<span class="number">2</span>], <span class="number">1</span>, y_size / <span class="number">4</span>, fp_yuv);</span><br><span class="line"></span><br><span class="line">                frame_count++;</span><br><span class="line">                LOGI(<span class="string">"解码第%d帧"</span>, frame_count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        av_free_packet(packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp_yuv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(input_, input_cstr);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(output_, output_cstr);</span><br><span class="line"></span><br><span class="line">    av_frame_free(&amp;pFrame);</span><br><span class="line"></span><br><span class="line">    avcodec_close(pCodecCtx);</span><br><span class="line"></span><br><span class="line">    avformat_free_context(pFormatCtx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function">jstring</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_MainActivity_stringFromJNI</span><span class="params">(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">"Hello from C++"</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注: 播放音频时务必使用真机,模拟机不支持AudioTrack播放pcm格式音频</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/08/04/android_ffmpeg_3/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">FFmpeg和libyuv的基本使用(四)</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="android_ffmpeg_4" data-title="FFmpeg和libyuv的基本使用(五)" data-url="http://yoursite.com/2017/08/04/android_ffmpeg_4/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 weifeng
    	</div>
      	<div class="footer-right">
      		<!--<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten-->
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>


  </div>
</body>
</html>