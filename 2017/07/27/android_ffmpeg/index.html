<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>FFmpeg和libyuv的基本使用 | Mobile Development</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="FFmpeg库简介FFmpeg一共包含8个库:
avodec: 编解码 (最重要的库)

avformat: 封装格式处理

avfilter: 滤镜特效处理

avdevice: 各种设备的输入输出">
<meta property="og:type" content="article">
<meta property="og:title" content="FFmpeg和libyuv的基本使用">
<meta property="og:url" content="http://yoursite.com/2017/07/27/android_ffmpeg/index.html">
<meta property="og:site_name" content="Mobile Development">
<meta property="og:description" content="FFmpeg库简介FFmpeg一共包含8个库:
avodec: 编解码 (最重要的库)

avformat: 封装格式处理

avfilter: 滤镜特效处理

avdevice: 各种设备的输入输出">
<meta property="og:image" content="http://7xk9ih.com1.z0.glb.clouddn.com/Snip20170728_3.png">
<meta property="og:image" content="http://7xk9ih.com1.z0.glb.clouddn.com/Snip20170728_4.png">
<meta property="og:image" content="http://7xk9ih.com1.z0.glb.clouddn.com/67A9C81A-FCC9-4DFA-8A0A-DFD8E2C15D75.png">
<meta property="og:image" content="http://7xk9ih.com1.z0.glb.clouddn.com/65E470C3-D8AC-44CF-90C1-06D80EEBCF97.png">
<meta property="og:image" content="http://7xk9ih.com1.z0.glb.clouddn.com/Snip20170804_2.png">
<meta property="og:image" content="http://7xk9ih.com1.z0.glb.clouddn.com/Snip20170804_android_javap.png">
<meta property="og:image" content="http://7xk9ih.com1.z0.glb.clouddn.com/Snip20170804_javah.png">
<meta property="og:updated_time" content="2017-08-04T06:25:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FFmpeg和libyuv的基本使用">
<meta name="twitter:description" content="FFmpeg库简介FFmpeg一共包含8个库:
avodec: 编解码 (最重要的库)

avformat: 封装格式处理

avfilter: 滤镜特效处理

avdevice: 各种设备的输入输出">
  
    <link rel="alternative" href="/atom.xml" title="Mobile Development" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://img0.imgtn.bdimg.com/it/u=781933599,3526596667&amp;fm=21&amp;gp=0.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">weifeng</a></h1>
		</hgroup>

		
		<p class="header-subtitle">移动开发</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://android-arsenal.com/">Android Arsenal</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.androiddevtools.cn/">AndroidDevTools</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://androidweekly.net/">Android Weekly</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://android-libs.com/">AndroidLibs</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://xjanker.github.io/akita/">Akita</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://dusunboy.github.io/android-nice-repo/">Android 开源项目</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://hmkcode.com/">HMKCode</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://weekly.manong.io/issues/">码农周刊</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://toutiao.io/">开发者头条</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.androidweekly.cn/">Android开发技术周报</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.devtf.cn/">开发技术前线</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://gank.io/">干货集中营</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.androidchina.net/">AndroidChina</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.codeceo.com/">码农网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jcodecraeer.com/">泡在网上的日子</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jobbole.com/">伯乐在线</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.kuqin.com/">酷勤网</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.akaifa.com/">爱开发</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://androidperformance.com/">Performance Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.lightskystreet.com/">lightSky Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.guolingfa.cn/">GuoBlog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://yanshi.name/">Kinney&#39;s Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.inferjay.com/">脉脉不得语的技术博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://droidyue.com/">技术小黑屋</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://sunjiajia.com/">安卓猴Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.race604.com/">Jlog博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.apkdv.com/">LengYue&#39;s Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://wuyexiong.github.io/">Wuyexiong de Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.25xt.com/">25学堂</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://get.jobdeer.com/">Get社区</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://evis.me/tag/app/">壹维思_EVIS</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://weirss.me/">WeiRSS</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://next.36kr.com/posts">NEXT</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">Android 开发</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">weifeng</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://img0.imgtn.bdimg.com/it/u=781933599,3526596667&amp;fm=21&amp;gp=0.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">weifeng</h1>
			</hgroup>
			
			<p class="header-subtitle">移动开发</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-android_ffmpeg" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/07/27/android_ffmpeg/" class="article-date">
  	<time datetime="2017-07-27T13:58:22.000Z" itemprop="datePublished">2017-07-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      FFmpeg和libyuv的基本使用
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="FFmpeg库简介">FFmpeg库简介</h3><h4 id="FFmpeg一共包含8个库:">FFmpeg一共包含8个库:</h4><ul>
<li><p>avodec: 编解码 (最重要的库)</p>
</li>
<li><p>avformat: 封装格式处理</p>
</li>
<li><p>avfilter: 滤镜特效处理</p>
</li>
<li><p>avdevice: 各种设备的输入输出</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>avutil: 工具库(大部分都需要这个库的支持)</p>
</li>
<li><p>postproc: 后加工</p>
</li>
<li><p>swresample: 音频采样数据格式转换</p>
</li>
<li><p>swscale: 视频像素数据格式转换</p>
</li>
</ul>
<h4 id="FFmpeg解码的流程图">FFmpeg解码的流程图</h4><p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/Snip20170728_3.png" alt=""></p>
<h4 id="FFmpeg解码函数简介">FFmpeg解码函数简介</h4><ul>
<li><p>av_register_all(): 注册所有组件</p>
</li>
<li><p>avformat_open_input(): 打开输入视频文件</p>
</li>
<li><p>avformat_find_stream_info(): 获取视频文件信息</p>
</li>
<li><p>avcodec_find_decoder(): 查找解码器</p>
</li>
<li><p>avcodec_open2(): 打开解码器</p>
</li>
<li><p>av_read_frame(): 从输入文件读取一帧压缩数据</p>
</li>
<li><p>avcodec_decode_vide2(): 解码一帧压缩数据</p>
</li>
<li><p>avcodec_close(): 关闭解码器</p>
</li>
<li><p>avformat_close_input(): 关闭输入视频文件 </p>
</li>
</ul>
<h4 id="FFmpeg解码的数据结构">FFmpeg解码的数据结构</h4><p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/Snip20170728_4.png" alt=""></p>
<h4 id="FFmpeg数据结构简介">FFmpeg数据结构简介</h4><ul>
<li><p>AVFormatContext</p>
<ul>
<li>封装格式上下文结构体,也是统领全局的结构体,保存了视频文件封装格式相关信息</li>
</ul>
</li>
<li><p>AVInputFormat</p>
<ul>
<li>每种封装格式(例如FLV,KVM,MP4,AVI)对应一个该结构体</li>
</ul>
</li>
<li><p>AVStream</p>
<ul>
<li>视频文件中每个视频(音频)流对应一个该结构体.(是一个数组,数量是不确定的,一般第0个都是视频流,第1个都是音频流)</li>
</ul>
</li>
<li><p>AVCodecContext</p>
<ul>
<li>编解码器上下文结构体,保存了视频(音频)编解码相关信息.(被更新了,现在使用AVCodecParameters,但是很多api并没有更新所以我们依旧使用AVCodecContext)</li>
</ul>
</li>
<li><p>AVCodec</p>
<ul>
<li>每种视频(音频)编解码器(例如H.264解码器)对应一个该结构体.(指明了编码器是什么类型的)</li>
</ul>
</li>
<li><p>AVPacket</p>
<ul>
<li>存储一帧压缩编码数据</li>
</ul>
</li>
<li><p>AVFrame</p>
<ul>
<li>存储一帧解码后像素(采样)数据</li>
</ul>
</li>
</ul>
<h4 id="FFmpeg数据结构的内容">FFmpeg数据结构的内容</h4><ul>
<li><p>AVFormatContext</p>
<ul>
<li>iformat: 输入视频的AVInputFormat</li>
<li>nb_streams: 输入视频的AVStream 个数</li>
<li>streams: 输入视频的AVStream []数组</li>
<li>duration: 输入视频的时长 (以微妙为单位)</li>
<li>bit_rate: 输入视频的码率</li>
</ul>
</li>
<li><p>AVInputFormat</p>
<ul>
<li>name: 封装格式名称</li>
<li>long_name: 封装格式的长名称</li>
<li>extensions: 封装格式的扩展名</li>
<li>id: 封装格式ID</li>
<li>一些封装格式处理的接口函数</li>
</ul>
</li>
<li><p>AVStream</p>
<ul>
<li>id: 序号</li>
<li>codec: 该流对应的AVCodecContext</li>
<li>time_base: 该流的时基</li>
<li>r_frame_rate: 该流的帧率</li>
</ul>
</li>
<li><p>AVCodecContext</p>
<ul>
<li>codec: 编解码器的AVCodec</li>
<li>width, height: 图形的宽高 (只针对视频)</li>
<li>pix_fmt: 像素格式 (只针对视频)</li>
<li>sample_rare: 采样率 (只针对音频)</li>
<li>channels: 声道数 (只针对音频)</li>
<li>sample_fmt: 采样格式 (只针对音频)</li>
</ul>
</li>
<li><p>AVCodec</p>
<ul>
<li>name: 编解码器名称</li>
<li>long_name: 编解码器长名称</li>
<li>type: 编解码器类型</li>
<li>id: 编解码器ID</li>
<li>一些编解码的接口函数</li>
</ul>
</li>
<li><p>AVPacket</p>
<ul>
<li>pts: 显示时间戳</li>
<li>dts: 解码时间戳</li>
<li>data: 压缩编码数据</li>
<li>size: 压缩编码数据大小</li>
<li>stream_index: 所属的AVStream</li>
</ul>
</li>
<li><p>AVFrame</p>
<ul>
<li>data: 编码后的图像像素数据 (音频采样数据)</li>
<li>linesize: 对视频来说是图像中一行像素的大小;对音频来说是整个音频帧的大小</li>
<li>width, height: 图像的宽高 (只针对视频)</li>
<li>key_frame: 是否为关键帧 (只针对视频)</li>
<li>pict_type: 帧类型 (只针对视频) 例如I, P, B</li>
</ul>
</li>
</ul>
<h4 id="示例程序">示例程序</h4><ul>
<li>位置: <code>FFmpeg-master/doc/examples</code></li>
</ul>
<h4 id="编译FFmpeg动态库">编译FFmpeg动态库</h4><p>生成x86_64平台下动态库</p>
<ul>
<li><p>进入FFmpeg-master源码目录</p>
</li>
<li><p><code>touch config.sh</code> 添加如下内容</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NDK=/Users/weifeng/Library/Android/sdk/ndk-bundle</span><br><span class="line">SYSROOT=<span class="variable">$NDK</span>/platforms/android-<span class="number">22</span>/arch-x86_64</span><br><span class="line">TOOLCHAIN=<span class="variable">$NDK</span>/toolchains/x86_64-<span class="number">4.9</span>/prebuilt/darwin-x86_64</span><br><span class="line">CPU=x86_64</span><br></pre></td></tr></table></figure>
<ul>
<li><code>touch build_android.sh</code> 添加如下内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="shebang">#!/bin/sh</span><br><span class="line"></span></span><br><span class="line">. config.sh</span><br><span class="line"></span><br><span class="line">PREFIX=$(<span class="built_in">pwd</span>)/android/<span class="variable">$CPU</span></span><br><span class="line">ADDI_CFLAGS=<span class="string">""</span></span><br><span class="line"><span class="keyword">function</span> build_android</span><br><span class="line">&#123;</span><br><span class="line">./configure \</span><br><span class="line">    --prefix=<span class="variable">$PREFIX</span> \</span><br><span class="line">    --enable-shared \</span><br><span class="line">    --disable-static \</span><br><span class="line">    --disable-doc \</span><br><span class="line">    --disable-ffmpeg \</span><br><span class="line">    --disable-ffplay \</span><br><span class="line">    --disable-ffprobe \</span><br><span class="line">    --disable-ffserver \</span><br><span class="line">    --disable-doc \</span><br><span class="line">    --disable-symver \</span><br><span class="line">    --disable-x86asm \</span><br><span class="line">    --enable-gpl \</span><br><span class="line">    --cross-prefix=<span class="variable">$TOOLCHAIN</span>/bin/x86_64-linux-android- \</span><br><span class="line">    --target-os=linux \</span><br><span class="line">    --arch=x86_64 \</span><br><span class="line">    --enable-cross-compile \</span><br><span class="line">    --sysroot=<span class="variable">$SYSROOT</span> \</span><br><span class="line">    --extra-cflags=<span class="string">"-Os -fpic <span class="variable">$ADDI_CFLAGS</span>"</span> \</span><br><span class="line">    --extra-ldflags=<span class="string">"<span class="variable">$ADDI_LDFLAGS</span>"</span> \</span><br><span class="line">    <span class="variable">$ADDITIONAL_CONFIGURE_FLAG</span></span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">&#125;</span><br><span class="line">build_android</span><br></pre></td></tr></table></figure>
<ul>
<li>修改<code>configure</code>文件中<code># build settings</code>下内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># build settings</span></span><br><span class="line">SHFLAGS=<span class="string">'-shared -Wl,-soname,$$(@F)'</span></span><br><span class="line">LIBPREF=<span class="string">"lib"</span></span><br><span class="line">LIBSUF=<span class="string">".a"</span></span><br><span class="line">FULLNAME=<span class="string">'$(NAME)$(BUILDSUF)'</span></span><br><span class="line">LIBNAME=<span class="string">'$(LIBPREF)$(FULLNAME)$(LIBSUF)'</span></span><br><span class="line">SLIBPREF=<span class="string">"lib"</span></span><br><span class="line">SLIBSUF=<span class="string">".so"</span></span><br><span class="line">SLIBNAME=<span class="string">'$(SLIBPREF)$(FULLNAME)$(SLIBSUF)'</span></span><br><span class="line">SLIBNAME_WITH_VERSION=<span class="string">'$(SLIBNAME).$(LIBVERSION)'</span></span><br><span class="line">SLIBNAME_WITH_MAJOR=<span class="string">'$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'</span>  </span><br><span class="line">LIB_INSTALL_EXTRA_CMD=<span class="string">'$$(RANLIB)"$(LIBDIR)/$(LIBNAME)"'</span>  </span><br><span class="line">SLIB_INSTALL_NAME=<span class="string">'$(SLIBNAME_WITH_MAJOR)'</span>  </span><br><span class="line">SLIB_INSTALL_LINKS=<span class="string">'$(SLIBNAME)'</span></span><br><span class="line">VERSION_SCRIPT_POSTPROCESS_CMD=<span class="string">"cat"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>为<code>build_android.sh</code>和<code>config.sh</code>添加执行权限  <code>chmod u+x build_android.sh</code> 、 <code>chmod u+x config.sh</code></p>
</li>
<li><p>执行<code>./build_android.sh</code> 编译并生成动态库</p>
</li>
</ul>
<p>如果要生成arm平台下的动态库,则要修改<code>config.sh</code>和<code>build_android.sh</code>内容如下:</p>
<p><code>config.sh</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NDK=/Users/weifeng/Library/Android/sdk/ndk-bundle</span><br><span class="line">SYSROOT=<span class="variable">$NDK</span>/platforms/android-<span class="number">21</span>/arch-arm</span><br><span class="line">TOOLCHAIN=<span class="variable">$NDK</span>/toolchains/arm-linux-androideabi-<span class="number">4.9</span>/prebuilt/darwin-x86_64</span><br><span class="line">CPU=armv7<span class="operator">-a</span></span><br></pre></td></tr></table></figure>
<p><code>build_android.sh</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="shebang">#!/bin/sh</span><br><span class="line"></span></span><br><span class="line">. config.sh</span><br><span class="line"></span><br><span class="line">PREFIX=$(<span class="built_in">pwd</span>)/android/<span class="variable">$CPU</span></span><br><span class="line">ADDI_CFLAGS=<span class="string">"-marm"</span></span><br><span class="line"><span class="keyword">function</span> build_android</span><br><span class="line">&#123;</span><br><span class="line">./configure \</span><br><span class="line">    --prefix=<span class="variable">$PREFIX</span> \</span><br><span class="line">    --enable-shared \</span><br><span class="line">    --disable-static \</span><br><span class="line">    --disable-doc \</span><br><span class="line">    --disable-ffmpeg \</span><br><span class="line">    --disable-ffplay \</span><br><span class="line">    --disable-ffprobe \</span><br><span class="line">    --disable-ffserver \</span><br><span class="line">    --disable-doc \</span><br><span class="line">    --disable-symver \</span><br><span class="line">    --enable-gpl \</span><br><span class="line">    --cross-prefix=<span class="variable">$TOOLCHAIN</span>/bin/arm-linux-androideabi- \</span><br><span class="line">    --target-os=linux \</span><br><span class="line">    --arch=arm \</span><br><span class="line">    --enable-cross-compile \</span><br><span class="line">    --sysroot=<span class="variable">$SYSROOT</span> \</span><br><span class="line">    --extra-cflags=<span class="string">"-Os -fpic <span class="variable">$ADDI_CFLAGS</span>"</span> \</span><br><span class="line">    --extra-ldflags=<span class="string">"<span class="variable">$ADDI_LDFLAGS</span>"</span> \</span><br><span class="line">    <span class="variable">$ADDITIONAL_CONFIGURE_FLAG</span></span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">&#125;</span><br><span class="line">build_android</span><br></pre></td></tr></table></figure>
<h4 id="编译libyuv动态库">编译libyuv动态库</h4><p>如果需要将YUV格式转RGBA像素格式,建议使用另外一个开源库<code>libyuv</code>,接下来教大家编译并生成<code>libyuv.so</code>库</p>
<ul>
<li><p>下载<a href="https://chromium.googlesource.com/libyuv/libyuv/" target="_blank" rel="external">libyuv</a>源代码</p>
</li>
<li><p>使用git clone下来 <code>git clone https://chromium.googlesource.com/libyuv/libyuv</code></p>
</li>
<li><p><code>cd libyuv</code> 进入libyuv源码目录,新建jni目录<code>mkdir jni</code>将源码拷贝到jni目录下</p>
</li>
<li><p>修改Android.mk文件</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This is the Android makefile for libyuv for both platform and NDK.</span></span><br><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_CPP_EXTENSION := .cc</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES := \</span><br><span class="line">    <span class="built_in">source</span>/compare.cc           \</span><br><span class="line">    <span class="built_in">source</span>/compare_common.cc    \</span><br><span class="line">    <span class="built_in">source</span>/convert.cc           \</span><br><span class="line">    <span class="built_in">source</span>/convert_argb.cc      \</span><br><span class="line">    <span class="built_in">source</span>/convert_from.cc      \</span><br><span class="line">    <span class="built_in">source</span>/convert_from_argb.cc \</span><br><span class="line">    <span class="built_in">source</span>/convert_to_argb.cc   \</span><br><span class="line">    <span class="built_in">source</span>/convert_to_i420.cc   \</span><br><span class="line">    <span class="built_in">source</span>/cpu_id.cc            \</span><br><span class="line">    <span class="built_in">source</span>/planar_functions.cc  \</span><br><span class="line">    <span class="built_in">source</span>/rotate.cc            \</span><br><span class="line">    <span class="built_in">source</span>/rotate_any.cc        \</span><br><span class="line">    <span class="built_in">source</span>/rotate_argb.cc       \</span><br><span class="line">    <span class="built_in">source</span>/rotate_common.cc     \</span><br><span class="line">    <span class="built_in">source</span>/row_any.cc           \</span><br><span class="line">    <span class="built_in">source</span>/row_common.cc        \</span><br><span class="line">    <span class="built_in">source</span>/scale.cc             \</span><br><span class="line">    <span class="built_in">source</span>/scale_any.cc         \</span><br><span class="line">    <span class="built_in">source</span>/scale_argb.cc        \</span><br><span class="line">    <span class="built_in">source</span>/scale_common.cc      \</span><br><span class="line">    <span class="built_in">source</span>/video_common.cc</span><br><span class="line"></span><br><span class="line">ifeq ($(TARGET_ARCH_ABI),armeabi-v7a)</span><br><span class="line">    LOCAL_CFLAGS += -DLIBYUV_NEON</span><br><span class="line">    LOCAL_SRC_FILES += \</span><br><span class="line">        <span class="built_in">source</span>/compare_neon.cc.neon    \</span><br><span class="line">        <span class="built_in">source</span>/rotate_neon.cc.neon     \</span><br><span class="line">        <span class="built_in">source</span>/row_neon.cc.neon        \</span><br><span class="line">        <span class="built_in">source</span>/scale_neon.cc.neon</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(TARGET_ARCH_ABI),arm64-v8a)</span><br><span class="line">    LOCAL_CFLAGS += -DLIBYUV_NEON</span><br><span class="line">    LOCAL_SRC_FILES += \</span><br><span class="line">        <span class="built_in">source</span>/compare_neon64.cc    \</span><br><span class="line">        <span class="built_in">source</span>/rotate_neon64.cc     \</span><br><span class="line">        <span class="built_in">source</span>/row_neon64.cc        \</span><br><span class="line">        <span class="built_in">source</span>/scale_neon64.cc </span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(TARGET_ARCH_ABI),$(filter $(TARGET_ARCH_ABI), x86 x86_64))</span><br><span class="line">    LOCAL_SRC_FILES += \</span><br><span class="line">        <span class="built_in">source</span>/compare_gcc.cc       \</span><br><span class="line">        <span class="built_in">source</span>/rotate_gcc.cc        \</span><br><span class="line">        <span class="built_in">source</span>/row_gcc.cc           \</span><br><span class="line">        <span class="built_in">source</span>/scale_gcc.cc</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include</span><br><span class="line">LOCAL_C_INCLUDES += $(LOCAL_PATH)/include</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := libyuv</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line"></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure>
<ul>
<li>修改Application.mk文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">APP_ABI := armeabi-v7a arm64-v8a x86 x86_64</span><br><span class="line">APP_PLATFORM := android-<span class="number">9</span></span><br><span class="line">APP_CPPFLAGS += -fno-rtti</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>ndk-build</code>命令进行编译,每次执行<code>ndk-build</code>之前都需要<code>ndk-build clean</code>一遍才行,不然不会将新的改动编译进去。</li>
</ul>
<p>执行 <code>ndk-build NDK_PROJECT_PATH=/Users/weifeng/Downloads/libyuv NDK_APPLICATION_MK=/Users/weifeng/Downloads/libyuv/jni/Application.mk</code> 命令生成动态库</p>
<h4 id="新建并配置工程">新建并配置工程</h4><p>下面使用Android Studio 2.2.3来进行实例工程的开发</p>
<ul>
<li><p>新建FFmpegDemo 工程</p>
</li>
<li><p>将之前生成的FFmpeg头文件、FFmpeg动态库、libyuv头文件、libyuv动态库拷贝到libs目录下</p>
</li>
</ul>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/67A9C81A-FCC9-4DFA-8A0A-DFD8E2C15D75.png" alt=""></p>
<p>头文件如下图:</p>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/65E470C3-D8AC-44CF-90C1-06D80EEBCF97.png" alt=""></p>
<ul>
<li>整个CMakeLists文件内容如下:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sets the minimum version of CMake required to build the native</span></span><br><span class="line"><span class="comment"># library. You should either keep the default value or only pass a</span></span><br><span class="line"><span class="comment"># value of 3.4.0 or lower.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMakeLists.txt用于配置jni项目属性，主要用于声明CMake版本 so库名称 C/Cpp文件路径等信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cmake版本声明</span></span><br><span class="line">cmake_minimum_required(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates and names a library, sets it as either STATIC</span></span><br><span class="line"><span class="comment"># or SHARED, and provides the relative paths to its source code.</span></span><br><span class="line"><span class="comment"># You can define multiple libraries, and CMake builds it for you.</span></span><br><span class="line"><span class="comment"># Gradle automatically packages shared libraries with your APK.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加native-lib动态共享库</span></span><br><span class="line"><span class="comment"># 配置库信息,库的名字,动态库或静态库,依赖的源文件</span></span><br><span class="line"><span class="comment"># STATIC: 静态库,是目标文件的归档文件,在链接其它目标的时候使用。</span></span><br><span class="line"><span class="comment"># SHARED: 动态库,会被动态链接,在运行时被加载。</span></span><br><span class="line"><span class="comment"># MODULE: 模块库,是不会被链接到其它目标中的插件,但是可能会在运行时使用</span></span><br><span class="line"><span class="comment"># dlopen: -系列的函数动态链接。</span></span><br><span class="line">add_library( <span class="comment"># Sets the name of the library.</span></span><br><span class="line">             native-lib</span><br><span class="line"></span><br><span class="line">             <span class="comment"># Sets the library as a shared library.</span></span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             <span class="comment"># Provides a relative path to your source file(s).</span></span><br><span class="line">             <span class="comment"># Associated headers in the same location as their source</span></span><br><span class="line">             <span class="comment"># file are automatically included.</span></span><br><span class="line">             src/main/cpp/native-lib.cpp )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Searches for a specified prebuilt library and stores the path as a</span></span><br><span class="line"><span class="comment"># variable. Because system libraries are included in the search path by</span></span><br><span class="line"><span class="comment"># default, you only need to specify the name of the public NDK library</span></span><br><span class="line"><span class="comment"># you want to add. CMake verifies that the library exists before</span></span><br><span class="line"><span class="comment"># completing its build.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载NDK上的library  C++日志</span></span><br><span class="line"><span class="comment"># 查找链接库  在指定目录下搜索一个库,保存在变量log-lib中,如果没有指定路径,则使用默认系统路径</span></span><br><span class="line">find_library( <span class="comment"># Sets the name of the path variable.</span></span><br><span class="line">              <span class="built_in">log</span>-lib</span><br><span class="line">              <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">              <span class="comment"># you want CMake to locate.</span></span><br><span class="line">              <span class="built_in">log</span> )</span><br><span class="line"></span><br><span class="line">find_library( <span class="comment"># Sets the name of the path variable.</span></span><br><span class="line">              jnigraphics-lib</span><br><span class="line">              <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">              <span class="comment"># you want CMake to locate.</span></span><br><span class="line">              jnigraphics )</span><br><span class="line"></span><br><span class="line">find_library( <span class="comment"># Sets the name of the path variable.</span></span><br><span class="line">              android-lib</span><br><span class="line">              <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">              <span class="comment"># you want CMake to locate.</span></span><br><span class="line">              android )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置cmakelist的目标路径</span></span><br><span class="line"><span class="built_in">set</span>(distribution_DIR <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加so文件动态共享库</span></span><br><span class="line"><span class="comment"># SHARED: 动态库,会被动态链接,在运行时被加载。</span></span><br><span class="line"><span class="comment"># IMPORTED : 不需要编译,由外部导入</span></span><br><span class="line">add_library( avutil-<span class="number">55</span></span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># PROPERTIES IMPORTED_LOCATION: 需要从本地导入并配置导入文件的路径</span></span><br><span class="line"><span class="comment"># 设置动态库的路径 $&#123;CMAKE_SOURCE_DIR&#125;/libs/$&#123;ANDROID_ABI&#125;/libavutil-55.so</span></span><br><span class="line"><span class="comment"># $&#123;ANDROID_ABI&#125;表示so文件的ABI类型的路径</span></span><br><span class="line"><span class="built_in">set</span>_target_properties( avutil-<span class="number">55</span></span><br><span class="line">                       PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libs/<span class="variable">$&#123;ANDROID_ABI&#125;</span>/libavutil-<span class="number">55</span>.so )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_library( swresample-<span class="number">2</span></span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>_target_properties( swresample-<span class="number">2</span></span><br><span class="line">                       PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libs/<span class="variable">$&#123;ANDROID_ABI&#125;</span>/libswresample-<span class="number">2</span>.so )</span><br><span class="line">add_library( avcodec-<span class="number">57</span></span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED )</span><br><span class="line"><span class="built_in">set</span>_target_properties( avcodec-<span class="number">57</span></span><br><span class="line">                       PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libs/<span class="variable">$&#123;ANDROID_ABI&#125;</span>/libavcodec-<span class="number">57</span>.so )</span><br><span class="line">add_library( avfilter-<span class="number">6</span></span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED)</span><br><span class="line"><span class="built_in">set</span>_target_properties( avfilter-<span class="number">6</span></span><br><span class="line">                       PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libs/<span class="variable">$&#123;ANDROID_ABI&#125;</span>/libavfilter-<span class="number">6</span>.so )</span><br><span class="line">add_library( swscale-<span class="number">4</span></span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED)</span><br><span class="line"><span class="built_in">set</span>_target_properties( swscale-<span class="number">4</span></span><br><span class="line">                       PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libs/<span class="variable">$&#123;ANDROID_ABI&#125;</span>/libswscale-<span class="number">4</span>.so )</span><br><span class="line"></span><br><span class="line">add_library( avformat-<span class="number">57</span></span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED)</span><br><span class="line"><span class="built_in">set</span>_target_properties( avformat-<span class="number">57</span></span><br><span class="line">                       PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libs/<span class="variable">$&#123;ANDROID_ABI&#125;</span>/libavformat-<span class="number">57</span>.so )</span><br><span class="line"></span><br><span class="line">add_library( avdevice-<span class="number">57</span></span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED)</span><br><span class="line"><span class="built_in">set</span>_target_properties( avdevice-<span class="number">57</span></span><br><span class="line">                       PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libs/<span class="variable">$&#123;ANDROID_ABI&#125;</span>/libavdevice-<span class="number">57</span>.so )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_library( postproc-<span class="number">54</span></span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED)</span><br><span class="line"><span class="built_in">set</span>_target_properties( postproc-<span class="number">54</span></span><br><span class="line">                       PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libs/<span class="variable">$&#123;ANDROID_ABI&#125;</span>/libpostproc-<span class="number">54</span>.so )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_library( yuv</span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED)</span><br><span class="line"><span class="built_in">set</span>_target_properties( yuv</span><br><span class="line">                       PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/libs/<span class="variable">$&#123;ANDROID_ABI&#125;</span>/libyuv.so )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -std=gnu++11"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置头文件路径</span></span><br><span class="line">include_directories(libs/include/ffmpeg libs/include/yuv)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># include_directories(libs/include/yuv)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies libraries CMake should link to your target library. You</span></span><br><span class="line"><span class="comment"># can link multiple libraries, such as libraries you define in the</span></span><br><span class="line"><span class="comment"># build script, prebuilt third-party libraries, or system libraries.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成链接动态库</span></span><br><span class="line"><span class="comment"># 添加链接库,相同于指定-l参数</span></span><br><span class="line"><span class="comment"># 将需要的库文件进行链接</span></span><br><span class="line">target_link_libraries( <span class="comment"># Specifies the target library.</span></span><br><span class="line">                       native-lib</span><br><span class="line">                       avutil-<span class="number">55</span></span><br><span class="line">                       swresample-<span class="number">2</span></span><br><span class="line">                       avcodec-<span class="number">57</span></span><br><span class="line">                       avfilter-<span class="number">6</span></span><br><span class="line">                       swscale-<span class="number">4</span></span><br><span class="line">                       avformat-<span class="number">57</span></span><br><span class="line">                       avdevice-<span class="number">57</span></span><br><span class="line">                       postproc-<span class="number">54</span></span><br><span class="line">                       yuv</span><br><span class="line"></span><br><span class="line">                       <span class="comment"># Links the target library to the log library</span></span><br><span class="line">                       <span class="comment"># included in the NDK.</span></span><br><span class="line">                       <span class="variable">$&#123;log-lib&#125;</span></span><br><span class="line">                       <span class="variable">$&#123;jnigraphics-lib&#125;</span></span><br><span class="line">                       <span class="variable">$&#123;android-lib&#125;</span> )</span><br></pre></td></tr></table></figure>
<ul>
<li>app Module 下 build.gradle文件内容如下:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">25</span></span><br><span class="line">    buildToolsVersion <span class="string">"25.0.2"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.vobile.ffmpegdemo"</span></span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">        targetSdkVersion <span class="number">25</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">        <span class="built_in">test</span>InstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                cppFlags <span class="string">"-frtti -fexceptions"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ndk &#123;</span><br><span class="line">            abiFilters <span class="string">'armeabi-v7a'</span>, <span class="string">"x86"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">source</span>Sets &#123;</span><br><span class="line"></span><br><span class="line">        main &#123;</span><br><span class="line">            jniLibs.srcDirs = [<span class="string">'libs'</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            jniDebuggable <span class="literal">true</span></span><br><span class="line">            jniDebuggable = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path <span class="string">"CMakeLists.txt"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span><br><span class="line">    androidTestCompile(<span class="string">'com.android.support.test.espresso:espresso-core:2.2.2'</span>, &#123;</span><br><span class="line">        exclude group: <span class="string">'com.android.support'</span>, module: <span class="string">'support-annotations'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    compile <span class="string">'com.android.support:appcompat-v7:25.3.1'</span></span><br><span class="line">    <span class="built_in">test</span>Compile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FFmpeg_和_libyuv的基本使用">FFmpeg 和 libyuv的基本使用</h4><p>万能视频播放器</p>
<p>实现的基本过程:</p>
<p>将任意格式的视频文件统一解码成YUV格式,然后将解码后的帧数据绘制到本地ANativeWindow里的Surface上. 这里的Surface由SurfaceView提供</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SurfaceHolder holder = surfaceView.getHolder();</span><br><span class="line"><span class="comment">//Surface 传入到Native函数中,用于绘制</span></span><br><span class="line">Surface surface = holder.getSurface();</span><br></pre></td></tr></table></figure>
<p>具体实现代码如下:</p>
<p>自定义SurfaceView类 VideoView.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoView</span> <span class="keyword">extends</span> <span class="title">SurfaceView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SurfaceHolder holder = getHolder();</span><br><span class="line">        holder.setFormat(PixelFormat.RGBA_8888);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>新建音视频播放工具类 VideoPlayer.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(String input, Surface surface)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sound</span><span class="params">(String input, String output)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">playSoud</span><span class="params">(String input)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">readAndPlaySound</span><span class="params">(String input, String output)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 创建一个AudioTrac对象，用于播放</span><br><span class="line">     * <span class="doctag">@param</span> nb_channels</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AudioTrack <span class="title">createAudioTrack</span><span class="params">(<span class="keyword">int</span> sampleRateInHz, <span class="keyword">int</span> nb_channels)</span></span>&#123;</span><br><span class="line">        <span class="comment">//固定格式的音频码流</span></span><br><span class="line">        <span class="keyword">int</span> audioFormat = AudioFormat.ENCODING_PCM_16BIT;</span><br><span class="line">        Log.i(<span class="string">"jason"</span>, <span class="string">"nb_channels:"</span>+nb_channels);</span><br><span class="line">        <span class="comment">//声道布局</span></span><br><span class="line">        <span class="keyword">int</span> channelConfig;</span><br><span class="line">        <span class="keyword">if</span>(nb_channels == <span class="number">1</span>)&#123;</span><br><span class="line">            channelConfig = android.media.AudioFormat.CHANNEL_OUT_MONO;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nb_channels == <span class="number">2</span>)&#123;</span><br><span class="line">            channelConfig = android.media.AudioFormat.CHANNEL_OUT_STEREO;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            channelConfig = android.media.AudioFormat.CHANNEL_OUT_STEREO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bufferSizeInBytes = AudioTrack.getMinBufferSize(sampleRateInHz, channelConfig, audioFormat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AudioTrack audioTrack = <span class="keyword">new</span> AudioTrack(</span><br><span class="line">                AudioManager.STREAM_MUSIC,</span><br><span class="line">                sampleRateInHz, channelConfig,</span><br><span class="line">                audioFormat,</span><br><span class="line">                bufferSizeInBytes, AudioTrack.MODE_STREAM);</span><br><span class="line">        <span class="comment">//播放</span></span><br><span class="line">        <span class="comment">//audioTrack.play();</span></span><br><span class="line">        <span class="comment">//写入PCM</span></span><br><span class="line">        <span class="comment">//audioTrack.write(audioData, offsetInBytes, sizeInBytes);</span></span><br><span class="line">        <span class="keyword">return</span> audioTrack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>具体Native代码实现如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;jni.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="comment">//C/C++混编 extern: 指示编译器按照C语言进行编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;libyuv.h&gt;</span></span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;libavcodec/avcodec.h&gt;</span></span><br><span class="line"><span class="comment">//封装格式处理</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;libavformat/avformat.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;libavfilter/avfilter.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;libswscale/swscale.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;android/log.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;android/native_window_jni.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;android/native_window.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;unistd.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> libyuv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//重采样</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;libswresample/swresample.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LOGI(FORMAT, ...) __android_log_print(ANDROID_LOG_INFO,"jason",FORMAT,##__VA_ARGS__);</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LOGE(FORMAT, ...) __android_log_print(ANDROID_LOG_ERROR,"jason",FORMAT,##__VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span>  MAX_AUDIO_FRAME_SIZE 48000 * 4</span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_MainActivity_avcodecinfo</span><span class="params">(JNIEnv *env, jobject instance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">    <span class="keyword">char</span> info[<span class="number">40000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    av_register_all();</span><br><span class="line">    AVCodec *<span class="keyword">c_t</span>emp = av_codec_next(NULL);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">c_t</span>emp != NULL)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">c_t</span>emp-&gt;decode != NULL)&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(info, <span class="string">"%sdecode:"</span>, info);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(info, <span class="string">"%sencode:"</span>, info);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">c_t</span>emp-&gt;type)&#123;</span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">                <span class="built_in">sprintf</span>(info, <span class="string">"%s(video):"</span>, info);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">                <span class="built_in">sprintf</span>(info, <span class="string">"%s(audio):"</span>, info);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">sprintf</span>(info, <span class="string">"%s(other):"</span>, info);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sprintf</span>(info, <span class="string">"%s[%10s]\n"</span>, info, <span class="keyword">c_t</span>emp-&gt;name);</span><br><span class="line">        <span class="keyword">c_t</span>emp = <span class="keyword">c_t</span>emp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_VideoPlayer_readAndPlaySound</span><span class="params">(JNIEnv *env, jobject jthiz,</span><br><span class="line">                                                        jstring input_, jstring output_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input_cstr = env-&gt;GetStringUTFChars(input_, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *output_cstr = env-&gt;GetStringUTFChars(output_, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    LOGI(<span class="string">"%s"</span>,<span class="string">"sound"</span>);</span><br><span class="line">    <span class="comment">//注册组件</span></span><br><span class="line">    av_register_all();</span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line">    <span class="comment">//打开音频文件</span></span><br><span class="line">    <span class="keyword">if</span>(avformat_open_input(&amp;pFormatCtx,input_cstr,NULL,NULL) != <span class="number">0</span>)&#123;</span><br><span class="line">        LOGI(<span class="string">"%s"</span>,<span class="string">"无法打开音频文件"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取输入文件信息</span></span><br><span class="line">    <span class="keyword">if</span>(avformat_find_stream_info(pFormatCtx,NULL) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        LOGI(<span class="string">"%s"</span>,<span class="string">"无法获取输入文件信息"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取音频流索引位置</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, audio_stream_idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; pFormatCtx-&gt;nb_streams;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;<span class="keyword">codec_t</span>ype == AVMEDIA_TYPE_AUDIO)&#123;</span><br><span class="line">            audio_stream_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取解码器</span></span><br><span class="line">    AVCodecContext *codecCtx = pFormatCtx-&gt;streams[audio_stream_idx]-&gt;codec;</span><br><span class="line">    AVCodec *codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span>(codec == NULL)&#123;</span><br><span class="line">        LOGI(<span class="string">"%s"</span>,<span class="string">"无法获取解码器"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开解码器</span></span><br><span class="line">    <span class="keyword">if</span>(avcodec_open2(codecCtx,codec,NULL) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        LOGI(<span class="string">"%s"</span>,<span class="string">"无法打开解码器"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压缩数据</span></span><br><span class="line">    AVPacket *packet = (AVPacket *)av_malloc(<span class="keyword">sizeof</span>(AVPacket));</span><br><span class="line">    <span class="comment">//解压缩数据</span></span><br><span class="line">    AVFrame *frame = av_frame_alloc();</span><br><span class="line">    <span class="comment">//frame-&gt;16bit 44100 PCM 统一音频采样格式与采样率</span></span><br><span class="line">    SwrContext *swrCtx = swr_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重采样设置参数-------------start</span></span><br><span class="line">    <span class="comment">//输入的采样格式</span></span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat in_sample_fmt = codecCtx-&gt;sample_fmt;</span><br><span class="line">    <span class="comment">//输出采样格式16bit PCM</span></span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">    <span class="comment">//输入采样率</span></span><br><span class="line">    <span class="keyword">int</span> in_sample_rate = codecCtx-&gt;sample_rate;</span><br><span class="line">    <span class="comment">//输出采样率</span></span><br><span class="line">    <span class="keyword">int</span> out_sample_rate = in_sample_rate;</span><br><span class="line">    <span class="comment">//获取输入的声道布局</span></span><br><span class="line">    <span class="comment">//根据声道个数获取默认的声道布局（2个声道，默认立体声stereo）</span></span><br><span class="line">    <span class="comment">//av_get_default_channel_layout(codecCtx-&gt;channels);</span></span><br><span class="line">    <span class="keyword">uint64_t</span> in_ch_layout = codecCtx-&gt;channel_layout;</span><br><span class="line">    <span class="comment">//输出的声道布局（立体声）</span></span><br><span class="line">    <span class="keyword">uint64_t</span> out_ch_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line"></span><br><span class="line">    swr_alloc_set_opts(swrCtx,</span><br><span class="line">                       out_ch_layout,out_sample_fmt,out_sample_rate,</span><br><span class="line">                       in_ch_layout,in_sample_fmt,in_sample_rate,</span><br><span class="line">                       <span class="number">0</span>, NULL);</span><br><span class="line">    swr_init(swrCtx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出的声道个数</span></span><br><span class="line">    <span class="keyword">int</span> out_channel_nb = av_get_channel_layout_nb_channels(out_ch_layout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重采样设置参数-------------end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//JNI begin------------------</span></span><br><span class="line">    <span class="comment">//JasonPlayer</span></span><br><span class="line">    jclass player_class = env-&gt;GetObjectClass(jthiz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AudioTrack对象</span></span><br><span class="line">    jmethodID <span class="keyword">create_audio_t</span>rack_mid = env-&gt;GetMethodID(player_class,<span class="string">"createAudioTrack"</span>,<span class="string">"(II)Landroid/media/AudioTrack;"</span>);</span><br><span class="line">    jobject <span class="keyword">audio_t</span>rack = env-&gt;CallObjectMethod(jthiz,<span class="keyword">create_audio_t</span>rack_mid,out_sample_rate,out_channel_nb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用AudioTrack.play方法</span></span><br><span class="line">    jclass <span class="keyword">audio_t</span>rack_class = env-&gt;GetObjectClass(<span class="keyword">audio_t</span>rack);</span><br><span class="line">    jmethodID <span class="keyword">audio_t</span>rack_play_mid = env-&gt;GetMethodID(<span class="keyword">audio_t</span>rack_class,<span class="string">"play"</span>,<span class="string">"()V"</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(<span class="keyword">audio_t</span>rack,<span class="keyword">audio_t</span>rack_play_mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AudioTrack.write</span></span><br><span class="line">    jmethodID <span class="keyword">audio_t</span>rack_write_mid = env-&gt;GetMethodID(<span class="keyword">audio_t</span>rack_class,<span class="string">"write"</span>,<span class="string">"([BII)I"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JNI end------------------</span></span><br><span class="line">    FILE *fp_pcm = fopen(output_cstr,<span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//16bit 44100 PCM 数据</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *out_buffer = (<span class="keyword">uint8_t</span> *)av_malloc(MAX_AUDIO_FRAME_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> got_frame = <span class="number">0</span>,index = <span class="number">0</span>, ret;</span><br><span class="line">    <span class="comment">//不断读取压缩数据</span></span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(pFormatCtx,packet) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//解码音频类型的Packet</span></span><br><span class="line">        <span class="keyword">if</span>(packet-&gt;stream_index == audio_stream_idx)&#123;</span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            ret = avcodec_decode_audio4(codecCtx,frame,&amp;got_frame,packet);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                LOGI(<span class="string">"%s"</span>,<span class="string">"解码完成"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解码一帧成功</span></span><br><span class="line">            <span class="keyword">if</span>(got_frame &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                LOGI(<span class="string">"解码：%d"</span>,index++);</span><br><span class="line">                swr_convert(swrCtx, &amp;out_buffer, MAX_AUDIO_FRAME_SIZE,(<span class="keyword">const</span> <span class="keyword">uint8_t</span> **)frame-&gt;data,frame-&gt;nb_samples);</span><br><span class="line">                <span class="comment">//获取sample的size</span></span><br><span class="line">                <span class="keyword">int</span> out_buffer_size = av_samples_get_buffer_size(NULL, out_channel_nb,</span><br><span class="line">                                                                 frame-&gt;nb_samples, out_sample_fmt, <span class="number">1</span>);</span><br><span class="line">                fwrite(out_buffer,<span class="number">1</span>,out_buffer_size,fp_pcm);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//out_buffer缓冲区数据，转成byte数组</span></span><br><span class="line">                jbyteArray audio_sample_array = env-&gt;NewByteArray(out_buffer_size);</span><br><span class="line">                jbyte* sample_bytep = env-&gt;GetByteArrayElements(audio_sample_array,NULL);</span><br><span class="line">                <span class="comment">//out_buffer的数据复制到sampe_bytep</span></span><br><span class="line">                <span class="built_in">memcpy</span>(sample_bytep,out_buffer,out_buffer_size);</span><br><span class="line">                <span class="comment">//同步</span></span><br><span class="line">                env-&gt;ReleaseByteArrayElements(audio_sample_array,sample_bytep,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//AudioTrack.write PCM数据</span></span><br><span class="line">                env-&gt;CallIntMethod(<span class="keyword">audio_t</span>rack,<span class="keyword">audio_t</span>rack_write_mid,</span><br><span class="line">                                      audio_sample_array,<span class="number">0</span>,out_buffer_size);</span><br><span class="line">                <span class="comment">//释放局部引用</span></span><br><span class="line">                env-&gt;DeleteLocalRef(audio_sample_array);</span><br><span class="line">                usleep(<span class="number">1000</span> * <span class="number">16</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_free_packet(packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">    av_free(out_buffer);</span><br><span class="line"></span><br><span class="line">    swr_free(&amp;swrCtx);</span><br><span class="line">    avcodec_close(codecCtx);</span><br><span class="line">    avformat_close_input(&amp;pFormatCtx);</span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(input_, input_cstr);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(output_, output_cstr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_VideoPlayer_playSoud</span><span class="params">(JNIEnv *env, jobject instance, jstring input_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input = env-&gt;GetStringUTFChars(input_, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">    <span class="comment">//1.注册所有组件</span></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装格式上下文，统领全局的结构体，保存了音视频文件封装格式的相关信息</span></span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.打开音频文件</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx, input, NULL, NULL) != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法打开音频文件"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取音频文件信息</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(pFormatCtx, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法获取音频文件信息"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取音频流的索引位置</span></span><br><span class="line">    <span class="comment">//遍历所有类型的流（音频流、视频流、字幕流），找到音频流</span></span><br><span class="line">    <span class="keyword">int</span> audio_stream_idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//number of streams</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="comment">//流的类型</span></span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;<span class="keyword">codec_t</span>ype == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            audio_stream_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio_stream_idx == -<span class="number">1</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到音频流\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取音频流中的编解码上下文</span></span><br><span class="line">    AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[audio_stream_idx]-&gt;codec;</span><br><span class="line">    <span class="comment">//4.根据编解码上下文中的编码id查找对应的解码</span></span><br><span class="line">    AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">    <span class="comment">//（迅雷看看，找不到解码器，临时下载一个解码器）</span></span><br><span class="line">    <span class="keyword">if</span> (pCodec == NULL) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到解码器\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.打开解码器</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"解码器无法打开\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出音频信息</span></span><br><span class="line">    LOGI(<span class="string">"音频的文件格式：%s"</span>, pFormatCtx-&gt;iformat-&gt;name);</span><br><span class="line">    LOGI(<span class="string">"音频时长：%lld"</span>, (pFormatCtx-&gt;duration) / <span class="number">1000000</span>);</span><br><span class="line">    LOGI(<span class="string">"音频的宽高：%d,%d"</span>, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line">    LOGI(<span class="string">"解码器的名称：%s"</span>, pCodec-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压缩数据</span></span><br><span class="line">    AVPacket *packet = (AVPacket *)av_malloc(<span class="keyword">sizeof</span>(AVPacket));</span><br><span class="line">    <span class="comment">//解压缩数据</span></span><br><span class="line">    AVFrame *frame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//frame-&gt;16bit  44100 PCM 统一音频采样格式与采样率</span></span><br><span class="line"></span><br><span class="line">    SwrContext *swrContext = swr_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重采样设置参数</span></span><br><span class="line">    <span class="comment">//输入的采样格式</span></span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat  in_sample_fmt = pCodecCtx-&gt;sample_fmt;</span><br><span class="line">    <span class="comment">//输出的采样格式</span></span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">    <span class="comment">//输入采样率</span></span><br><span class="line">    <span class="keyword">int</span> in_sample_rate = pCodecCtx-&gt;sample_rate;</span><br><span class="line">    <span class="comment">//输出采样率</span></span><br><span class="line">    <span class="keyword">int</span> out_sample_rate = in_sample_rate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取输入的声道布局 参加AudioFormat.java  286行</span></span><br><span class="line">    <span class="comment">//根据声道个数获取默认的声道布局(2个声道,默认立体声CHANNEL_OUT_STEREO)</span></span><br><span class="line">    <span class="comment">//CHANNEL_OUT_5POINT1 为5.1环绕声</span></span><br><span class="line">    <span class="comment">//av_get_default_channel_layout(pCodecCtx-&gt;channels);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span>  in_ch_layout = pCodecCtx-&gt;channel_layout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出的声道布局</span></span><br><span class="line">    <span class="keyword">int64_t</span> out_ch_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出声道个数</span></span><br><span class="line">    <span class="keyword">int</span> out_channel_nb = av_get_channel_layout_nb_channels(out_ch_layout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> log_offset = <span class="number">0</span>; <span class="comment">// 不偏移</span></span><br><span class="line"></span><br><span class="line">    swr_alloc_set_opts(swrContext,</span><br><span class="line">                       out_ch_layout, out_sample_fmt, out_sample_rate,</span><br><span class="line">                       in_ch_layout, in_sample_fmt, in_sample_rate,</span><br><span class="line">                       log_offset, NULL);</span><br><span class="line"></span><br><span class="line">    swr_init(swrContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//VideoPlayer</span></span><br><span class="line">    jclass player_class = env-&gt;GetObjectClass(instance);</span><br><span class="line">    <span class="comment">//AudioTrack对象</span></span><br><span class="line">    <span class="comment">//cd  cd /Users/vobile/AndroidStudioProjects/FFmpegDemo/app/build/intermediates/classes/debug/com/vobile/ffmpegdemo/</span></span><br><span class="line">    <span class="comment">//javap -s VideoPlayer.class</span></span><br><span class="line">    jmethodID <span class="keyword">create_audio_t</span>rack_mid = env-&gt;GetMethodID(player_class,<span class="string">"createAudioTrack"</span>,<span class="string">"(II)Landroid/media/AudioTrack;"</span>);</span><br><span class="line">    jobject <span class="keyword">audio_t</span>rack = env-&gt;CallObjectMethod(instance,<span class="keyword">create_audio_t</span>rack_mid,out_sample_rate,out_channel_nb);</span><br><span class="line">    <span class="comment">//调用AudioTrack.play()方法</span></span><br><span class="line">    jclass <span class="keyword">audio_t</span>rack_class = env-&gt;GetObjectClass(<span class="keyword">audio_t</span>rack);</span><br><span class="line">    jmethodID <span class="keyword">audio_t</span>rack_play_mid = env-&gt;GetMethodID(<span class="keyword">audio_t</span>rack_class,<span class="string">"play"</span>,<span class="string">"()V"</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(<span class="keyword">audio_t</span>rack,<span class="keyword">audio_t</span>rack_play_mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AudioTrack.write</span></span><br><span class="line">    jmethodID <span class="keyword">audio_t</span>rack_write_mid = env-&gt;GetMethodID(<span class="keyword">audio_t</span>rack_class,<span class="string">"write"</span>,<span class="string">"([BII)I"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存了16bit  44100 PCM 采样数据</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *out_buffer = (<span class="keyword">uint8_t</span> *)av_malloc(MAX_AUDIO_FRAME_SIZE); <span class="comment">//unsigned char</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> got_frame = <span class="number">0</span>, frame_count = <span class="number">0</span>, ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不断读取压缩数据</span></span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(pFormatCtx,packet) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//解码音频类型的Packet</span></span><br><span class="line">        <span class="keyword">if</span>(packet-&gt;stream_index == audio_stream_idx)&#123;</span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            ret = avcodec_decode_audio4(pCodecCtx, frame,&amp;got_frame,packet);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                LOGE(<span class="string">"%s"</span>, <span class="string">"解码错误"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解码一帧成功</span></span><br><span class="line">            <span class="keyword">if</span> (got_frame &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                LOGI(<span class="string">"解码: %d"</span>,frame_count++);</span><br><span class="line">                swr_convert(swrContext, &amp;out_buffer, MAX_AUDIO_FRAME_SIZE,</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) frame-&gt;data, frame-&gt;nb_samples);</span><br><span class="line">                <span class="comment">//获取sample的大小</span></span><br><span class="line">                <span class="keyword">int</span> out_buffer_size = av_samples_get_buffer_size(NULL,out_channel_nb,frame-&gt;nb_samples,out_sample_fmt,<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//AudioTrack.writePCM数据</span></span><br><span class="line">                <span class="comment">//out_buffer缓冲区数据,转成byte数组</span></span><br><span class="line">                jbyteArray  audio_sample_array = env-&gt;NewByteArray(out_buffer_size);</span><br><span class="line">                jbyte* sample_bytep = env-&gt;GetByteArrayElements(audio_sample_array,NULL);</span><br><span class="line">                <span class="comment">//out_buffer的数据复制到sample_bytep</span></span><br><span class="line">                <span class="built_in">memcpy</span>(sample_bytep,out_buffer,out_buffer_size);</span><br><span class="line">                <span class="comment">//同步</span></span><br><span class="line">                env-&gt;ReleaseByteArrayElements(audio_sample_array,sample_bytep,<span class="number">0</span>);</span><br><span class="line">                env-&gt;CallIntMethod(<span class="keyword">audio_t</span>rack,<span class="keyword">audio_t</span>rack_write_mid,</span><br><span class="line">                                   audio_sample_array,<span class="number">0</span>,out_buffer_size);</span><br><span class="line">                <span class="comment">//释放局部引用</span></span><br><span class="line">                env-&gt;DeleteLocalRef(audio_sample_array);</span><br><span class="line">                usleep(<span class="number">1000</span> * <span class="number">16</span>);<span class="comment">//16毫秒</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_free_packet(packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">    av_free(out_buffer);</span><br><span class="line"></span><br><span class="line">    swr_free(&amp;swrContext);</span><br><span class="line">    avcodec_close(pCodecCtx);</span><br><span class="line">    avformat_close_input(&amp;pFormatCtx);</span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(input_, input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_VideoPlayer_sound</span><span class="params">(JNIEnv *env, jobject instance, jstring input_,</span><br><span class="line">                                             jstring output_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input = env-&gt;GetStringUTFChars(input_, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *output = env-&gt;GetStringUTFChars(output_, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">    <span class="comment">//1.注册所有组件</span></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装格式上下文，统领全局的结构体，保存了音视频文件封装格式的相关信息</span></span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.打开音频文件</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx, input, NULL, NULL) != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法打开音频文件"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取音频文件信息</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(pFormatCtx, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法获输入文件信息"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取音频流的索引位置</span></span><br><span class="line">    <span class="comment">//遍历所有类型的流（音频流、视频流、字幕流），找到音频流</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, audio_stream_idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//number of streams</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="comment">//流的类型</span></span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;<span class="keyword">codec_t</span>ype == AVMEDIA_TYPE_AUDIO) &#123;</span><br><span class="line">            audio_stream_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio_stream_idx == -<span class="number">1</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到音频流\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取音频流中的编解码上下文</span></span><br><span class="line">    AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[audio_stream_idx]-&gt;codec;</span><br><span class="line">    <span class="comment">//4.根据编解码上下文中的编码id查找对应的解码</span></span><br><span class="line">    AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">    <span class="comment">//（迅雷看看，找不到解码器，临时下载一个解码器）</span></span><br><span class="line">    <span class="keyword">if</span> (pCodec == NULL) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到解码器\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.打开解码器</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法打开解码器\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出音频信息</span></span><br><span class="line">    LOGI(<span class="string">"音频的文件格式：%s"</span>, pFormatCtx-&gt;iformat-&gt;name);</span><br><span class="line">    LOGI(<span class="string">"音频时长：%lld"</span>, (pFormatCtx-&gt;duration) / <span class="number">1000000</span>);</span><br><span class="line">    LOGI(<span class="string">"音频的宽高：%d,%d"</span>, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line">    LOGI(<span class="string">"解码器的名称：%s"</span>, pCodec-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压缩数据</span></span><br><span class="line">    AVPacket *packet = (AVPacket *)av_malloc(<span class="keyword">sizeof</span>(AVPacket));</span><br><span class="line">    <span class="comment">//解压缩数据</span></span><br><span class="line">    AVFrame *frame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//frame-&gt;16bit  44100 PCM 统一音频采样格式与采样率</span></span><br><span class="line"></span><br><span class="line">    SwrContext *swrContext = swr_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重采样设置参数</span></span><br><span class="line">    <span class="comment">//输入的采样格式</span></span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat  in_sample_fmt = pCodecCtx-&gt;sample_fmt;</span><br><span class="line">    <span class="comment">//输出的采样格式16bit PCM</span></span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">    <span class="comment">//输入采样率</span></span><br><span class="line">    <span class="keyword">int</span> in_sample_rate = pCodecCtx-&gt;sample_rate;</span><br><span class="line">    <span class="comment">//输出采样率</span></span><br><span class="line">    <span class="keyword">int</span> out_sample_rate = in_sample_rate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取输入的声道布局 参加AudioFormat.java  286行</span></span><br><span class="line">    <span class="comment">//根据声道个数获取默认的声道布局(2个声道,默认立体声CHANNEL_OUT_STEREO)</span></span><br><span class="line">    <span class="comment">//CHANNEL_OUT_5POINT1 为5.1环绕声</span></span><br><span class="line">    <span class="comment">//av_get_default_channel_layout(pCodecCtx-&gt;channels);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span>  in_ch_layout = pCodecCtx-&gt;channel_layout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出的声道布局</span></span><br><span class="line">    <span class="keyword">int64_t</span> out_ch_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出的声道个数</span></span><br><span class="line">    <span class="keyword">int</span> out_channel_nb = av_get_channel_layout_nb_channels(out_ch_layout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> log_offset = <span class="number">0</span>; <span class="comment">// 不偏移</span></span><br><span class="line"></span><br><span class="line">    swr_alloc_set_opts(swrContext,</span><br><span class="line">                       out_ch_layout, out_sample_fmt, out_sample_rate,</span><br><span class="line">                       in_ch_layout, in_sample_fmt, in_sample_rate,</span><br><span class="line">                       log_offset, NULL);</span><br><span class="line">    swr_init(swrContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存了16bit  44100 PCM 采样数据</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *out_buffer = (<span class="keyword">uint8_t</span> *)av_malloc(MAX_AUDIO_FRAME_SIZE); <span class="comment">//unsigned char</span></span><br><span class="line"></span><br><span class="line">    FILE *fp_pcm = fopen(output, <span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> got_frame = <span class="number">0</span>, frame_count = <span class="number">0</span>, ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不断读取压缩数据</span></span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(pFormatCtx,packet) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//解码音频类型的Packet</span></span><br><span class="line">        <span class="keyword">if</span>(packet-&gt;stream_index == audio_stream_idx)&#123;</span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            ret = avcodec_decode_audio4(pCodecCtx, frame,&amp;got_frame,packet);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                LOGE(<span class="string">"%s"</span>, <span class="string">"解码错误"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解码一帧成功</span></span><br><span class="line">            <span class="keyword">if</span> (got_frame &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                LOGI(<span class="string">"解码: %d"</span>,frame_count++);</span><br><span class="line">                swr_convert(swrContext, &amp;out_buffer, MAX_AUDIO_FRAME_SIZE,</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) frame-&gt;data, frame-&gt;nb_samples);</span><br><span class="line">                <span class="comment">//获取sample的大小</span></span><br><span class="line">                <span class="keyword">int</span> out_buffer_size = av_samples_get_buffer_size(NULL,out_channel_nb,frame-&gt;nb_samples,out_sample_fmt,<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//uint8_t *out_buffer---unsigned char--1</span></span><br><span class="line">                fwrite(out_buffer,<span class="number">1</span>,out_buffer_size,fp_pcm);</span><br><span class="line">            &#125;</span><br><span class="line">            av_free_packet(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGI(<span class="string">"解码完成"</span>);</span><br><span class="line">    fclose(fp_pcm);</span><br><span class="line">    av_frame_free(&amp;frame);</span><br><span class="line">    av_free(out_buffer);</span><br><span class="line">    swr_free(&amp;swrContext);</span><br><span class="line">    avcodec_close(pCodecCtx);</span><br><span class="line">    avformat_close_input(&amp;pFormatCtx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(input_, input);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(output_, output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_VideoPlayer_render</span><span class="params">(JNIEnv *env, jobject instance, jstring input_,</span><br><span class="line">                                              jobject surface)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要转码的视频文件(输入的视频文件)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input_cstr = env-&gt;GetStringUTFChars(input_, NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">    <span class="comment">//1.注册所有组件</span></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装格式上下文，统领全局的结构体，保存了视频文件封装格式的相关信息</span></span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.打开输入视频文件</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx, input_cstr, NULL, NULL) != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法打开输入视频文件"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取视频文件信息</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(pFormatCtx, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法获取视频文件信息"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取视频流的索引位置</span></span><br><span class="line">    <span class="comment">//遍历所有类型的流（音频流、视频流、字幕流），找到视频流</span></span><br><span class="line">    <span class="keyword">int</span> v_stream_idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//number of streams</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="comment">//流的类型</span></span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;<span class="keyword">codec_t</span>ype == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">            v_stream_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v_stream_idx == -<span class="number">1</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到视频流\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有知道视频的编码方式，才能够根据编码方式去找到解码器</span></span><br><span class="line">    <span class="comment">//获取视频流中的编解码上下文</span></span><br><span class="line">    AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[v_stream_idx]-&gt;codec;</span><br><span class="line">    <span class="comment">//4.根据编解码上下文中的编码id查找对应的解码</span></span><br><span class="line">    AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">    <span class="comment">//（迅雷看看，找不到解码器，临时下载一个解码器）</span></span><br><span class="line">    <span class="keyword">if</span> (pCodec == NULL) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到解码器\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.打开解码器</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"解码器无法打开\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出视频信息</span></span><br><span class="line">    LOGI(<span class="string">"视频的文件格式：%s"</span>, pFormatCtx-&gt;iformat-&gt;name);</span><br><span class="line">    LOGI(<span class="string">"视频时长：%lld"</span>, (pFormatCtx-&gt;duration) / <span class="number">1000000</span>);</span><br><span class="line">    LOGI(<span class="string">"视频的宽高：%d,%d"</span>, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line">    LOGI(<span class="string">"解码器的名称：%s"</span>, pCodec-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备读取</span></span><br><span class="line">    <span class="comment">//AVPacket用于存储一帧一帧的压缩数据（H264）</span></span><br><span class="line">    <span class="comment">//缓冲区，开辟空间</span></span><br><span class="line">    <span class="comment">//AVPacket *packet; //编码数据</span></span><br><span class="line">    <span class="comment">//av_init_packet(packet);</span></span><br><span class="line">    AVPacket *packet = (AVPacket *) av_malloc(<span class="keyword">sizeof</span>(AVPacket));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AVFrame用于存储解码后的像素数据(YUV)</span></span><br><span class="line">    <span class="comment">//内存分配</span></span><br><span class="line">    AVFrame *yuv_frame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    AVFrame *rgb_frame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//native绘制</span></span><br><span class="line">    <span class="comment">//窗体</span></span><br><span class="line">    ANativeWindow*  nativeWindow = ANativeWindow_fromSurface(env, surface);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制时的缓冲区</span></span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> got_picture, ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> frame_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.一帧一帧的读取压缩数据</span></span><br><span class="line">    <span class="keyword">while</span> (av_read_frame(pFormatCtx, packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//只要视频压缩数据（根据流的索引位置判断）</span></span><br><span class="line">        <span class="keyword">if</span> (packet-&gt;stream_index == v_stream_idx) &#123;</span><br><span class="line">            <span class="comment">//7.解码一帧视频压缩数据，得到视频像素数据</span></span><br><span class="line">            <span class="comment">//解码 AVPacket-&gt;AVFrame</span></span><br><span class="line">            ret = avcodec_decode_video2(pCodecCtx, yuv_frame, &amp;got_picture, packet);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                LOGE(<span class="string">"%s"</span>, <span class="string">"解码错误"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为0说明解码完成，非0正在解码</span></span><br><span class="line">            <span class="keyword">if</span> (got_picture) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//lock</span></span><br><span class="line">                <span class="comment">//设置缓冲区的属性(宽、高、像素格式)  这里应该和SurfaceView上指定的format一致</span></span><br><span class="line">                ANativeWindow_setBuffersGeometry(nativeWindow,</span><br><span class="line">                                                         pCodecCtx-&gt;width, pCodecCtx-&gt;height, WINDOW_FORMAT_RGBA_8888);</span><br><span class="line">                ANativeWindow_lock(nativeWindow,&amp;outBuffer,NULL);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//YUV-&gt;RGBA_8888</span></span><br><span class="line">                <span class="comment">//pCodecCtx-&gt;pix_fmt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置rgb_frame的属性(像素格式、宽高)和缓冲区</span></span><br><span class="line">                avpicture_fill((AVPicture *)rgb_frame, (<span class="keyword">uint8_t</span> *)outBuffer.bits, AV_PIX_FMT_RGBA,pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//fill buffer   data[0] 是Y 的数据, linesize[0]是Y的一行的大小</span></span><br><span class="line">                <span class="comment">//rgb_frame的缓冲区与outBuffer.bits是同一块内存</span></span><br><span class="line">                I420ToARGB(yuv_frame-&gt;data[<span class="number">0</span>],yuv_frame-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                           yuv_frame-&gt;data[<span class="number">2</span>],yuv_frame-&gt;linesize[<span class="number">2</span>],</span><br><span class="line">                           yuv_frame-&gt;data[<span class="number">1</span>],yuv_frame-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">                           rgb_frame-&gt;data[<span class="number">0</span>], rgb_frame-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                           pCodecCtx-&gt;width,pCodecCtx-&gt;height</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//unlock</span></span><br><span class="line">                ANativeWindow_unlockAndPost(nativeWindow);</span><br><span class="line"></span><br><span class="line">                frame_count++;</span><br><span class="line">                LOGI(<span class="string">"解码第%d帧"</span>, frame_count);</span><br><span class="line"></span><br><span class="line">                usleep(<span class="number">1000</span> * <span class="number">16</span>);<span class="comment">//16毫秒</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        av_free_packet(packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    ANativeWindow_release(nativeWindow);</span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(input_, input_cstr);</span><br><span class="line"></span><br><span class="line">    av_frame_free(&amp;yuv_frame);</span><br><span class="line"></span><br><span class="line">    avcodec_close(pCodecCtx);</span><br><span class="line"></span><br><span class="line">    avformat_free_context(pFormatCtx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_MainActivity_decode</span><span class="params">(JNIEnv *env, jclass type, jstring input_,</span><br><span class="line">                                               jstring output_)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要转码的视频文件(输入的视频文件)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input_cstr = env-&gt;GetStringUTFChars(input_, NULL);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *output_cstr = env-&gt;GetStringUTFChars(output_, NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">    <span class="comment">//1.注册所有组件</span></span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装格式上下文，统领全局的结构体，保存了视频文件封装格式的相关信息</span></span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.打开输入视频文件</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx, input_cstr, NULL, NULL) != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法打开输入视频文件"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取视频文件信息</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(pFormatCtx, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"无法获取视频文件信息"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取视频流的索引位置</span></span><br><span class="line">    <span class="comment">//遍历所有类型的流（音频流、视频流、字幕流），找到视频流</span></span><br><span class="line">    <span class="keyword">int</span> v_stream_idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//number of streams</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="comment">//流的类型</span></span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;<span class="keyword">codec_t</span>ype == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">            v_stream_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v_stream_idx == -<span class="number">1</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到视频流\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有知道视频的编码方式，才能够根据编码方式去找到解码器</span></span><br><span class="line">    <span class="comment">//获取视频流中的编解码上下文</span></span><br><span class="line">    AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[v_stream_idx]-&gt;codec;</span><br><span class="line">    <span class="comment">//4.根据编解码上下文中的编码id查找对应的解码</span></span><br><span class="line">    AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">    <span class="comment">//（迅雷看看，找不到解码器，临时下载一个解码器）</span></span><br><span class="line">    <span class="keyword">if</span> (pCodec == NULL) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"找不到解码器\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.打开解码器</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, NULL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>, <span class="string">"解码器无法打开\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出视频信息</span></span><br><span class="line">    LOGI(<span class="string">"视频的文件格式：%s"</span>, pFormatCtx-&gt;iformat-&gt;name);</span><br><span class="line">    LOGI(<span class="string">"视频时长：%lld"</span>, (pFormatCtx-&gt;duration) / <span class="number">1000000</span>);</span><br><span class="line">    LOGI(<span class="string">"视频的宽高：%d,%d"</span>, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line">    LOGI(<span class="string">"解码器的名称：%s"</span>, pCodec-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备读取</span></span><br><span class="line">    <span class="comment">//AVPacket用于存储一帧一帧的压缩数据（H264）</span></span><br><span class="line">    <span class="comment">//缓冲区，开辟空间</span></span><br><span class="line">    <span class="comment">//AVPacket *packet; //编码数据</span></span><br><span class="line">    <span class="comment">//av_init_packet(packet);</span></span><br><span class="line">    AVPacket *packet = (AVPacket *) av_malloc(<span class="keyword">sizeof</span>(AVPacket));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AVFrame用于存储解码后的像素数据(YUV)</span></span><br><span class="line">    <span class="comment">//内存分配</span></span><br><span class="line">    AVFrame *pFrame = av_frame_alloc();</span><br><span class="line">    <span class="comment">//YUV420 像素数据(解码数据)</span></span><br><span class="line">    AVFrame *pFrameYUV = av_frame_alloc();</span><br><span class="line">    <span class="comment">//只有指定了AVFrame的像素格式、画面大小才能真正分配内存</span></span><br><span class="line">    <span class="comment">//缓冲区分配内存</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *out_buffer = (<span class="keyword">uint8_t</span> *) av_malloc(</span><br><span class="line">            avpicture_get_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height));</span><br><span class="line">    <span class="comment">//初始化缓冲区</span></span><br><span class="line">    avpicture_fill((AVPicture *) pFrameYUV, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width,</span><br><span class="line">                   pCodecCtx-&gt;height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于转码（缩放）的参数，转之前的宽高，转之后的宽高，格式等</span></span><br><span class="line">    <span class="keyword">struct</span> SwsContext *sws_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class="line">                                                pCodecCtx-&gt;pix_fmt,</span><br><span class="line">                                                pCodecCtx-&gt;width, pCodecCtx-&gt;height,</span><br><span class="line">                                                AV_PIX_FMT_YUV420P,</span><br><span class="line">                                                SWS_BICUBIC, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> got_picture, ret;</span><br><span class="line"></span><br><span class="line">    FILE *fp_yuv = fopen(output_cstr, <span class="string">"wb+"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> frame_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.一帧一帧的读取压缩数据</span></span><br><span class="line">    <span class="keyword">while</span> (av_read_frame(pFormatCtx, packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//只要视频压缩数据（根据流的索引位置判断）</span></span><br><span class="line">        <span class="keyword">if</span> (packet-&gt;stream_index == v_stream_idx) &#123;</span><br><span class="line">            <span class="comment">//7.解码一帧视频压缩数据，得到视频像素数据</span></span><br><span class="line">            ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                LOGE(<span class="string">"%s"</span>, <span class="string">"解码错误"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为0说明解码完成，非0正在解码</span></span><br><span class="line">            <span class="keyword">if</span> (got_picture) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//AVFrame转为像素格式YUV420，宽高</span></span><br><span class="line">                <span class="comment">//2 6输入、输出数据</span></span><br><span class="line">                <span class="comment">//3 7输入、输出画面一行的数据的大小 AVFrame 转换是一行一行转换的</span></span><br><span class="line">                <span class="comment">//4 输入数据第一列要转码的位置 从0开始</span></span><br><span class="line">                <span class="comment">//5 输入画面的高度</span></span><br><span class="line">                sws_scale(sws_ctx, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **)pFrame-&gt;data, pFrame-&gt;linesize, <span class="number">0</span>, pCodecCtx-&gt;height,</span><br><span class="line">                          pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//输出到YUV文件</span></span><br><span class="line">                <span class="comment">//AVFrame像素帧写入文件</span></span><br><span class="line">                <span class="comment">//data解码后的图像像素数据（音频采样数据）</span></span><br><span class="line">                <span class="comment">//Y 亮度 UV 色度（压缩了） 人对亮度更加敏感</span></span><br><span class="line">                <span class="comment">//U V 个数是Y的1/4</span></span><br><span class="line">                <span class="keyword">int</span> y_size = pCodecCtx-&gt;width * pCodecCtx-&gt;height;</span><br><span class="line">                fwrite(pFrameYUV-&gt;data[<span class="number">0</span>], <span class="number">1</span>, y_size, fp_yuv);</span><br><span class="line">                fwrite(pFrameYUV-&gt;data[<span class="number">1</span>], <span class="number">1</span>, y_size / <span class="number">4</span>, fp_yuv);</span><br><span class="line">                fwrite(pFrameYUV-&gt;data[<span class="number">2</span>], <span class="number">1</span>, y_size / <span class="number">4</span>, fp_yuv);</span><br><span class="line"></span><br><span class="line">                frame_count++;</span><br><span class="line">                LOGI(<span class="string">"解码第%d帧"</span>, frame_count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        av_free_packet(packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp_yuv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(input_, input_cstr);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(output_, output_cstr);</span><br><span class="line"></span><br><span class="line">    av_frame_free(&amp;pFrame);</span><br><span class="line"></span><br><span class="line">    avcodec_close(pCodecCtx);</span><br><span class="line"></span><br><span class="line">    avformat_free_context(pFormatCtx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function">jstring</span><br><span class="line"><span class="title">Java_com_vobile_ffmpegdemo_MainActivity_stringFromJNI</span><span class="params">(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">"Hello from C++"</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注: 播放音频时务必使用真机,模拟机不支持AudioTrack播放pcm格式音频</p>
<h4 id="Android_Studio配置自动生成类的头文件以及查看类中方法签名">Android Studio配置自动生成类的头文件以及查看类中方法签名</h4><ul>
<li><p>Android Studio-&gt;Preferences-&gt;Tools-&gt;External Tools</p>
</li>
<li><p>查看项目中类方法签名配置如下</p>
</li>
</ul>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/Snip20170804_2.png" alt=""></p>
<ul>
<li>查看系统源码中类中方法签名</li>
</ul>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/Snip20170804_android_javap.png" alt=""></p>
<ul>
<li>生成头文件</li>
</ul>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/Snip20170804_javah.png" alt=""></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/07/26/vim/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Vim使用</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="android_ffmpeg" data-title="FFmpeg和libyuv的基本使用" data-url="http://yoursite.com/2017/07/27/android_ffmpeg/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 weifeng
    	</div>
      	<div class="footer-right">
      		<!--<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten-->
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>


  </div>
</body>
</html>