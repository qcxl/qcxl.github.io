<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Mobile Development]]></title>
  <subtitle><![CDATA[移动开发]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com//"/>
  <updated>2016-10-14T12:17:02.000Z</updated>
  <id>http://yoursite.com//</id>
  
  <author>
    <name><![CDATA[weifeng]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python包管理工具的安装和爬虫学习]]></title>
    <link href="http://yoursite.com/2016/09/25/python_scrapy_study/"/>
    <id>http://yoursite.com/2016/09/25/python_scrapy_study/</id>
    <published>2016-09-25T01:28:11.000Z</published>
    <updated>2016-10-14T12:17:02.000Z</updated>
    <content type="html"><![CDATA[<h4 id="pip简介"><a href="https://pypi.python.org/pypi/pip" target="_blank" rel="external">pip</a>简介</h4><ul>
<li><code>pip</code>是一个安装和管理Python包的工具,是<code>easy_install</code>的一个替换品.<code>pip</code>的目标非常明确 – 取代<code>easy_install</code>. easy_install有很多不足:<ul>
<li>安装事务是非原子操作</li>
<li>只支持svn</li>
<li>没有提供卸载命令</li>
<li>安装一系列包时需要写脚本</li>
</ul>
</li>
<li>pip使用<a href="http://pip.readthedocs.io/en/latest/" target="_blank" rel="external">帮助文档</a></li>
</ul>
<a id="more"></a>
<ul>
<li>pip使用<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">pip install Scrapy</span><br><span class="line"><span class="comment"># 通过使用==, &gt;=, &lt;=, &gt;, &lt;来指定一个版本号。</span></span><br><span class="line">$ pip install <span class="string">'Markdown&lt;2.0'</span></span><br><span class="line"><span class="comment"># 卸载包</span></span><br><span class="line">pip uninstall Scrapy</span><br><span class="line"><span class="comment"># 升级包</span></span><br><span class="line">pip install --upgrade Scrapy</span><br><span class="line">pip install -U Scrapy</span><br><span class="line"><span class="comment"># 查询包</span></span><br><span class="line">pip search <span class="string">"Markdown"</span></span><br><span class="line"><span class="comment"># 列出已安装包</span></span><br><span class="line">pip freeze</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="卸载pip">卸载<a href="https://pypi.python.org/pypi/pip" target="_blank" rel="external">pip</a></h4><ul>
<li>如果是通过<code>easy_install pip</code> 安装的pip 有可能会提示你更新pip,然后使用<code>pip install --upgrade pip</code>或者<code>pip install -U pip</code>会出现安装失败,提示你先卸载pip,这个时候可以使用下面的命令<code>sudo pip uninstall pip</code>先卸载pip然后再安装</li>
</ul>
<h4 id="安装pip">安装<a href="https://pypi.python.org/pypi/pip" target="_blank" rel="external">pip</a></h4><ul>
<li>下载<a href="https://pypi.python.org/packages/e7/a8/7556133689add8d1a54c0b14aeff0acb03c64707ce100ecd53934da1aa13/pip-8.1.2.tar.gz#md5=87083c0b9867963b29f7aba3613e8f4a" target="_blank" rel="external">pip-8.1.2.tar.gz (md5, pgp)</a>源码包,然后解压文件并进入<code>pip-8.1.2</code>目录,使用<code>sudo python setup.py install</code>安装.</li>
</ul>
<h4 id="安装setuptool">安装<a href="https://pypi.python.org/pypi/setuptools" target="_blank" rel="external">setuptool</a></h4><blockquote>
<p>easy_install是setuptools自带的安装脚本,也就是一旦setuptools安装完毕,easy_install也便可用.最大的特点是自动查找Python 官方维护的包源PyPI,安装第三方Python包非常方便</p>
<ul>
<li>通过curl下载安装<code>curl https://bootstrap.pypa.io/ez_setup.py -o - | python</code></li>
<li>easy_install 使用<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">easy_install Scrapy</span><br><span class="line"><span class="comment"># 卸载包</span></span><br><span class="line">easy_install -m Scrapy</span><br><span class="line"><span class="comment"># 升级包</span></span><br><span class="line">easy_install --upgrade Scrapy</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="安装BeautifulSoup">安装<a href="https://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="external">BeautifulSoup</a></h4><ul>
<li>通过<code>pip install beautifulsoup4</code>来安装</li>
</ul>
<h4 id="安装PhantomJS">安装<a href="http://phantomjs.org/quick-start.html" target="_blank" rel="external">PhantomJS</a></h4><blockquote>
<p>PhantomJS 是一个基于 WebKit 的服务器端 JavaScript API。它全面支持web而不需浏览器支持，其快速、原生支持各种Web标准：DOM 处理、CSS 选择器、JSON、Canvas 和 SVG。 PhantomJS 可以用于页面自动化、网络监测、网页截屏以及无界面测试等。</p>
</blockquote>
<ul>
<li>brew install phantomjs</li>
</ul>
<h4 id="安装PySpider">安装<a href="http://docs.pyspider.org/en/latest/" target="_blank" rel="external">PySpider</a></h4><blockquote>
<p><a href="http://www.pyspider.cn/" target="_blank" rel="external">pyspider中文网</a></p>
</blockquote>
<ul>
<li>直接利用 pip 安装即可 <code>sudo pip install pyspider</code></li>
<li>如果安装过程中出现<code>error: could not create &#39;/System/Library/Frameworks/Python.framework/Versions/2.7/share&#39;: Operation not permitted</code> 有一个方法,关机.开机前按着 <code>cmd键 + R</code> ,会进入一个 恢复模式. 在菜单栏 有一个选项:”终端”.进入终端后,输入 <code>csrutil disable</code> . 这样就关闭了OSX10.11的目录写入权限验证. 重启电脑,你会发现上述目录不再提示权限不足.剩下按照报错提示操作.要回复安全机制,同理回到之前的模式,然后输入 <code>csrutil enable</code></li>
<li>安装过程中可能缺少一些包,<a href="https://pypi.python.org/pypi" target="_blank" rel="external">打开</a>并搜索安装需要的包</li>
<li>最后执行<code>pyspider all</code>如果没有出错说明运行成功了,然后浏览器访问<code>http://localhost:5000</code>.</li>
</ul>
<h4 id="运行PySpider可能出现的问题">运行<a href="http://docs.pyspider.org/en/latest/" target="_blank" rel="external">PySpider</a>可能出现的问题</h4><ul>
<li>在终端中输入<code>pyspider all</code> 有可能会出现 <code>ImportError: No module named xmlrpc_server</code> 这个是因为你使用的是Python 2.7的问题,six 中的xmlrpc_server模块需要 Python3才能使用,解决办法:将Python切换到Python3之后,重新运行就不会报这个错了.如果当前已经是Python3还是存在这个问题可以尝试升级一下six库: <code>pip install -U six</code></li>
</ul>
<h4 id="Mac_OS_X_下_Python多版本共存">Mac OS X 下 Python多版本共存</h4><ul>
<li>安装pyenv.<code>brew install pyenv</code></li>
<li>然后使用<code>open -e ~/.bash_profile</code>打开.bash_profile文件,加入<code>eval &quot;$(pyenv init -)&quot;</code></li>
<li>最后执行<code>source ~/.bash_profile</code></li>
<li>查看 Python 安装路径: <code>which python</code></li>
</ul>
<h5 id="使用_pyenv_安装_Python_的其他版本">使用 pyenv 安装 Python 的其他版本</h5><ul>
<li>查看能安裝的版本 <code>pyenv install --list</code></li>
<li>使用 pyenv 安装 Python 3.5.2:<code>pyenv install 3.5.2 -v</code></li>
<li>安装完成后,更新数据库 <code>pyenv rehash</code></li>
<li>查看目前系统已安装的 Python 版本: <code>pyenv versions</code>.其中显示的<code>*</code>表示系统当前正在使用的版本</li>
<li>切换 Python 版本:<code>pyenv global 3.5.2</code></li>
<li>运行 Python,确认 Python 版本:<code>python --version</code></li>
<li>将 Python 切换回 2.7.10:<code>pyenv global 2.7.10</code></li>
<li>设置局部 Python 版本:<code>pyenv local &lt;python版本&gt;</code></li>
</ul>
<h5 id="查看路径">查看路径</h5><ul>
<li>在终端中输入:<code>echo $PATH</code> 接下來就会看到一串类似这样的東西 <code>/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin</code> , 分号 (:) 是分隔的意思,所以當你在 terminal 裡面輸入 brew 时系统就会开始从 /usr/bin 找起,如果在 /usr/bin 里面找不到的话<br>就会往下一个 /bin 去搜寻,以此类推</li>
<li><p>我们可以使用命令调整搜寻顺序: <code>sudo emacs /etc/paths</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">control + k：把一行字剪下來</span><br><span class="line">control + y：粘贴</span><br><span class="line">control + x + s：保存</span><br><span class="line">control + x + c：关掉 emacs</span><br></pre></td></tr></table></figure>
</li>
<li><p>调整好后,再打一次<code>echo $PATH</code>发现没有变更,需要开一个新的terminal才会看到调整后的内容</p>
</li>
</ul>
<h4 id="安装Scrapy">安装Scrapy</h4><ul>
<li><code>sudo -H pip install -U Scrapy</code></li>
</ul>
<h4 id="Scrapy的简单使用">Scrapy的简单使用</h4><ul>
<li>新建Scrapy项目: <code>scrapy startproject 项目名称</code></li>
<li><p>在当前项目中创建Spider: <code>cd 项目名称</code>、<code>scrapy genspider [-t template] &lt;name&gt; &lt;domain&gt;</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">-t 为使用的模板名称</span><br><span class="line">name spider名称</span><br><span class="line">domain 要爬取的网站域名</span><br><span class="line"></span><br><span class="line">查看可供使用的模板:</span><br><span class="line">scrapy genspider -l</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">Available templates:</span><br><span class="line">  basic</span><br><span class="line">  crawl</span><br><span class="line">  csvfeed</span><br><span class="line">  xmlfeed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看使用指定模板生成的spider:</span><br><span class="line">scrapy genspider -d basic</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">class $classname(scrapy.Spider):</span><br><span class="line">    name = "$name"</span><br><span class="line">    allowed_domains = ["$domain"]</span><br><span class="line">    start_urls = (</span><br><span class="line">        'http://www.$domain/',</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">scrapy genspider -t basic example example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前项目有哪些spider: <code>scrapy list</code></p>
</li>
<li>运行某个spider: <code>scrapy crawl name_spider</code></li>
<li>将爬取到的内容以json格式保存到文件: <code>scrapy crawl name_spider -o name.json -t json</code></li>
<li>查看scrapy中的组件版本: <code>scrapy version -v</code></li>
<li>查看页面源码在浏览器中显示的样子: <code>scrapy view 网址</code></li>
<li>用来测试在工程中使用固定的parse函数解析某个页面是否存在问题: <code>scrapy parse 网址</code></li>
<li>用shell来调试数据、检测xpath、查看页面源码,等等: <code>scrapy shell 网址</code></li>
<li>运行自包含的爬虫: <code>scrapy runspider stackoverflow_spider.py</code></li>
<li>执行一个基准测试: <code>scrapy bench</code> 可用来检测scrapy是否安装成功</li>
</ul>
<h5 id="基类(scrapy-Spider)介绍">基类(scrapy.Spider)介绍</h5><ul>
<li>属性:<ul>
<li>name: spider的名称,要求唯一 </li>
<li>allowed_domains: 允许的域名</li>
<li>start_urls: 初始urls</li>
<li>custom_settings: 个性化配置,会覆盖全局的设置</li>
<li>crawler: 抓取器,spider将绑定在它上面</li>
<li>settings: 配置实例,包含工程中所有的配置变量</li>
<li>logger: 日志实例</li>
</ul>
</li>
<li>方法:<ul>
<li>from_crawler(cls, crawler, <em>args, *</em>kwargs): 类方法,用来创建spiders</li>
<li>start_requests(): 生成初始化的requests</li>
<li>make_requests_from_url(url): 根据url生成一个request</li>
<li>parse(response): 用来解析网页内容</li>
<li>log(self, message, level=logging.DEBUG, **kw): 用来记录日志,这里请使用logger属性来记录日志self.logger.info(“xxx”)</li>
<li>close(spider, reason): 当spider关闭的时候调用的方法</li>
</ul>
</li>
</ul>
<h5 id="Spider子类介绍">Spider子类介绍</h5><ul>
<li>CrawlSpider: 最常用的spider,用于抓取普通的网页.增加了两个成员:<ul>
<li>rules: 定义了一些抓取的规则—连接怎么跟踪、使用哪一个parse函数解析此连接</li>
<li>parse_start_url(response): 解析初始化url的响应</li>
</ul>
</li>
<li>XMLFeedSpider</li>
<li>CSVFeedSpider</li>
<li>SitemapSpider</li>
</ul>
<h5 id="网页内容抽取器Selector">网页内容抽取器Selector</h5><ul>
<li>用来解析网页的库有很多,比如beautifulsoup、lxml,但在scrapy里面默认使用的是selector,相对来说也是最好用的</li>
<li><p>基本使用:</p>
<ul>
<li><p>实例化: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.selector <span class="keyword">import</span> Selector</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> HtmlResponse</span><br><span class="line"></span><br><span class="line">方式一:</span><br><span class="line">body = <span class="string">'&lt;html&gt;&lt;body&gt;&lt;span&gt;good&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;'</span> </span><br><span class="line">Selector(text=body).xpath(<span class="string">'//span/text()'</span>).extract()</span><br><span class="line"></span><br><span class="line">方式二:</span><br><span class="line">response = HtmlResponse(url=<span class="string">'http://example.com'</span>,body=body)</span><br><span class="line">Selector(response=response).xpath(<span class="string">'//span/text()'</span>).extract()</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用方法: xpath、css、re、extract</p>
</li>
</ul>
</li>
</ul>
<h4 id="XPath知识点">XPath知识点</h4><ul>
<li>对于要一次同时提取几个标签里的文本,可以采用如下形式:<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div id="test-1"&gt;需要的内容1&lt;/div&gt;</span><br><span class="line">&lt;div id="test-2"&gt;需要的内容2&lt;/div&gt;</span><br><span class="line">&lt;div id="testfault"&gt;需要的内容3&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">contents = Selector(response).xpath('//div[start-with(@id,'test')]/text()').extract()</span><br><span class="line">for content in contents:</span><br><span class="line">	print(content)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="pip简介"><a href="https://pypi.python.org/pypi/pip">pip</a>简介</h4><ul>
<li><code>pip</code>是一个安装和管理Python包的工具,是<code>easy_install</code>的一个替换品.<code>pip</code>的目标非常明确 – 取代<code>easy_install</code>. easy_install有很多不足:<ul>
<li>安装事务是非原子操作</li>
<li>只支持svn</li>
<li>没有提供卸载命令</li>
<li>安装一系列包时需要写脚本</li>
</ul>
</li>
<li>pip使用<a href="http://pip.readthedocs.io/en/latest/">帮助文档</a></li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[汇编语言学习]]></title>
    <link href="http://yoursite.com/2016/09/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2016/09/10/汇编语言学习/</id>
    <published>2016-09-10T01:28:11.000Z</published>
    <updated>2016-10-14T12:16:36.000Z</updated>
    <content type="html"><![CDATA[<h4 id="Mac_上搭建汇编环境">Mac 上搭建汇编环境</h4><ul>
<li>下载<a href="https://www.dosbox.com/" target="_blank" rel="external">DOSBOX</a></li>
<li>下载debug.exe程序到Mac</li>
<li>最后运行DOSBOX,并挂载本地debug.exe所在的目录到DOSBOX的一个盘符,比如你的debug.exe在<code>/Users/weifeng/Downloads/DOS/</code>,就在DOSBOX中运行命令:<code>mount c: /Users/weifeng/Downloads/DOS/</code>,再运行命令<code>c:</code>进入c盘符,最后运行命令:<code>debug</code>,就行了.</li>
</ul>
<a id="more"></a>
<h4 id="寄存器">寄存器</h4><ul>
<li>AX、BX、CX、DX是通用寄存器</li>
<li>它们有分成AH、AL…</li>
<li>它们是用来存储数据的</li>
</ul>
<h5 id="地址加法器工作原理">地址加法器工作原理</h5><ul>
<li>8086CPU外部提供了20根地址总线,而CPU内部由于技术的问题只能提供16位的地址那怎么办呢? 它提供了血汗工厂:地址加法器,将2个16位的地址最后合成一个20位的地址.</li>
<li>地址加法器合成物理地址的方法:<code>物理地址 = 段地址 * 16 + 偏移地址</code> 其中段地址存储在段寄存器中,8086CPU有4个段寄存器:CS、DS、SS、ES.</li>
<li>段地址乘以16相当于向左移一位.例如对于十进制数:<code>3 * 10 = 30</code> 向左移一位</li>
<li>1个16进制的数代表4个二进制的位</li>
<li><code>段地址 * 16</code> 有一个更为常用的说法就是数据左移4位.(二进制位)</li>
<li>一个数据的二进制形式左移1位,相当于该数乘以2;</li>
<li>一个数据的二进制形式左移N位,相当于该数据乘以2的N次方;</li>
<li>一个数据的十六进制形式左移1位,相当于乘以16;</li>
<li>一个数据的十进制形式左移1位,相当于乘以10;</li>
<li>一个数据的X进制形式左移1位,相当于乘以X;</li>
</ul>
<!--more-->
<h4 id="段的概念">段的概念</h4><ul>
<li>内存并没有分段,段的划分来自于CPU,由于8086CPU用<code>物理地址 = 段地址 * 16 + 偏移地址</code>的方式给出内存单元的物理地址,使得我们可以用分段的方式来管理内存.</li>
<li><code>段地址 *  16</code>必然是16的倍数,所以一个段的起始地址也一定是16的倍数;</li>
<li>偏移地址为16位,16位地址的寻址能力为64K,所以一个段的长度最大为64K.</li>
<li>CPU可以用不同的段地址和偏移地址形成同一个物理地址</li>
<li>偏移地址16位,变化范围为0~FFFFH,仅用偏移地址来寻址最多可寻64K个内存单元</li>
<li>比如:给定段地址1000H,用偏移地址寻址,CPU的寻址范围为:10000H~1FFFFH.</li>
<li>在8086PC机中,存储单元的地址用两个元素来描述.即段地址和偏移地址.</li>
<li>可根据需要,将地址连续、起始地址为16的倍数的一组内存单元定义为一个段</li>
</ul>
<h4 id="段寄存器">段寄存器</h4><ul>
<li>段寄存器就是提供段地址的.<br>8086CPU有4个段寄存器:CS、DS、SS、ES</li>
<li>当有8086CPU需要访问内存时,由这4个段寄存器提供内存单元的段地址.</li>
<li>CS是Code Segement是代码段地址寄存器</li>
<li>DS是Data Segement是数据段地址寄存器</li>
<li>SS是Stack Segement是堆栈段地址寄存器</li>
<li>ES是附加段地址寄存器</li>
<li>CS和IP是8086CPU中最关键的寄存器,它们指示了CPU当前要读取指令的地址</li>
<li>IP为指令指针寄存器</li>
</ul>
<h4 id="8086CPU工作过程的简要描述">8086CPU工作过程的简要描述</h4><ul>
<li>从CS:IP指向内存单元读取指令,读取的指令进入指令缓冲器;</li>
<li>IP = IP + 所读取指令的长度,从而指向下一条指令;</li>
<li>执行指令.转到步骤 1 ,重复这个过程.</li>
</ul>
<h4 id="8086CPU工作过程的简要描述-1">8086CPU工作过程的简要描述</h4><ul>
<li>在8086CPU加电启动或复位后(即CPU刚开始工作时)CS和IP被设置为CS = FFFFH,IP = 0000H.</li>
<li>即在8086PC机刚启动时,CPU从内存FFFF0H单元中读取指令执行.</li>
<li>FFFF0H单元中的指令是8086PC机开机后执行的第一条指令.</li>
</ul>
<h4 id="CS和IP">CS和IP</h4><ul>
<li>在任何时候,CPU将CS、IP的内容当作指令的段地址和偏移地址,用它们合成指令的物理地址,到内存中读取指令码,执行.</li>
<li>如果说,内存中的一段信息曾被CPU执行过的话,那么,它所在的内存单元必然被CS:IP指向过.</li>
</ul>
<h4 id="修改CS、IP的指令">修改CS、IP的指令</h4><ul>
<li>在CPU中,程序员能够用指令读写的部件只有寄存器,程序员可以通过改变寄存器中的内容实现对CPU的控制</li>
<li>CPU从何处执行指令是有CS、IP中的内容来控制CPU执行目标指令.</li>
</ul>
<h4 id="如何修改AX中的值">如何修改AX中的值</h4><ul>
<li>mov 指令</li>
<li>如: mov ax,123</li>
<li>mov 指令可以改变8086CPU大部分寄存器的值,被称为传送指令</li>
</ul>
<h4 id="修改CS、IP的指令-1">修改CS、IP的指令</h4><ul>
<li>mov指令不能用于设置CS、IP的值,8086CPU没有提供这样的功能</li>
<li>8086CPU为CS、IP提供了另外的指令来改变它们的值:转移指令</li>
<li>同时修改CS、IP的内容:jmp 段地址 : 偏移地址</li>
<li>jmp 2AE3:3 (最后的地址为2AE33H)   jmp 3:0B16 (最后的地址为00B46H)</li>
<li>功能:用指令中给出的段地址修改CS,偏移地址修改IP</li>
<li>仅修改IP的内容: jmp 某一合法寄存器  </li>
<li>jmp ax (类似于 mov IP,ax) 、jmp bx</li>
<li>功能:用寄存器中的值修改IP</li>
</ul>
<h4 id="代码段">代码段</h4><ul>
<li>对于8086PC机,在编程时,可以根据需要,将一组内存单元定义为一个段.</li>
<li>可以将长度为N(N&lt;=64KB)的一组代码,存在一组地址连续、起始地址为16的倍数的内存单元中,这段内存是用来存放代码的,从而定义了一个代码段</li>
<li>CPU只能被CS:IP指向的内存单元中的内容为指令</li>
<li>所以要将CS:IP指向所定义的代码段中的第一条指令的首地址.</li>
</ul>
<h4 id="DEBUG">DEBUG</h4><ul>
<li>R命令查看、改变CPU寄存器的内容</li>
<li>D命令查看内存中的内容</li>
<li>E命令改写内存中的内容</li>
<li>U命令将内存中的机器指令翻译成汇编指令</li>
<li>T命令执行一条机器指令</li>
<li>A命令以汇编指令的格式在内存中写入一条机器指令<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">e <span class="number">1000</span>:<span class="number">0</span> <span class="number">23</span> <span class="number">11</span> <span class="number">22</span> <span class="number">66</span> -&gt; 向<span class="number">10000</span>H内存单元地址中写入 <span class="number">23</span> <span class="number">11</span> <span class="number">22</span> <span class="number">66</span></span><br><span class="line">d <span class="number">1000</span>:<span class="number">0</span> -&gt; 查看<span class="number">10000</span>H内存单元地址中写入的数据</span><br><span class="line">r 查看CPU寄存器的内容</span><br><span class="line">a <span class="number">073</span>f:<span class="number">011</span>a -&gt; 开始往<span class="number">0750</span>a中写入代码</span><br><span class="line">mov ax,<span class="number">1000</span></span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,[<span class="number">0</span>]</span><br><span class="line">mov bx,[<span class="number">2</span>]</span><br><span class="line">mov cx,[<span class="number">1</span>]</span><br><span class="line">add bx,[<span class="number">1</span>]</span><br><span class="line">add cx,[<span class="number">2</span>]</span><br><span class="line">t 单步执行汇编指令直到执行结束查看每一步执行时 ax、ds等的变化</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="DS和[address]">DS和[address]</h4><ul>
<li>mov 指令的格式: mov 寄存器名,内存单元地址</li>
<li>“[…]” 表示一个内存单元,”[…]”中的0表示内存单元的偏移地址.</li>
<li>执行指令时,8086CPU自动取DS中的数据为内存单元的段地址.</li>
<li>如何用mov指令从10000H中读取数据?<ul>
<li>mov bx,1000H -&gt; mov ds,bx -&gt; mov al,[0]</li>
<li>10000H表示为1000:0(段地址:偏移地址)</li>
<li>将段地址1000H放入ds</li>
<li>用mov al,[0]完成传送(mov指令中的[]说明操作对象是一个内存单元,[]中的0说明这个内存单元的偏移地址是0,它的段地址默认放在ds中)</li>
</ul>
</li>
<li>如何把1000H送入ds?    </li>
<li>8086CPU不支持将数据直接送入段寄存器的操作,ds是一个段寄存器.</li>
<li>mov ds,1000H是非法的.</li>
<li>数据 -&gt; 通用寄存器 -&gt; 段寄存器</li>
<li>怎样将数据从寄存器送入内存单元?<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">move bx,<span class="number">1000</span>H</span><br><span class="line">move ds,bx</span><br><span class="line">move [<span class="number">0</span>],a1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="值的传送">值的传送</h4><ul>
<li>因为8086CPU是16位结构,有16根数据线,所以,可以一次性传送16位的数据,也就是一次性传送一个字.</li>
<li>比如:<pre><code class="objc">mov bx,<span class="number">1000</span>H
mov ds,bx
mov ax,[<span class="number">0</span>]  <span class="number">1000</span>:<span class="number">0</span>处的字型数据送入ax
mov [<span class="number">0</span>],cx  cx中的<span class="number">16</span>位数据送到<span class="number">1000</span>:<span class="number">0</span>处
</code></pre>
</li>
</ul>
<h4 id="CPU提供的栈机制">CPU提供的栈机制</h4><ul>
<li>8086CPU提供入栈和出栈指令:<ul>
<li>PUSH (入栈)</li>
<li>POP (出栈)</li>
</ul>
</li>
<li>push ax: 将寄存器ax中的数据送人栈中</li>
<li>pop ax: 从栈顶取出数据送人ax</li>
<li>8086CPU的入栈和出栈操作都是以字为单位进行的</li>
<li>8086CPU中,有两个寄存器:<ul>
<li>段寄存器SS 存放栈顶的段地址</li>
<li>寄存器SP 存放栈顶的偏移地址</li>
</ul>
</li>
<li>任意时刻,SS:SP指向栈顶元素.</li>
</ul>
<h4 id="push指令的执行过程">push指令的执行过程</h4><ul>
<li>push ax<ul>
<li>SP = SP - 2</li>
<li>将ax中的内容送人SS:SP指向的内存单元处,SS:SP此时指向新栈顶.</li>
</ul>
</li>
<li>任意时刻,SS:SP指向栈顶元素,当栈为空的时候,栈中没有元素,也就不存在栈顶元素</li>
<li>所以SS:SP只能指向栈的最底部单元下面的单元,该单元的偏移地址为栈最底部的字单元的偏移地址+2</li>
<li>栈最底部字单元的地址为1000:000E,所以栈空时,SP=0010H。</li>
</ul>
<h4 id="pop指令的执行过程">pop指令的执行过程</h4><ul>
<li>pop ax<ul>
<li>将SS:SP指向的内存单元处的数据送人ax中</li>
<li>SP = SP + 2, SS:SP指向当前栈顶下面的单元,以当前栈顶下面的单元为新的栈顶</li>
</ul>
</li>
</ul>
<h4 id="push、pop指令">push、pop指令</h4><ul>
<li>push和pop指令是可以在寄存器和内存之间传送数据的</li>
<li>push 寄存器 : 将一个寄存器中的数据入栈</li>
<li>pop 寄存器  : 用一个寄存器接收出栈的数据</li>
<li>push 段寄存器 : 将一个段寄存器中的数据入栈</li>
<li>pop 段寄存器 : 出栈,用一个段寄存器接收出栈的数据</li>
<li>push 内存单元 : 讲一个内存单元处的字入栈(栈操作都是以字为单位)</li>
<li>pop 内存单元 : 出栈,用一个内存字单元接收出栈的数据</li>
<li>指令执行时,CPU要知道内存单元的地址,可以在push、pop指令中给出内存单元的偏移地址,段地址在指令执行时,CPU从ds中取得.</li>
</ul>
<h4 id="栈与内存">栈与内存</h4><ul>
<li>栈空间当然也是内存空间的一部分,它只是一段可以以一种特殊的方式进行访问的内存空间</li>
<li>push、pop实质上就是一种内存传送指令,可以在寄存器和内存之间传送数据,与mov指令不同的是,push和pop指令访问的内存单元的地址不是指令中给出的,而是由SS:SP指出的.</li>
<li>同时,push和pop指令还要改变SP中的内容</li>
<li>执行push时 先改变SP,然后向SS:SP处传送.</li>
<li>执行pop时    先读取SS:SP处的数据,然后改变SP.</li>
<li>push、pop等栈操作指令,修改的只是SP也就是说,栈顶的变化范围最大为:0~FFFFH.因为SP存放的也是16位,所以最大值是FFFFH,2的16次方 = 65536,65536/1024 = 64KB,最大存储64KB的数据</li>
</ul>
<h4 id="定义一个段">定义一个段</h4>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="Mac_上搭建汇编环境">Mac 上搭建汇编环境</h4><ul>
<li>下载<a href="https://www.dosbox.com/">DOSBOX</a></li>
<li>下载debug.exe程序到Mac</li>
<li>最后运行DOSBOX,并挂载本地debug.exe所在的目录到DOSBOX的一个盘符,比如你的debug.exe在<code>/Users/weifeng/Downloads/DOS/</code>,就在DOSBOX中运行命令:<code>mount c: /Users/weifeng/Downloads/DOS/</code>,再运行命令<code>c:</code>进入c盘符,最后运行命令:<code>debug</code>,就行了.</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS逆向学习]]></title>
    <link href="http://yoursite.com/2016/09/05/iOS%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2016/09/05/iOS逆向学习/</id>
    <published>2016-09-05T01:28:11.000Z</published>
    <updated>2016-10-14T12:18:34.000Z</updated>
    <content type="html"><![CDATA[<h4 id="当Mac_OSX_10-11的/usr/bin目录不可写之后,class-dump应该何处安家?">当Mac OSX 10.11的/usr/bin目录不可写之后,class-dump应该何处安家?</h4><ul>
<li>打开Terminal,输入mkdir ~/bin,在当前用户根目录下创建一个bin目录;</li>
<li>把class-dump给拷贝到这个目录里,并赋予其可执行权限:mv /path/to/class-dump ~/bin; chmod +x ~/bin/class-dump;</li>
<li>打开~/.bash_profile文件:vi ~/.bash_profile,在文件最上方加一行:export PATH=$HOME/bin/:$PATH,然后保存并退出,然后输入wq,回车即可;</li>
<li>在Terminal中执行source ~/.bash_profile;</li>
</ul>
<a id="more"></a>
<h4 id="使用方法">使用方法</h4><ul>
<li>class-dump -H 要破解的可执行文件路径 -o 破解后的头文件存放路径</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="当Mac_OSX_10-11的/usr/bin目录不可写之后,class-dump应该何处安家?">当Mac OSX 10.11的/usr/bin目录不可写之后,class-dump应该何处安家?</h4><ul>
<li>打开Terminal,输入mkdir ~/bin,在当前用户根目录下创建一个bin目录;</li>
<li>把class-dump给拷贝到这个目录里,并赋予其可执行权限:mv /path/to/class-dump ~/bin; chmod +x ~/bin/class-dump;</li>
<li>打开~/.bash_profile文件:vi ~/.bash_profile,在文件最上方加一行:export PATH=$HOME/bin/:$PATH,然后保存并退出,然后输入wq,回车即可;</li>
<li>在Terminal中执行source ~/.bash_profile;</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[MJRefresh 框架知识点]]></title>
    <link href="http://yoursite.com/2016/08/26/MJRefresh%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2016/08/26/MJRefresh框架知识点/</id>
    <published>2016-08-26T02:11:36.000Z</published>
    <updated>2016-10-14T12:12:31.000Z</updated>
    <content type="html"><![CDATA[<h4 id="UIScrollView的几个属性">UIScrollView的几个属性</h4><ul>
<li>frame: 是指UIScrollView的可视范围</li>
<li>contentSize: 是其滚动范围,内容视图的大小</li>
<li>contentInset: 为UIScrollView增加额外的滚动区域,是UIScrollView的contentView的顶点相对于UIScrollView的位置</li>
<li>contentOffset: 是个CGpoint类型的结构体,用来记录ScrollView的滚动位置.垂直往下滚动时contentOffset的Y值越来越小,当偏离UIScrollView左上角时,contentOffset的Y值为负值。垂直往上滚动时contentOffset的Y值越来越大。</li>
</ul>
<a id="more"></a>
<h4 id="MJRefreshComponent刷新视图的基类。刷新头部和尾部视图都继承自该类">MJRefreshComponent刷新视图的基类。刷新头部和尾部视图都继承自该类</h4><ul>
<li><code>- (instancetype)initWithFrame:(CGRect)frame</code> 初始化刷新视图,并将刷新状态置为空闲状态. 内部会调用<code>- (void)prepare</code> 做一些初始化刷新视图的准备工作。 </li>
<li><code>- (void)willMoveToSuperview:(UIView *)newSuperview</code> 当刷新视图即将添加到父视图(UITableView、UICollectionView)中的时候会调用。这个方法中设置刷新视图的宽和X坐标、记录UIScrollView、设置UIScrollView永远支持垂直弹簧效果、记录UIScrollView最开始的contentInset、添加UIScrollView的ContentOffset和ContentSize以及pan手势状态的监听</li>
<li><code>- (void)placeSubviews</code> 调用子类的placeSubviews重新布局刷新视图的子控件</li>
<li><code>- (void)setState:(MJRefreshState)state</code> 更新刷新视图状态 并刷新布局</li>
<li><code>- (void)beginRefreshing</code> 进入刷新状态. 将刷新视图的透明度和拉拽的百分比值都置为1.0并更新刷新状态为正在刷新</li>
<li><code>- (void)endRefreshing</code> 结束刷新状态. 更新刷新状态为结束刷新</li>
<li><code>- (void)setAutomaticallyChangeAlpha:(BOOL)automaticallyChangeAlpha</code> 根据拖拽比例自动切换透明度</li>
<li><code>- (void)setPullingPercent:(CGFloat)pullingPercent</code> 根据拖拽进度设置透明度</li>
</ul>
<h4 id="MJRefreshHeader刷新头部视图的基类继承自MJRefreshComponent">MJRefreshHeader刷新头部视图的基类继承自MJRefreshComponent</h4><ul>
<li><code>+ (instancetype)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock</code> 和 <code>+ (instancetype)headerWithRefreshingTarget:(id)target refreshingAction:(SEL)action</code> 通过设置正在刷新的回调来初始化刷新头部视图</li>
<li><code>- (void)prepare</code> 在初始化视图的时候设置刷新头部视图高度为MJRefreshHeaderHeight(默认值为54)</li>
<li><code>- (void)placeSubviews</code> 设置刷新头部视图的Y值。<code>Y = - MJRefreshHeaderHeight - 忽略多少scrollView的contentInset的top;</code> 刷新头部会移到UIScrollView顶部之外</li>
<li><code>- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change</code> 当监听到UIScrollView的ContentOffset发生变化的时候会调用这个方法。记录当前UIScrollView的ContentInset、offsetY值、下拉刷新头刚好出现的offsetY、普通 和 即将刷新 的临界点,如果UIScrollView正在拖拽记录拖拽进度并通过比较offsetY与刷新 的临界点之间的大小来判断刷新状态是否即将刷新还是空闲状态并更新刷新头部状态,如果用户松开手指并且刷新状态为即将刷新 则执行<code>- (void)beginRefreshing</code>开始刷新</li>
<li><code>- (void)setState:(MJRefreshState)state</code> 更新刷新状态。如果当前是空闲状态并且上次为正在刷新状态(即当前刷新完毕)则保存刷新时间,恢复inset和offset,拖拽进度重置为0。如果当前是正在刷新状态设置UIScrollView的上边距为刷新头部视图高度加上原来上边距并设置ContentOffset为负的ContentInset.Top最后调用内部方法<code>- (void)executeRefreshingCallback</code>执行刷新回调</li>
</ul>
<h4 id="MJRefreshStateHeader带刷新状态和时间的刷新头部视图继承自MJRefreshHeader">MJRefreshStateHeader带刷新状态和时间的刷新头部视图继承自MJRefreshHeader</h4><ul>
<li><code>- (void)prepare</code> 初始化文字距离圈圈、箭头的距离 与 初始化不同刷新状态下的文字 </li>
<li><code>- (void)placeSubviews</code> 布局刷新状态和刷新时间UILabel</li>
<li><code>- (void)setState:(MJRefreshState)state</code> 记录刷新状态、设置状态文字并重新显示时间</li>
</ul>
<h4 id="MJRefreshNormalHeader带刷新箭头和菊花样式的刷新头部视图继承自MJRefreshStateHeader">MJRefreshNormalHeader带刷新箭头和菊花样式的刷新头部视图继承自MJRefreshStateHeader</h4><ul>
<li><code>- (void)prepare</code> 设置活动指示器的样式</li>
<li><code>- (void)placeSubviews</code> 布局 刷新箭头和圈圈</li>
<li><code>- (void)setState:(MJRefreshState)state</code> 记录刷新状态。如果当前是空闲状态隐藏圈圈重置并显示箭头,如果当前刷新状态是正在下拉刷新则隐藏圈圈显示箭头并将箭头逆时针旋转180°,如果当前刷新状态为正在刷新则显示圈圈隐藏箭头</li>
</ul>
<h4 id="MJRefreshGifHeader带Gif动画的刷新头部视图继承自MJRefreshStateHeader">MJRefreshGifHeader带Gif动画的刷新头部视图继承自MJRefreshStateHeader</h4><ul>
<li><code>- (void)setImages:(NSArray *)images duration:(NSTimeInterval)duration forState:(MJRefreshState)state</code> 设置不同刷新状态下的显示图片和动画时长</li>
<li><code>- (void)prepare</code>初始化间距</li>
<li><code>- (void)setPullingPercent:(CGFloat)pullingPercent</code> 如果当前状态为空闲状态即还没变成松开刷新和正在刷新状态时,根据拖拽进度显示对应的图片</li>
<li><code>- (void)placeSubviews</code> 根据刷新状态Label和更新时间Label的显示状态来布局UIImageView Gif视图</li>
<li><code>- (void)setState:(MJRefreshState)state</code> 更新对象刷新状态下显示的图片</li>
</ul>
<h4 id="MJRefreshFooter刷新尾部视图继承自MJRefreshComponent(根据ContentSize来布局尾部刷新视图)">MJRefreshFooter刷新尾部视图继承自MJRefreshComponent(根据ContentSize来布局尾部刷新视图)</h4><ul>
<li><code>+ (instancetype)footerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock</code> 和 <code>+ (instancetype)footerWithRefreshingTarget:(id)target refreshingAction:(SEL)action</code> 通过设置正在刷新的回调来初始化刷新尾部视图</li>
<li><code>- (void)prepare</code> 设置刷新尾部视图的高度 当无数据时默认不隐藏尾部刷新视图</li>
<li><code>- (void)willMoveToSuperview:(UIView *)newSuperview</code> 监听scrollView数据的变化来显示或隐藏刷新尾部视图</li>
</ul>
<h4 id="MJRefreshBackFooter继承自MJRefreshFooter">MJRefreshBackFooter继承自MJRefreshFooter</h4><ul>
<li><code>- (void)willMoveToSuperview:(UIView *)newSuperview</code> 调用父类的该方法同时会调用<code>scrollViewContentSizeDidChange</code></li>
<li><code>- (void)scrollViewContentSizeDidChange:(NSDictionary *)change</code> 根据内容的高度和表格的高度来设置尾部刷新视图的Y坐标</li>
<li><code>- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change</code> 当监听到UIScrollView的ContentOffset发生变化的时候会调用这个方法。记录UIScrollView的contentInset、当前的contentOffset、尾部控件刚好出现的offsetY、拖拽进度值。如果UIScrollView正在拖拽 保存拖拽进度、获取普通 和 即将刷新 的临界点,如果当前刷新状态为空闲状态并且offsetY大于普通 和 即将刷新 的临界点值则更新为即将刷新状态,如果当前刷新状态为松开就可以进行刷新的状态并且offsetY小于普通 和 即将刷新 的临界点值则更新为空闲刷新状态。如果用户松开了手指并且当前刷新状态为松开就可以进行刷新的状态则调用<code>beginRefreshing</code>开始刷新</li>
<li><code>- (void)setState:(MJRefreshState)state</code> 根据状态来设置属性。如果当前刷新状态为正在刷新则更新UIScrollView的contentInset.bottom和contentOffset.y最后调用内部的<code>executeRefreshingCallback</code>执行刷新,如果当前刷新状态为所有数据加载完毕没有更多的数据或者普通闲置状态则调整contentInset.bottomcontentOffset.y重置拖拽进度值最后调用block结束刷新</li>
</ul>
<h4 id="MJRefreshAutoFooter继承自MJRefreshFooter">MJRefreshAutoFooter继承自MJRefreshFooter</h4><ul>
<li><code>- (void)prepare</code> 初始化并设置默认底部控件100%出现时才会自动刷新</li>
<li><code>- (void)willMoveToSuperview:(UIView *)newSuperview</code> 监听刷新尾部视图是否添加到UIScollView或者从其移除。如果添加到UIScrollView 将尾部刷新视图的Y坐标设置为contentSize.height 如果尾部刷新视图没被隐藏则添加底部间距为一个底部刷新视图的高度。如果被移除了底部间距要基于原来的基础上减去一个底部刷新视图的高度</li>
<li><code>- (void)scrollViewContentSizeDidChange:(NSDictionary *)change</code> 当ContentSize变化时更新底部刷新控件的Y坐标为contentSize.height</li>
<li><code>- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change</code> 如果内容超过一个屏幕并且<code>offsetY&gt;contentSize.height+contentInset.bottom-scrollView.height-刷新尾部视图高度+自动触发刷新的尾部视图高度比例</code> 则调用开始刷新</li>
<li><code>- (void)scrollViewPanStateDidChange:(NSDictionary *)change</code> 监听手势 当手松开的时候如果不够一个屏幕 并且向上拽 则调用刷新。如果手松开内容超出一个屏幕并且<code>offsetY&gt;contentSize.height+contentInset.bottom-scrollView高度</code>则开始刷新</li>
<li><code>- (void)setState:(MJRefreshState)state</code> 如果是正在刷新状态则执行内部的开始刷新,如果是所有数据加载完毕没有更多的数据了或者为普通空闲状态则调用结束刷新block</li>
</ul>
<h4 id="其它尾部视图刷新类的实现类似刷新头部视图">其它尾部视图刷新类的实现类似刷新头部视图</h4><h4 id="为UIScrollView做分类添加刷新头部和尾部视图供外部访问">为UIScrollView做分类添加刷新头部和尾部视图供外部访问</h4><h4 id="为UITableView和UICollectionView做分类_交换reloadData_和_mj_reloadData的实现">为UITableView和UICollectionView做分类 交换reloadData 和 mj_reloadData的实现</h4>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="UIScrollView的几个属性">UIScrollView的几个属性</h4><ul>
<li>frame: 是指UIScrollView的可视范围</li>
<li>contentSize: 是其滚动范围,内容视图的大小</li>
<li>contentInset: 为UIScrollView增加额外的滚动区域,是UIScrollView的contentView的顶点相对于UIScrollView的位置</li>
<li>contentOffset: 是个CGpoint类型的结构体,用来记录ScrollView的滚动位置.垂直往下滚动时contentOffset的Y值越来越小,当偏离UIScrollView左上角时,contentOffset的Y值为负值。垂直往上滚动时contentOffset的Y值越来越大。</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[SDWebImage 框架知识点]]></title>
    <link href="http://yoursite.com/2016/08/23/SDWebImage%20%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2016/08/23/SDWebImage 框架知识点/</id>
    <published>2016-08-23T02:57:36.000Z</published>
    <updated>2016-10-14T12:28:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="计算缓存图片大小">计算缓存图片大小</h3><ul>
<li><code>image.size.height * image.size.width * image.scale * image.scale</code></li>
</ul>
<h3 id="检查缓存文件是否是PNG图片">检查缓存文件是否是PNG图片</h3><ul>
<li>PNG图片前8位是137, 80, 78, 71, 13, 10, 26, 10 对应十六进制为0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)imageDataHasPNGPreffix:(<span class="built_in">NSData</span> *)data&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> kPNGSignatureBytes[<span class="number">8</span>] = &#123;<span class="number">0x89</span>, <span class="number">0x50</span>, <span class="number">0x4E</span>, <span class="number">0x47</span>, <span class="number">0x0D</span>, <span class="number">0x0A</span>, <span class="number">0x1A</span>, <span class="number">0x0A</span>&#125;;</span><br><span class="line">	<span class="built_in">NSData</span> *kPNGSignatureData = [<span class="built_in">NSData</span> dataWithBytes:kPNGSignatureBytes length:<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> pngSignatureLength = [kPNGSignatureData length];</span><br><span class="line">    <span class="keyword">if</span> ([data length] &gt;= pngSignatureLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[data subdataWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, pngSignatureLength)] isEqualToData:kPNGSignatureData]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h3 id="检查图片是否有Alpha值">检查图片是否有Alpha值</h3><ul>
<li><code>CGImageGetAlphaInfo</code><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)imageHasAlpha:(<span class="built_in">UIImage</span> *)image&#123;</span><br><span class="line">	<span class="keyword">int</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(image<span class="variable">.CGImage</span>);</span><br><span class="line">    <span class="built_in">BOOL</span> hasAlpha = !(alphaInfo == k<span class="built_in">CGImageAlphaNone</span> ||</span><br><span class="line">                      alphaInfo == k<span class="built_in">CGImageAlphaNoneSkipFirst</span> ||</span><br><span class="line">                      alphaInfo == k<span class="built_in">CGImageAlphaNoneSkipLast</span>);</span><br><span class="line">    <span class="keyword">return</span> hasAlpha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="检查图片的类型">检查图片的类型</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)contentTypeForImageData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    uint8_t c;</span><br><span class="line">    [data getBytes:&amp;c length:<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xFF</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"image/jpeg"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x89</span>:<span class="comment">//137 80 78 71 13 10 26 10</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"image/png"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x47</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"image/gif"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x49</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x4D</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@"image/tiff"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x52</span>:</span><br><span class="line">            <span class="comment">// R as RIFF for WEBP</span></span><br><span class="line">            <span class="keyword">if</span> ([data length] &lt; <span class="number">12</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSString</span> *testString = [[<span class="built_in">NSString</span> alloc] initWithData:[data subdataWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">12</span>)] encoding:<span class="built_in">NSASCIIStringEncoding</span>];</span><br><span class="line">            <span class="keyword">if</span> ([testString hasPrefix:<span class="string">@"RIFF"</span>] &amp;&amp; [testString hasSuffix:<span class="string">@"WEBP"</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">@"image/webp"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解析GIF图片">解析GIF图片</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)animatedGIFWithData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">	<span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> source = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)data, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    size_t count = <span class="built_in">CGImageSourceGetCount</span>(source);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *animatedImage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        animatedImage = [[<span class="built_in">UIImage</span> alloc] initWithData:data];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="built_in">NSMutableArray</span> *images = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSTimeInterval</span> duration = <span class="number">0.0</span>f;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="built_in">CGImageRef</span> image = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(source, i, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            duration += [<span class="keyword">self</span> frameDurationAtIndex:i source:source];</span><br><span class="line"></span><br><span class="line">            [images addObject:[<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:image scale:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.scale</span> orientation:<span class="built_in">UIImageOrientationUp</span>]];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">CGImageRelease</span>(image);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!duration) &#123;</span><br><span class="line">            duration = (<span class="number">1.0</span>f / <span class="number">10.0</span>f) * count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        animatedImage = [<span class="built_in">UIImage</span> animatedImageWithImages:images duration:duration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFRelease</span>(source);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> animatedImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">float</span>)frameDurationAtIndex:(<span class="built_in">NSUInteger</span>)index source:(<span class="built_in">CGImageSourceRef</span>)source &#123;</span><br><span class="line">    <span class="keyword">float</span> frameDuration = <span class="number">0.1</span>f;</span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> cfFrameProperties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(source, index, <span class="literal">nil</span>);</span><br><span class="line">    <span class="built_in">NSDictionary</span> *frameProperties = (__bridge <span class="built_in">NSDictionary</span> *)cfFrameProperties;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *gifProperties = frameProperties[(<span class="built_in">NSString</span> *)k<span class="built_in">CGImagePropertyGIFDictionary</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSNumber</span> *delayTimeUnclampedProp = gifProperties[(<span class="built_in">NSString</span> *)k<span class="built_in">CGImagePropertyGIFUnclampedDelayTime</span>];</span><br><span class="line">    <span class="keyword">if</span> (delayTimeUnclampedProp) &#123;</span><br><span class="line">        frameDuration = [delayTimeUnclampedProp floatValue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">//The amount of time, in hundredths of a second(0.01s), to wait before displaying the next image in an animated sequence.</span></span><br><span class="line">        <span class="built_in">NSNumber</span> *delayTimeProp = gifProperties[(<span class="built_in">NSString</span> *)k<span class="built_in">CGImagePropertyGIFDelayTime</span>];</span><br><span class="line">        <span class="keyword">if</span> (delayTimeProp) &#123;</span><br><span class="line">            frameDuration = [delayTimeProp floatValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Many annoying ads specify a 0 duration to make an image flash as quickly as possible.</span></span><br><span class="line">    <span class="comment">// We follow Firefox's behavior and use a duration of 100 ms for any frames that specify</span></span><br><span class="line">    <span class="comment">// a duration of &lt;= 10 ms. See &lt;rdar://problem/7689300&gt; and &lt;http://webkit.org/b/36082&gt;</span></span><br><span class="line">    <span class="comment">// for more information.</span></span><br><span class="line">    <span class="keyword">if</span> (frameDuration &lt; <span class="number">0.011</span>f) &#123;</span><br><span class="line">        frameDuration = <span class="number">0.100</span>f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFRelease</span>(cfFrameProperties);</span><br><span class="line">    <span class="keyword">return</span> frameDuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解析WebP图片">解析WebP图片</h3><ul>
<li>使用Google的WebP.framework框架 <a href="http://seanooi.github.io/iOS-WebP/" target="_blank" rel="external">地址</a></li>
<li>SDWebImage中支持WebP格式的,可以完成UIImage -&gt; Webp和WebP -&gt; UIImage的转换。直接通过CocoaPods的Podfile文件中加入pod ‘SDWebImage/WebP’即可。</li>
<li>WebP转换 Google提供了一套完整的工具集方便我们使用WebP.<a href="https://developers.google.com/speed/webp/docs/precompiled" target="_blank" rel="external">点此下载</a></li>
<li>创建一张图片:<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGImageRef</span> <span class="built_in">CGImageCreate</span> (</span><br><span class="line">   size_t width, <span class="comment">//图片的宽度</span></span><br><span class="line">   size_t height, <span class="comment">//图片的高度</span></span><br><span class="line">   size_t bitsPerComponent, <span class="comment">//图片每个颜色的位数,比如rgb颜色空间,有可能是5 或者 8等等</span></span><br><span class="line">   size_t bitsPerPixel, <span class="comment">//每一个像素占用的位数,15 位24位 32位等等</span></span><br><span class="line">   size_t bytesPerRow, <span class="comment">//每一行占用多少字节</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> space, <span class="comment">//颜色空间,比如rgb</span></span><br><span class="line">   <span class="built_in">CGBitmapInfo</span> bitmapInfo, <span class="comment">//layout,像素中bit的布局,是rgba还是argb</span></span><br><span class="line">   <span class="built_in">CGDataProviderRef</span> provider, <span class="comment">//数据源提供者,url或者内存等等</span></span><br><span class="line">   <span class="keyword">const</span> <span class="built_in">CGFloat</span> *decode, <span class="comment">//一个解码数组</span></span><br><span class="line">   <span class="keyword">bool</span> shouldInterpolate, <span class="comment">//抗锯齿参数</span></span><br><span class="line">   <span class="built_in">CGColorRenderingIntent</span> intent <span class="comment">//图片渲染相关参数</span></span><br><span class="line">);</span><br><span class="line">Color Spaces and Bitmap Layout,这里需要提供的几个东西:</span><br><span class="line"><span class="number">1.</span>位图是否包含alpha通道</span><br><span class="line"><span class="number">2.</span>color components是否已经乘以alpha value</span><br><span class="line"><span class="number">3.</span>数据格式是浮点数还是整型</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithWebPData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    WebPDecoderConfig config;</span><br><span class="line">    <span class="keyword">if</span> (!WebPInitDecoderConfig(&amp;config)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WebPGetFeatures(data<span class="variable">.bytes</span>, data<span class="variable">.length</span>, &amp;config<span class="variable">.input</span>) != VP8_STATUS_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    config<span class="variable">.output</span><span class="variable">.colorspace</span> = config<span class="variable">.input</span><span class="variable">.has_alpha</span> ? MODE_rgbA : MODE_RGB;</span><br><span class="line">    config<span class="variable">.options</span><span class="variable">.use_threads</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode the WebP image data into a RGBA value array.</span></span><br><span class="line">    <span class="keyword">if</span> (WebPDecode(data<span class="variable">.bytes</span>, data<span class="variable">.length</span>, &amp;config) != VP8_STATUS_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> width = config<span class="variable">.input</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="keyword">int</span> height = config<span class="variable">.input</span><span class="variable">.height</span>;</span><br><span class="line">    <span class="keyword">if</span> (config<span class="variable">.options</span><span class="variable">.use_scaling</span>) &#123;</span><br><span class="line">        width = config<span class="variable">.options</span><span class="variable">.scaled_width</span>;</span><br><span class="line">        height = config<span class="variable">.options</span><span class="variable">.scaled_height</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct a UIImage from the decoded RGBA value array.</span></span><br><span class="line">    <span class="built_in">CGDataProviderRef</span> provider =</span><br><span class="line">    <span class="built_in">CGDataProviderCreateWithData</span>(<span class="literal">NULL</span>, config<span class="variable">.output</span><span class="variable">.u</span><span class="variable">.RGBA</span><span class="variable">.rgba</span>, config<span class="variable">.output</span><span class="variable">.u</span><span class="variable">.RGBA</span><span class="variable">.size</span>, FreeImageData);</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGBitmapInfo</span> bitmapInfo = config<span class="variable">.input</span><span class="variable">.has_alpha</span> ? k<span class="built_in">CGBitmapByteOrder32Big</span> | k<span class="built_in">CGImageAlphaPremultipliedLast</span> : <span class="number">0</span>;</span><br><span class="line">    size_t components = config<span class="variable">.input</span><span class="variable">.has_alpha</span> ? <span class="number">4</span> : <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">CGColorRenderingIntent</span> renderingIntent = k<span class="built_in">CGRenderingIntentDefault</span>;</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGImageCreate</span>(width, height, <span class="number">8</span>, components * <span class="number">8</span>, components * width, colorSpaceRef, bitmapInfo, provider, <span class="literal">NULL</span>, <span class="literal">NO</span>, renderingIntent);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">    <span class="built_in">CGDataProviderRelease</span>(provider);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc] initWith<span class="built_in">CGImage</span>:imageRef];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(imageRef);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">###获取Image方向</span></span><br><span class="line">```objc</span><br><span class="line">+(<span class="built_in">UIImageOrientation</span>)imageOrientationFromImageData:(<span class="built_in">NSData</span> *)imageData &#123;</span><br><span class="line">    <span class="built_in">UIImageOrientation</span> result = <span class="built_in">UIImageOrientationUp</span>;</span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)imageData, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (imageSource) &#123;</span><br><span class="line">        <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">            <span class="built_in">CFTypeRef</span> val;</span><br><span class="line">            <span class="keyword">int</span> exifOrientation;</span><br><span class="line">            val = <span class="built_in">CFDictionaryGetValue</span>(properties, k<span class="built_in">CGImagePropertyOrientation</span>);</span><br><span class="line">            <span class="keyword">if</span> (val) &#123;</span><br><span class="line">                <span class="built_in">CFNumberGetValue</span>(val, k<span class="built_in">CFNumberIntType</span>, &amp;exifOrientation);</span><br><span class="line">                result = [<span class="keyword">self</span> exifOrientationToiOSOrientation:exifOrientation];</span><br><span class="line">            &#125; <span class="comment">// else - if it's not set it remains at up</span></span><br><span class="line">            <span class="built_in">CFRelease</span>((<span class="built_in">CFTypeRef</span>) properties);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//NSLog(@"NO PROPERTIES, FAIL");</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFRelease</span>(imageSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark EXIF orientation tag converter</span></span><br><span class="line"><span class="comment">// Convert an EXIF image orientation to an iOS one.</span></span><br><span class="line"><span class="comment">// reference see here: http://sylvana.net/jpegcrop/exif_orientation.html</span></span><br><span class="line">+ (<span class="built_in">UIImageOrientation</span>) exifOrientationToiOSOrientation:(<span class="keyword">int</span>)exifOrientation &#123;</span><br><span class="line">    <span class="built_in">UIImageOrientation</span> orientation = <span class="built_in">UIImageOrientationUp</span>;</span><br><span class="line">    <span class="keyword">switch</span> (exifOrientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            orientation = <span class="built_in">UIImageOrientationUp</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            orientation = <span class="built_in">UIImageOrientationDown</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            orientation = <span class="built_in">UIImageOrientationLeft</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            orientation = <span class="built_in">UIImageOrientationRight</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            orientation = <span class="built_in">UIImageOrientationUpMirrored</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            orientation = <span class="built_in">UIImageOrientationDownMirrored</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            orientation = <span class="built_in">UIImageOrientationLeftMirrored</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            orientation = <span class="built_in">UIImageOrientationRightMirrored</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orientation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">生成对应方向的图片:</span><br><span class="line"><span class="built_in">UIImage</span> image = [[<span class="built_in">UIImage</span> alloc] initWithData:data];</span><br><span class="line"><span class="built_in">UIImageOrientation</span> orientation = [<span class="keyword">self</span> imageOrientationFromImageData:data];</span><br><span class="line"><span class="keyword">if</span> (orientation != <span class="built_in">UIImageOrientationUp</span>) &#123;</span><br><span class="line">    image = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:image<span class="variable">.CGImage</span></span><br><span class="line">                     scale:image<span class="variable">.scale</span></span><br><span class="line">                     orientation:orientation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="对UIImage进行解码">对UIImage进行解码</h3><ul>
<li>为什么需要解码图片?<br>因为当显示或者绘制的时候,UIKit 只做了额外的延迟初始化和消耗很高解码。而下面的代码片段,从后台线程解压缩成合适的格式,从而让系统不必做额外的转换。然后在主线程上显示</li>
<li>如果UIImage是空 或者 UIImage有Alpha值则不解码<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)decodedImageWithImage:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="comment">// while downloading huge amount of images</span></span><br><span class="line">    <span class="comment">// autorelease the bitmap context</span></span><br><span class="line">    <span class="comment">// and all vars to help system to free memory</span></span><br><span class="line">    <span class="comment">// when there are memory warning.</span></span><br><span class="line">    <span class="comment">// on iOS7, do not forget to call</span></span><br><span class="line">    <span class="comment">// [[SDImageCache sharedImageCache] clearMemory];</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123; <span class="comment">// Prevent "CGBitmapContextCreateImage: invalid context 0x0" error</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">        <span class="comment">// do not decode animated images</span></span><br><span class="line">        <span class="keyword">if</span> (image<span class="variable">.images</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGImageRef</span> imageRef = image<span class="variable">.CGImage</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGImageAlphaInfo</span> alpha = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef);</span><br><span class="line">        <span class="built_in">BOOL</span> anyAlpha = (alpha == k<span class="built_in">CGImageAlphaFirst</span> ||</span><br><span class="line">                         alpha == k<span class="built_in">CGImageAlphaLast</span> ||</span><br><span class="line">                         alpha == k<span class="built_in">CGImageAlphaPremultipliedFirst</span> ||</span><br><span class="line">                         alpha == k<span class="built_in">CGImageAlphaPremultipliedLast</span>);</span><br><span class="line">        <span class="keyword">if</span> (anyAlpha) &#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// current</span></span><br><span class="line">        <span class="built_in">CGColorSpaceModel</span> imageColorSpaceModel = <span class="built_in">CGColorSpaceGetModel</span>(<span class="built_in">CGImageGetColorSpace</span>(imageRef));</span><br><span class="line">        <span class="built_in">CGColorSpaceRef</span> colorspaceRef = <span class="built_in">CGImageGetColorSpace</span>(imageRef);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">BOOL</span> unsupportedColorSpace = (imageColorSpaceModel == k<span class="built_in">CGColorSpaceModelUnknown</span> ||</span><br><span class="line">                                      imageColorSpaceModel == k<span class="built_in">CGColorSpaceModelMonochrome</span> ||</span><br><span class="line">                                      imageColorSpaceModel == k<span class="built_in">CGColorSpaceModelCMYK</span> ||</span><br><span class="line">                                      imageColorSpaceModel == k<span class="built_in">CGColorSpaceModelIndexed</span>);</span><br><span class="line">        <span class="keyword">if</span> (unsupportedColorSpace) &#123;</span><br><span class="line">            colorspaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">        size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">        <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">NSUInteger</span> bytesPerRow = bytesPerPixel * width;</span><br><span class="line">        <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// kCGImageAlphaNone is not supported in CGBitmapContextCreate.</span></span><br><span class="line">        <span class="comment">// Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast</span></span><br><span class="line">        <span class="comment">// to create bitmap graphics contexts without alpha info.</span></span><br><span class="line">        <span class="comment">// 如果是加载高分辨率图片的话,有可能造成上G的内存消耗</span></span><br><span class="line">        <span class="comment">// 解压缩操作中,每一个像素点都会分配一个空间来存储相关值,那么分辨率越高的图片,就意味着更多数量的像素点,也就意味着需要分配更多的空间！所以对于高分辨率图来说,解压缩操作的确会造成内存飙升,即使是几M的图片,解压缩过程中也是有可能消耗上G的内存！</span></span><br><span class="line">        <span class="comment">// 解决办法 [[SDImageCache sharedImageCache] setShouldDecompressImages:NO];</span></span><br><span class="line">				  [[SDWebImageDownloader sharedDownloader] setShouldDecompressImages:<span class="literal">NO</span>];</span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">                                                     width,</span><br><span class="line">                                                     height,</span><br><span class="line">                                                     bitsPerComponent,</span><br><span class="line">                                                     bytesPerRow,</span><br><span class="line">                                                     colorspaceRef,</span><br><span class="line">                                                     k<span class="built_in">CGBitmapByteOrderDefault</span>|k<span class="built_in">CGImageAlphaNoneSkipLast</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Draw the image into the context and retrieve the new bitmap image without alpha</span></span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">        <span class="built_in">CGImageRef</span> imageRefWithoutAlpha = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">UIImage</span> *imageWithoutAlpha = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:imageRefWithoutAlpha</span><br><span class="line">                                                         scale:image<span class="variable">.scale</span></span><br><span class="line">                                                   orientation:image<span class="variable">.imageOrientation</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (unsupportedColorSpace) &#123;</span><br><span class="line">            <span class="built_in">CGColorSpaceRelease</span>(colorspaceRef);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">        <span class="built_in">CGImageRelease</span>(imageRefWithoutAlpha);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> imageWithoutAlpha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="下载图片-NSOperation">下载图片-NSOperation</h3><h4 id="第一种方式:">第一种方式:</h4><ul>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>NSOperation对象的start方法</li>
<li>这里要注意:默认情况下,调用了start方法后并不会开一条新线程去执行操作,而是在当前线程同步执行操作.只有将operation放到一个NSOperationQueue中,才会异步执行操作.<h4 id="第二种方式:">第二种方式:</h4></li>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperation中封装的操作放到一条新线程中执行<br>在此过程中,我们根本不用考虑线程的生命周期、同步、加锁等问题</li>
</ul>
<h5 id="相关属性:">相关属性:</h5><ul>
<li><code>@property (readonly, getter=isReady) BOOL ready;</code> //operation是否现在可以执行了</li>
<li><code>@property (readonly, getter=isExecuting) BOOL executing;</code> //operation是否正在执行</li>
<li><code>@property (readonly, getter=isFinished) BOOL finished;</code> //operation执行是否结束了</li>
<li><code>@property (readonly, getter=isCancelled) BOOL cancelled;</code> //operation是否被取消了</li>
<li><code>@property (readonly, getter=isConcurrent) BOOL concurrent;</code> //operation是否是异步执行</li>
<li><code>@property NSOperationQueuePriority queuePriority;</code></li>
<li><code>@property (nullable, copy) void (^completionBlock)(void);</code> //operation主任务执行结束之后会执行这个block</li>
</ul>
<h5 id="相关方法:">相关方法:</h5><ul>
<li><code>- (void)start;</code> //开始执行operation 自定义NSOperation 可以重写这个方法将要执行的任务封装在这个方法内部去执行.</li>
<li><code>- (void)main;</code> //自定义NSOperation 可以重写这个方法将要执行的任务封装在这个方法内部去执行.注意:子类重新该方法时需要调用super方法,这个方法会在NSOperation提供的自动释放池中执行所以在重写该方法时你不需要自己创建自动释放池,如果你需要异步执行operation时你不需要重新该方法而应该重写start方法 </li>
<li><code>- (void)cancel;</code> //取消operation</li>
<li><code>- (void)addDependency:(NSOperation *)op;</code> //添加依赖的operation</li>
<li><code>- (void)removeDependency:(NSOperation *)op;</code> //移除依赖的operation</li>
</ul>
<h5 id="默认情况下,NSOperation并不具备封装操作的能力,必须使用它的子类NSBlockOperation和NSInvocationOperation">默认情况下,NSOperation并不具备封装操作的能力,必须使用它的子类NSBlockOperation和NSInvocationOperation</h5><h6 id="NSBlockOperation的相关属性和方法:">NSBlockOperation的相关属性和方法:</h6><ul>
<li><code>+ (instancetype)blockOperationWithBlock:(void (^)(void))block;</code></li>
<li><code>- (void)addExecutionBlock:(void (^)(void))block;</code></li>
<li><code>@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks;</code></li>
<li>注意:调用start方法执行的时候是在当前线程同步执行操作,只有将operation放到一个NSOperationQueue中,才会异步执行操作。</li>
</ul>
<h6 id="NSInvocationOperation的相关属性和方法:">NSInvocationOperation的相关属性和方法:</h6><ul>
<li><code>- (nullable instancetype)initWithTarget:(id)target selector:(SEL)sel object:(nullable id)arg;</code></li>
<li><code>- (instancetype)initWithInvocation:(NSInvocation *)inv;</code></li>
<li><code>@property (readonly, retain) NSInvocation *invocation;</code></li>
<li><code>@property (nullable, readonly, retain) id result;</code></li>
<li>注意:调用start方法执行的时候是在当前线程同步执行操作,只有将operation放到一个NSOperationQueue中,才会异步执行操作。</li>
</ul>
<h5 id="NSOperationQueue">NSOperationQueue</h5><ul>
<li>创建任务队列<br><code>+ (nullable NSOperationQueue *)currentQueue;</code><br><code>+ (NSOperationQueue *)mainQueue;</code></li>
<li>将operation添加到任务队列中异步执行<br><code>- (void)addOperation:(NSOperation *)op;</code><br><code>- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait;</code><br><code>- (void)addOperationWithBlock:(void (^)(void))block;</code></li>
<li>取消所有任务<br><code>- (void)cancelAllOperations;</code></li>
<li>相关属性<br><code>@property (nullable, copy) NSString *name;</code> //队列名称<br><code>@property (getter=isSuspended) BOOL suspended;</code> //队列是否挂起了<br><code>@property NSInteger maxConcurrentOperationCount;</code> //任务最大并发数量<br><code>@property (readonly) NSUInteger operationCount;</code> //当前任务总数<br><code>@property (readonly, copy) NSArray&lt;__kindof NSOperation *&gt; *operations;</code> //所有任务</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="计算缓存图片大小">计算缓存图片大小</h3><ul>
<li><code>image.size.height * image.size.width * image.scale * image.scale</code></li>
</ul>
<h3 id="检查缓存文件是否是PNG图片">检查缓存文件是否是PNG图片</h3><ul>
<li>PNG图片前8位是137, 80, 78, 71, 13, 10, 26, 10 对应十六进制为0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)imageDataHasPNGPreffix:(<span class="built_in">NSData</span> *)data&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> kPNGSignatureBytes[<span class="number">8</span>] = &#123;<span class="number">0x89</span>, <span class="number">0x50</span>, <span class="number">0x4E</span>, <span class="number">0x47</span>, <span class="number">0x0D</span>, <span class="number">0x0A</span>, <span class="number">0x1A</span>, <span class="number">0x0A</span>&#125;;</span><br><span class="line">	<span class="built_in">NSData</span> *kPNGSignatureData = [<span class="built_in">NSData</span> dataWithBytes:kPNGSignatureBytes length:<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> pngSignatureLength = [kPNGSignatureData length];</span><br><span class="line">    <span class="keyword">if</span> ([data length] &gt;= pngSignatureLength) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[data subdataWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, pngSignatureLength)] isEqualToData:kPNGSignatureData]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 框架知识点]]></title>
    <link href="http://yoursite.com/2016/07/21/AFNetworking%20%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2016/07/21/AFNetworking 框架知识点/</id>
    <published>2016-07-21T01:16:36.000Z</published>
    <updated>2016-10-14T12:27:24.000Z</updated>
    <content type="html"><![CDATA[<h3 id="iOS进度指示器——NSProgress">iOS进度指示器——NSProgress</h3><hr>
<ul>
<li><p><code>+ (nullable NSProgress *)currentProgress;</code> 获取当前线程的进度管理对象根节点,注意:当有NSProgress对象调用了becomeCurrentWithPendingUnitCount:方法后,这个方法才能获取到</p>
</li>
<li><p><code>+ (NSProgress *)progressWithTotalUnitCount:(int64_t)unitCount</code> 创建一个NSProgress对象,需要传入进度的单元数量</p>
</li>
<li><p><code>+ (NSProgress *)discreteProgressWithTotalUnitCount:(int64_t)unitCount</code> 和上一个方法功能相似 iOS9之后的新方法</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p><code>+ (NSProgress *)progressWithTotalUnitCount:(int64_t)unitCount parent:(NSProgress *)parent pendingUnitCount:(int64_t)portionOfParentTotalUnitCount;</code> iOS9之后的新方法 创建某个进度指示器节点的子节点</p>
</li>
<li><p><code>- (instancetype)initWithParent:(nullable NSProgress *)parentProgressOrNil userInfo:(nullable NSDictionary *)userInfoOrNil;</code> NSProgress实例的初始化方法 自父节点参数可以为nil</p>
</li>
<li><p><code>- (void)becomeCurrentWithPendingUnitCount:(int64_t)unitCount</code> 注册为当前线程根节点</p>
</li>
<li><p><code>- (void)resignCurrent</code> 取消注册 与注册方法必须同步出现</p>
</li>
<li><p><code>- (void)addChild:(NSProgress *)child withPendingUnitCount:(int64_t)inUnitCount</code> iOS9新方法 向一个节点中添加一个子节点</p>
</li>
<li><p><code>@property int64_t totalUnitCount</code> 进度单元总数</p>
</li>
<li><p><code>@property int64_t completedUnitCount</code> 已完成的进度单元数</p>
</li>
<li><p><code>@property (readonly) double fractionCompleted</code> 为0-1之间的浮点值,为任务的完成比例 <code>[progress addObserver:self forKeyPath:@&quot;fractionCompleted&quot; options:NSKeyValueObservingOptionNew context:nil];</code></p>
</li>
<li><p><code>@property (null_resettable, copy) NSString *localizedDescription</code> 显示完后比例 如:10% completed</p>
</li>
<li><p><code>@property (null_resettable, copy) NSString *localizedAdditionalDescription</code> 完成数量 如:1 of 10</p>
</li>
<li><p><code>@property (getter=isCancellable) BOOL cancellable</code> 是否可取消</p>
</li>
<li><p><code>@property (getter=isPausable) BOOL pausable</code> 是否可暂停</p>
</li>
<li><p><code>- (void)cancel</code> 取消</p>
</li>
<li><p><code>- (void)pause</code> 暂停</p>
</li>
<li><p><code>- (void)resume</code> 恢复</p>
</li>
</ul>
<h3 id="关于NSProgress对象的用户配置字典">关于NSProgress对象的用户配置字典</h3><hr>
<ul>
<li><p><code>[progress setUserInfoObject:@10 forKey:NSProgressEstimatedTimeRemainingKey];</code> 设置剩余时间 会影响localizedAdditionalDescription的值 例如:0 of 10 — About 10 seconds remaining</p>
</li>
<li><p><code>[progress setUserInfoObject:@15 forKey:NSProgressThroughputKey];</code> 设置完成速度信息 会影响localizedAdditionalDescription的值 例如:Zero KB of 10 bytes (15 bytes/sec)</p>
</li>
<li><p>NSProgressFileOperationKindKey键对应的是提示文字类型 会影响localizedDescription的值<br>下面这些键值的生效 必须将NSProgress对象的kind属性设置为 NSProgressKindFile<br>NSProgressFileOperationKindKey可选的对应值如下:<br>NSProgressFileOperationKindDownloading: 显示Downloading files…<br>NSProgressFileOperationKindDecompressingAfterDownloading： 显示Decompressing files…<br>NSProgressFileOperationKindReceiving: 显示Receiving files…<br>NSProgressFileOperationKindCopying: 显示Copying files…<br><code>[progress setUserInfoObject:NSProgressFileOperationKindDownloading forKey:NSProgressFileOperationKindKey];</code></p>
</li>
<li><p><code>NSString *const NSProgressFileTotalCountKey</code> 键设置显示的文件总数 例如: Copying 100 files… <code>[progress setUserInfoObject:@100 forKey:NSProgressFileTotalCountKey];</code></p>
</li>
<li><p><code>NSString *const NSProgressFileCompletedCountKey</code> 键设置显示的文件已完成的数量 <code>[progress setUserInfoObject:@1 forKey:NSProgressFileCompletedCountKey];</code></p>
</li>
</ul>
<blockquote>
<p><a href="http://my.oschina.net/u/2340880/blog/679367" target="_blank" rel="external">备注来源</a></p>
</blockquote>
<h3 id="NSSortDescriptor排序">NSSortDescriptor排序</h3><p>NSSortDescriptor可以实现按照对象的属性进行排序。比如我们有一个对象（People）。People有两个属性分别是名字（name）和年龄（age）。现在我们要按照People的年龄（age）来进行排序。<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按年龄排序</span></span><br><span class="line"><span class="comment">//这样是按照年龄的降序进行排序。如果想升序的话将NO改为YES即可</span></span><br><span class="line"><span class="built_in">NSSortDescriptor</span> *sortDescriptor = [[<span class="built_in">NSSortDescriptor</span> alloc] initWithKey:<span class="string">@"_age"</span> ascending:<span class="literal">NO</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *sortDescriptors = [<span class="built_in">NSArray</span> arrayWithObjects:sortDescriptor, <span class="literal">nil</span>];</span><br><span class="line">[arrayPeople sortUsingDescriptors:sortDescriptors];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按姓名排序</span></span><br><span class="line"><span class="built_in">NSSortDescriptor</span> *sortDescriptorName = [[<span class="built_in">NSSortDescriptor</span> alloc] initWithKey:<span class="string">@"_name"</span> ascending:<span class="literal">NO</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *sortDescriptors = [<span class="built_in">NSArray</span> arrayWithObjects:sortDescriptorName, <span class="literal">nil</span>];</span><br><span class="line">[arrayPeople sortUsingDescriptors:sortDescriptors];</span><br><span class="line"></span><br><span class="line"><span class="comment">//按年龄和名字排序</span></span><br><span class="line"><span class="built_in">NSSortDescriptor</span> *sortDescriptor = [[<span class="built_in">NSSortDescriptor</span> alloc] initWithKey:<span class="string">@"_age"</span> ascending:<span class="literal">NO</span>];</span><br><span class="line"><span class="built_in">NSSortDescriptor</span> *sortDescriptorName = [[<span class="built_in">NSSortDescriptor</span> alloc] initWithKey:<span class="string">@"_name"</span> ascending:<span class="literal">NO</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *sortDescriptors = [<span class="built_in">NSArray</span> arrayWithObjects:sortDescriptor, sortDescriptorName, <span class="literal">nil</span>];</span><br><span class="line">[_mutArrVideo sortUsingDescriptors:sortDescriptors];</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="iOS进度指示器——NSProgress">iOS进度指示器——NSProgress</h3><hr>
<ul>
<li><p><code>+ (nullable NSProgress *)currentProgress;</code> 获取当前线程的进度管理对象根节点,注意:当有NSProgress对象调用了becomeCurrentWithPendingUnitCount:方法后,这个方法才能获取到</p>
</li>
<li><p><code>+ (NSProgress *)progressWithTotalUnitCount:(int64_t)unitCount</code> 创建一个NSProgress对象,需要传入进度的单元数量</p>
</li>
<li><p><code>+ (NSProgress *)discreteProgressWithTotalUnitCount:(int64_t)unitCount</code> 和上一个方法功能相似 iOS9之后的新方法</p>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift]]></title>
    <link href="http://yoursite.com/2016/05/01/swift_note/"/>
    <id>http://yoursite.com/2016/05/01/swift_note/</id>
    <published>2016-05-01T14:28:11.000Z</published>
    <updated>2016-05-21T03:01:46.000Z</updated>
    <content type="html"><![CDATA[<h3 id="常量&amp;变量">常量&amp;变量</h3><ul>
<li>let 定义常量,设置之后不可以修改</li>
<li>var 定义变量,设置之后可以修改</li>
<li>语句末尾不用使用 ;</li>
<li>在Swift中使用print() 替代OC中的NSLog</li>
<li>print 的性能更好</li>
</ul>
<a id="more"></a>
<h3 id="类型转换">类型转换</h3><ul>
<li>Swift中不存在隐式类型转换,所有的类型转换都必须是显示的<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">9.9</span></span><br><span class="line"><span class="keyword">let</span> iSum = num1 + <span class="type">Int</span>(num2)</span><br><span class="line"><span class="keyword">let</span> dSum = <span class="type">Double</span>(num1) + num2</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num3: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> num4: <span class="type">Int</span> = <span class="type">Int</span>(<span class="number">10.1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="分支">分支</h3><h4 id="switch">switch</h4><ul>
<li>Swift中的if可以省略()</li>
<li>Swift中哪怕if后面只有一条语句,也不能省略{}</li>
<li>Swift中条件只能放bool值,取值只有两个ture/false</li>
<li>Swift中的switch<ul>
<li>后面的()可以省略</li>
<li>OC中的switch如果没有break会穿透,但是Swift不会穿透</li>
<li>OC中如果要在case中定义变量,必须加上{}确定作用域,而Swift中不用</li>
<li>OC中default的位置可以随便写,只有所有case都不满足才会执行default而Swift中的default只能放在最后</li>
<li>OC中的default可以省略,Swift中”大部分”情况下不能省略</li>
</ul>
</li>
</ul>
<h4 id="for和while循环">for和while循环</h4><ul>
<li>普通for循环和OC中基本一致</li>
<li><p>0..&lt;10 代表一个区间范围 从0开始到9,包含头不包含尾</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;<span class="number">10</span></span><br><span class="line">&#123;</span><br><span class="line">	print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>_</code>代表忽略,如果不关心某个参数,就可以使用<code>_</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0.</span>.&lt;<span class="number">10</span></span><br><span class="line">&#123;</span><br><span class="line">	print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>0…10代表一个区间范围 从0开始到10,包含头又包含尾</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>..<span class="number">10</span></span><br><span class="line">&#123;</span><br><span class="line">	print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Swift中的while循环和OC差不多,而且在开发中很少使用while</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var a = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">10</span></span><br><span class="line">&#123;</span><br><span class="line">	print(a)</span><br><span class="line">	a++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Swift升级到2.0之后,do while循环发生了很大的变化 do while 没有do了,因为do被用作捕获异常了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var b = <span class="number">0</span></span><br><span class="line">repeat&#123;</span><br><span class="line">	print(b)</span><br><span class="line">	b++</span><br><span class="line">&#125;<span class="keyword">while</span> b&lt;<span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="三目运算符和可选类型">三目运算符和可选类型</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let res = (num ==<span class="number">5</span>) ? <span class="number">5</span> : <span class="number">10</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<ul>
<li>可选类型:代表着可以有也可以没有 Optional ? 以后但凡看到一个方法或者数据类型后面有?,就代表返回的是一个可选类型</li>
<li>使用可选类型需要注意,如果直接打印可选类型,那么打印出来的值会被Optional包裹</li>
<li>!代表告诉编译器,可选类型中一定有值,强制解析。如果可选类型中没有值,而又进行了强制解析,那么程序就会崩溃<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let url = <span class="built_in">NSURL</span>(string: <span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">print(url)</span><br><span class="line">print(url!)</span><br><span class="line"></span><br><span class="line">let request = <span class="built_in">NSURLRequest</span>(URL: url!)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> url != <span class="literal">nil</span></span><br><span class="line">&#123;</span><br><span class="line">	let request = <span class="built_in">NSURLRequest</span>(URL: url!)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选绑定</span></span><br><span class="line"><span class="comment">// 会将url中的值取出来赋值给urlFinal变量,如果值不为nil,那么久可以进入&#123;&#125;</span></span><br><span class="line"><span class="keyword">if</span> let urlFinal = url&#123;</span><br><span class="line">	let request = <span class="built_in">NSURLRequest</span>(URL: urlFinal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组">数组</h3><ul>
<li>和OC数组的区别就是去掉前面的@符号<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = @[<span class="string">@""</span>,<span class="string">@""</span>];</span><br><span class="line">let arr = []</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="字典">字典</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字典</span></span><br><span class="line">var dict = [<span class="string">"name"</span>:<span class="string">"xxx"</span>,<span class="string">"age"</span>:<span class="number">30</span>]</span><br><span class="line"><span class="comment">// 获取value</span></span><br><span class="line">dict[<span class="string">"name"</span>]</span><br><span class="line"><span class="comment">// 遍历字典</span></span><br><span class="line"><span class="keyword">for</span> (k,v) <span class="keyword">in</span> dict</span><br><span class="line">&#123;</span><br><span class="line">	print(k)</span><br><span class="line">	print(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增key / value</span></span><br><span class="line">dict[<span class="string">"gender"</span>] = <span class="string">"man"</span></span><br><span class="line"><span class="comment">// 更新key / value</span></span><br><span class="line">dict[<span class="string">"name"</span>] = <span class="string">"yyy"</span></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">dict<span class="variable">.removeValueForKey</span>(<span class="string">"name"</span>)</span><br><span class="line"><span class="comment">// 合并字典</span></span><br><span class="line">var dict2 = [<span class="string">"score"</span>:<span class="number">99</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key,value) <span class="keyword">in</span> dict2</span><br><span class="line">&#123;</span><br><span class="line">	dict[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串">字符串</h3><ul>
<li>在OC中定义字符串用@””. Swift中用””</li>
<li>OC中的字符串是NSString,Swift中的字符串是String</li>
<li>OC中的字符串是一个对象,继承于NSObject。Swift中的字符串是一个结构体,性能比OC中的高<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var str: String = <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接</span></span><br><span class="line">var str2 = <span class="string">"yyy"</span></span><br><span class="line"></span><br><span class="line">str += str2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化</span></span><br><span class="line">let num = <span class="number">30</span></span><br><span class="line">let name = <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Swift中可以使用\()来拼接其它值</span></span><br><span class="line">var str3 = <span class="string">"name = \(name), age = \(num)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 09:08:13</span></span><br><span class="line"><span class="comment">// 注意: 所有的值都必须放到数组中,哪怕只有一个值也需要放到数组中</span></span><br><span class="line">var str4 = String(format: <span class="string">"%02d: %02d: %02d"</span>, arguments: [<span class="number">9</span>, <span class="number">8</span>, <span class="number">13</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取</span></span><br><span class="line"><span class="comment">// 注意:在Swift中,如果需要截取字符串,建议使用OC的字符串来截取.</span></span><br><span class="line"><span class="comment">// 将Swift中的字符串转换为OC的字符串</span></span><br><span class="line">var str5: <span class="built_in">NSString</span> = <span class="string">"xxxxxxx"</span></span><br><span class="line">var str6 = <span class="string">"xxxxxxx"</span> as <span class="built_in">NSString</span></span><br><span class="line"></span><br><span class="line">var subStr = str5<span class="variable">.substringWithRange</span>(<span class="built_in">NSMakeRange</span>(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift中的字符串是支持直接遍历的</span></span><br><span class="line">var str7 = <span class="string">"xxxxxx"</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> st7<span class="variable">.characters</span></span><br><span class="line">&#123;</span><br><span class="line">	print(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="函数">函数</h3><ul>
<li>Swift定义函数的格式:<br>语义: 将前面计算的结果返回给 -&gt; 返回值<br>func 函数名称(参数列表) -&gt; 返回值<br>{<br>  执行代码<br>}<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有返回值没有参数</span></span><br><span class="line"><span class="comment">// 如果函数没有返回值,就写Void</span></span><br><span class="line"><span class="comment">// 如果函数没有返回值还可以简写</span></span><br><span class="line"><span class="comment">// 1. ()替代Void</span></span><br><span class="line"><span class="comment">// 2. 可以省略 -&gt; ()  -&gt;Void</span></span><br><span class="line">func say() -&gt; Void</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line">say()</span><br><span class="line">func say2() -&gt; ()</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line">say2()</span><br><span class="line">func say3()</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line">say3()</span><br><span class="line"><span class="comment">// 有返回值没有参数</span></span><br><span class="line">func getNumber() -&gt; Int</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">998</span></span><br><span class="line">&#125;</span><br><span class="line">print(getNumber())</span><br><span class="line"><span class="comment">// 有参数没有返回值</span></span><br><span class="line"><span class="comment">// Swift2.0中,会自动将形参列表中的第二个参数开始的参数名称作为便签,以便于提高阅读性</span></span><br><span class="line">func sum(a: Int, b: Int)</span><br><span class="line">&#123;</span><br><span class="line">	print(a + b)</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">10</span>, b: <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加标签,添加外部参数</span></span><br><span class="line"><span class="comment">// x/y称之为外部参数, a/b称之为内部参数</span></span><br><span class="line">func sum2(x a: Int, y b: Int)</span><br><span class="line">&#123;</span><br><span class="line">	print(a + b)</span><br><span class="line">&#125;</span><br><span class="line">sum2(x: <span class="number">10</span> y: <span class="number">20</span>)</span><br><span class="line"><span class="comment">// 有参数有返回值</span></span><br><span class="line">func sum3(a: Int, b: Int) -&gt;Int</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(sum3(<span class="number">10</span>, b:<span class="number">20</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="闭包">闭包</h3><ul>
<li>闭包和OC中的Block非常相似</li>
<li>OC中的Block类似于匿名函数</li>
<li>闭包是用来定义函数的</li>
<li>作用: Blcok是用于保存一段代码,在需要的时候执行.闭包也是用于保存一段代码,在需要的时候执行</li>
<li>Block 格式: 返回值类型(^block名称)(参数列表)</li>
<li>闭包的基本格式:<br>in 的格式是用于区分形参返回值和执行代码<br>{<br>  (形参列表) -&gt; (返回值)<br>  in<br>  需要执行的代码<br>}</li>
<li><p>闭包的几种格式</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.将闭包通过实参传递给函数</span></span><br><span class="line"><span class="comment">// 2.如果闭包是函数的最后一个参数,那么闭包可以写在函数()的后面</span></span><br><span class="line"><span class="comment">// 3.如果函数只接收一个参数,并且这个参数是闭包,那么()可以省略</span></span><br><span class="line">say(&#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">	print(<span class="string">"xxx"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义闭包</span></span><br><span class="line">func loadData(num: Int, finished: ()-&gt;())</span><br><span class="line">&#123;</span><br><span class="line">	finished()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下3个为调用loadData函数</span></span><br><span class="line">loadData(<span class="number">10</span>, finished:&#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">	print(<span class="string">"xxx"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loadData(<span class="number">10</span>)&#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">	print(<span class="string">"xxx"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包的简写:如果闭包没有参数也没有返回值,那么in之前的东西都可以删除,包括in</span></span><br><span class="line">loadData(<span class="number">10</span>)&#123;</span><br><span class="line">	print(<span class="string">"xxx"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数接收一个参数,这个参数是一个闭包,闭包没有参数和返回值</span></span><br><span class="line">func say(finished: ()-&gt;())</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">"执行耗时操作"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包的返回值和参数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">override func viewDidLoad()&#123;</span><br><span class="line">	let sc = createScrollview (&#123; () -&gt; Int <span class="keyword">in</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">	&#125;) &#123; (index) -&gt; <span class="built_in">UIView</span> <span class="keyword">in</span></span><br><span class="line">		let width = <span class="number">80</span></span><br><span class="line">		let btn = <span class="built_in">UIButton</span>()</span><br><span class="line">		<span class="comment">// 3.设置UIButton的属性</span></span><br><span class="line">		btn<span class="variable">.backgroundColor</span> = <span class="built_in">UIColor</span><span class="variable">.greenColor</span>()</span><br><span class="line">		btn<span class="variable">.setTitle</span>(<span class="string">"标题\(index)"</span>, forState: <span class="built_in">UIControlState</span><span class="variable">.Normal</span>)</span><br><span class="line">		btn<span class="variable">.frame</span> = <span class="built_in">CGRect</span>(x: index * width, y: <span class="number">0</span>, width: width, height: <span class="number">44</span>)</span><br><span class="line">		<span class="comment">// 4.返回创建好的控件</span></span><br><span class="line">		<span class="keyword">return</span> btn</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 5. 将UIScrollview添加到控制器view上</span></span><br><span class="line">	view<span class="variable">.addSubview</span>(sc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要求:定义一个方法来创建UIScrollView</span></span><br><span class="line"><span class="comment">// 1.并且UIScrollView上有多少个按钮必须通过闭包告诉该方法</span></span><br><span class="line"><span class="comment">// 2.并且如何创建按钮也需要通过闭包来创建</span></span><br><span class="line">func createScrollview(btnCount: ()-&gt; Int, btnWithIndex: (index:Int)-&gt;<span class="built_in">UIView</span>) -&gt; <span class="built_in">UIScrollView</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Swift推荐:能不写self就不写self</span></span><br><span class="line">	<span class="comment">// 1.创建UIScrollView</span></span><br><span class="line">	let sc = <span class="built_in">UIScrollView</span>(frame: <span class="built_in">CGRect</span>(x:<span class="number">0</span>, y:<span class="number">100</span>, width:<span class="number">375</span>, height:<span class="number">44</span>))</span><br><span class="line">	sc<span class="variable">.backgroundColor</span> = <span class="built_in">UIColor</span><span class="variable">.redColor</span>()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//let width = 80</span></span><br><span class="line">	let count = btnCount()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.创建N多个UIButton</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;count</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		let btn = UIButton()</span><br><span class="line">		// 3.设置UIButton的属性</span><br><span class="line">		btn.backgroundColor = UIColor.greenColor()</span><br><span class="line">		btn.setTitle("标题\(i)", forState: UIControlState.Normal)</span><br><span class="line">		btn.frame = CGRect(x: i * width, y: 0, width: width, height: 44)</span><br><span class="line">		// 4.将UIButton添加到UIScrollView上</span><br><span class="line">		sc.addSubview(btn)</span><br><span class="line">		*/</span></span><br><span class="line">		let subView = btnWithIndex(index:i)</span><br><span class="line">		sc<span class="variable">.addSubview</span>(subView)</span><br><span class="line">	&#125;</span><br><span class="line">	sc<span class="variable">.contentSize</span> = <span class="built_in">CGSize</span>(width: <span class="built_in">CGFloat</span>(count) * subView<span class="variable">.bounds</span><span class="variable">.width</span>, height: <span class="number">44</span>)</span><br><span class="line">	<span class="keyword">return</span> sc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包的循环引用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Swift中,如果在某个类中定义一个属性,那么这个属性必须要初始化,否则就会出错</span></span><br><span class="line"><span class="comment">// 如果此时不想初始化,那么可以在后面写一个?号</span></span><br><span class="line"><span class="comment">// 注意: 这个是错误的写法,当前写法代表闭包的返回值可以是nil</span></span><br><span class="line"><span class="comment">// var finished: ()-&gt;()?</span></span><br><span class="line">var finished: (()-&gt;())?</span><br><span class="line"></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">	<span class="keyword">super</span><span class="variable">.viewDidLoad</span>()</span><br><span class="line">	<span class="comment">// OC中的解决方案</span></span><br><span class="line">	<span class="comment">// __weak typeof(self) weakSelf = self</span></span><br><span class="line">	<span class="keyword">weak</span> var weakSelf = <span class="keyword">self</span></span><br><span class="line">	loadData &#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">		print(<span class="string">"回到主线程更新UI"</span>)</span><br><span class="line">		<span class="comment">// 在Swift开发中,能不写self就不写self,但是在闭包中必须写上self</span></span><br><span class="line">		<span class="comment">// 所以以后看到self基本上都和闭包有关系</span></span><br><span class="line">		weakSelf!<span class="variable">.view</span><span class="variable">.backgroundColor</span> = <span class="built_in">UIColor</span><span class="variable">.redColor</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func loadData(finished: ()-&gt;())</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">"执行耗时操作"</span>)</span><br><span class="line">	<span class="keyword">self</span><span class="variable">.finished</span> = finished</span><br><span class="line">	finished()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数,相当于OC中的dealloc</span></span><br><span class="line">deinit</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">"xxx"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="懒加载">懒加载</h3><ul>
<li>格式:定义变量时前面使用lazy来修饰变量,后面通过等到赋值一个闭包. 注意点: 1.必须使用var 2.闭包后面必须跟上()<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">lazy var dataList:[String] = &#123;</span><br><span class="line">	()-&gt;[String]</span><br><span class="line">	<span class="keyword">in</span></span><br><span class="line">	<span class="keyword">return</span> [<span class="string">"xxx"</span>, <span class="string">"x"</span>]</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果闭包是用于懒加载,那么in之前的代码都可以删除包括in在内</span></span><br><span class="line">lazy var dataList2:[String] = &#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="string">"xxx"</span>, <span class="string">"x"</span>]</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">let demoFunc = &#123;</span><br><span class="line">	()-&gt;[String]</span><br><span class="line">	<span class="keyword">in</span></span><br><span class="line">	<span class="keyword">return</span> [<span class="string">"xxx"</span>, <span class="string">"x"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy var dataList3:[String] = <span class="keyword">self</span><span class="variable">.demoFunc</span>()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="getter&amp;setter">getter&amp;setter</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">class Person: <span class="built_in">NSObject</span>&#123;</span><br><span class="line">	</span><br><span class="line">	var _name:String?</span><br><span class="line">	var name:String?&#123;</span><br><span class="line">		get&#123;</span><br><span class="line">			<span class="keyword">return</span> _name</span><br><span class="line">		&#125;</span><br><span class="line">		set&#123;</span><br><span class="line">			<span class="comment">// 只要外界通过对象.name给name赋值,那么值就会保存在newValue</span></span><br><span class="line">			_name = newValue</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var gender:String?&#123;</span><br><span class="line">		<span class="comment">//设置完值之后调用</span></span><br><span class="line">		<span class="comment">//Swift中使用didSet来替代OC中重写setter方法</span></span><br><span class="line">		didSet&#123;</span><br><span class="line">			print(gender)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果只重写了get方法,那么这个属性我们称之为 计算型 属性</span></span><br><span class="line">	<span class="comment">// 也就是对应OC中的只读属性</span></span><br><span class="line">	<span class="comment">// 注意点: 计算型属性是不占用内存空间的</span></span><br><span class="line">	var age:Int&#123;</span><br><span class="line">		get&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">30</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Swift中,如果想使用某一个类,是不用import头文件的</span></span><br><span class="line"><span class="comment">//因为Swift中新增了一个OC中以前没有的概念"命名空间"</span></span><br><span class="line"><span class="comment">//只要是在同一个命名空间中的资源都是共享的</span></span><br><span class="line"><span class="comment">//默认情况下,项目名称就是命名空间</span></span><br></pre></td></tr></table></figure>
<h3 id="构造方法">构造方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">class Person: <span class="built_in">NSObject</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果定义属性的时候没有初始化,那么必须在后面写上一个?</span></span><br><span class="line">	<span class="comment">// Swift要求,属性是必须有初始值的</span></span><br><span class="line">	<span class="comment">// 只要在构造方法中对属性进行了初始化,那么就不用写?</span></span><br><span class="line">	var name:String?</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 如果是定义一个 "对象属性" 那么后面可以写上?</span><br><span class="line">	 * 如果是定义一个 "基本数据类型属性", 那么建议直接赋值为0</span><br><span class="line">	 * 因为super.init()方法在分配存储空间的时候,如果发现属性是一个对象,并且是一个可选类型,那么会给这个属性分配存储空间</span><br><span class="line">	 * 但是如果属性是一个基本数据类型,并且是可选类型,那么super.init()不会给该属性分配存储空间</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="comment">//var age:Int?</span></span><br><span class="line">	var age:Int = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意:如果自定义构造方法,并且没有重写父类默认的构造方法那么默认的构造方法就会失效</span></span><br><span class="line">	override init()&#123;</span><br><span class="line">		<span class="keyword">self</span><span class="variable">.name</span> = <span class="string">"xxx"</span></span><br><span class="line">		<span class="keyword">self</span><span class="variable">.age</span> = <span class="number">30</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自定义构造方法</span></span><br><span class="line">	<span class="comment">//Swift中有方法重载的概念</span></span><br><span class="line">	<span class="comment">//允许有同名的方法,只要形参或返回值不一样即可</span></span><br><span class="line">	init(name:String age:Int)&#123;</span><br><span class="line">		<span class="keyword">self</span><span class="variable">.name</span> = name</span><br><span class="line">		<span class="keyword">self</span><span class="variable">.age</span> = age</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	init(dict:[String: Object])&#123;</span><br><span class="line">		<span class="comment">//注意点:Swift中如果想在构造方法中使用KVC给属性赋值,那么在使用KVC之前必须使用super.init()</span></span><br><span class="line">		<span class="comment">//调用super.init()的目的就是为了能在使用KVC赋值之前给属性分配存储空间</span></span><br><span class="line">		setValuesForKeysWithDictionary(dict)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UITableView基本使用">UITableView基本使用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift中遵守协议直接在后面通过逗号分隔即可</span></span><br><span class="line">class ViewController: <span class="built_in">UIViewController</span>&#123;</span><br><span class="line">	</span><br><span class="line">	override func loadView()&#123;</span><br><span class="line">		let tv = <span class="built_in">UITableView</span>()</span><br><span class="line">		tv<span class="variable">.frame</span> = <span class="built_in">UIScreen</span><span class="variable">.mainScreen</span>()<span class="variable">.bounds</span></span><br><span class="line">		tv<span class="variable">.dataSource</span> = <span class="keyword">self</span></span><br><span class="line">		tv<span class="variable">.delegate</span> = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">		view = tv</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MARK: -	懒加载数据</span></span><br><span class="line">	lazy var dataList:[String] = &#123;</span><br><span class="line">		<span class="keyword">return</span> [<span class="string">"xxx"</span>, <span class="string">"xx"</span>, <span class="string">"x"</span>]</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 苹果官方建议,可以将数据源代理方法单独写到一个扩展中,以便于提高代码的可读性</span></span><br><span class="line"><span class="comment">// extension 相当于OC中的category</span></span><br><span class="line">extension ViewController: <span class="built_in">UITableViewDataSource</span>, <span class="built_in">UITableViewDelegate</span>&#123;</span><br><span class="line">	<span class="comment">// MARK: -UITableViewDataSource</span></span><br><span class="line">	func tableView(tableView: <span class="built_in">UITableView</span>, numberOfRowsInSection section:Int) -&gt; Int&#123;</span><br><span class="line">		<span class="keyword">return</span> dataList<span class="variable">.count</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	func tableView(tableView: <span class="built_in">UITableView</span>, cellForRowAtIndexPath indexPath:<span class="built_in">NSIndexPath</span>) -&gt; <span class="built_in">UITableViewCell</span> &#123;</span><br><span class="line">		<span class="comment">// 1.取出cell</span></span><br><span class="line">		let cell = tableView<span class="variable">.dequeueResuableCellWithIdentifier</span>(<span class="string">"customCell"</span>)</span><br><span class="line">		<span class="keyword">if</span> cell == <span class="literal">nil</span>&#123;</span><br><span class="line">			cell = <span class="built_in">UITableViewCell</span>(style:<span class="built_in">UITableViewCellStyle</span><span class="variable">.Default</span>,reuseIdentifier:<span class="string">"customCell"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2.设置数据</span></span><br><span class="line">		cell?<span class="variable">.textLabel</span>?<span class="variable">.text</span> = dataList[indexPath<span class="variable">.row</span>]</span><br><span class="line">		<span class="comment">// 3.返回cell</span></span><br><span class="line">		<span class="keyword">return</span> cell!</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义Log">自定义Log</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数的默认值:如果调用者没有传递对应的参数,那么系统就会使用默认值,如果调用者传递了参数,那么救护使用传递的参数</span></span><br><span class="line"><span class="comment">// 由于编译器可以通过赋值的类型自定推导数据的真实类型,所有Swift开发中,能不写数据类型就不写数据类型</span></span><br><span class="line"><span class="comment">// 优点:可以减少冗余代码</span></span><br><span class="line"><span class="comment">// 如果想在函数中使用泛型,那么必须告诉系统是一个泛型函数</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * func 函数名称&lt;T&gt;(形参列表) -&gt; 返回值类型</span><br><span class="line"> * &#123;</span><br><span class="line"> *</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">// T具体是什么类型由调用者来确定,调用者传递的是什么类型,T就是什么类型</span></span><br><span class="line"> var flag: <span class="built_in">BOOL</span> = <span class="literal">false</span></span><br><span class="line">func MCLog&lt;T&gt;(message: T, fileName: String = __FILE__, methodName: String = __FUNCTION__, lineNumber: Int = __LINE__)&#123;</span><br><span class="line">	<span class="preprocessor">#if DEBUG</span></span><br><span class="line">	print(<span class="string">"\((fileName as NSString).pathComponents.last!).\(methodName)[\(lineNumber)]:\(message)"</span>)</span><br><span class="line">	<span class="preprocessor">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名空间">命名空间</h3><ul>
<li>作用:避免重复,不同项目中的命名空间是不一样的,默认情况下命名空间的名称就是当前项目的名称</li>
<li>Swift中如果想通过类名来创建一个类必须加上命名空间</li>
<li>由于字典/数组中只能存储对象,所以通过一个key从字典中获取值,取出来是一个AnyObject类型,并且如果key写错或者没有对应的值,那么就娶不到值,所以返回值可能有值也可能没值,所以最终的类型是AnyObject?</li>
<li>动态获取命名空间<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">  * guard 可以有效的解决可选绑定容易形成&#123;&#125;嵌套问题</span><br><span class="line">  *	guard 条件表达式 else&#123;</span><br><span class="line">  *		需要执行的语句</span><br><span class="line">  *		只有条件为假才会执行&#123;&#125;中的内容</span><br><span class="line">  *		并且 guard的&#123;&#125;结尾一定要返回 return</span><br><span class="line">  * &#125;</span><br><span class="line">*/</span></span><br><span class="line"><span class="comment">//可选绑定</span></span><br><span class="line"><span class="comment">//as?是因为前面可能有值也可能没值</span></span><br><span class="line"><span class="keyword">if</span> let name = <span class="built_in">NSBundle</span><span class="variable">.mainBundle</span>()<span class="variable">.infoDictionary</span>![<span class="string">"CFBundleExecutable"</span>] as? String</span><br><span class="line">&#123;</span><br><span class="line">	let cls: AnyClass? = <span class="built_in">NSClassFromString</span>(name + <span class="string">"."</span> +childControllerName) </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Swift中如果想通过一个Class来创建一个对象,必须告诉系统这个Class的确切类型</span></span><br><span class="line">	<span class="keyword">if</span> let typeCls = cls as? <span class="built_in">UITableViewController</span><span class="variable">.Type</span>&#123;</span><br><span class="line">		<span class="comment">// 通过Class创建对象</span></span><br><span class="line">		let childController = tyoeCls!<span class="variable">.init</span>()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func addChildViewController(childControllerName: String?, title: String?, imageName: String?)&#123;</span><br><span class="line"></span><br><span class="line">	guard let name = <span class="built_in">NSBundle</span><span class="variable">.mainBundle</span>()<span class="variable">.infoDictionary</span>![<span class="string">"CFBundleExecutable"</span>] as? String <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		MCLog(<span class="string">"获取命名空间失败"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var cls: AnyClass? = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> let vcName = childControllerName</span><br><span class="line">	&#123;</span><br><span class="line">		cls = <span class="built_in">NSClassFromString</span>(name + <span class="string">"."</span> + childControllerName)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	guard let typeCls = cls as? <span class="built_in">UITableViewController</span><span class="variable">.Type</span> <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		MCLog(<span class="string">"cls不能当做UITableViewController"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	let childController = typeCls<span class="variable">.init</span>()</span><br><span class="line"></span><br><span class="line">	childController<span class="variable">.title</span> = title</span><br><span class="line">	<span class="keyword">if</span> let ivName = imageName&#123;</span><br><span class="line">		childController<span class="variable">.tabBarItem</span><span class="variable">.image</span> = <span class="built_in">UIImage</span>(named: imageName)</span><br><span class="line">		childController<span class="variable">.tabBarItem</span><span class="variable">.selectedImage</span> = <span class="built_in">UIImage</span>(named: imageName + <span class="string">"_highlighted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	let nav = <span class="built_in">UINavigationController</span>(rootViewController: childController)</span><br><span class="line">	addChildViewController(nav)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func addChildViewControllers()</span><br><span class="line">&#123;</span><br><span class="line">	guard let filePath = <span class="built_in">NSBundle</span><span class="variable">.mainBundle</span>()<span class="variable">.pathForResource</span>(<span class="string">"MainVCSettings.json"</span>, ofType: <span class="literal">nil</span>) <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		MCLog(<span class="string">"JSON文件不存在"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	guard let data = <span class="built_in">NSData</span>(contentsOfFile: filePath) <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		MCLog(<span class="string">"加载二进制数据失败"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Swift和OC不太一样,OC中一般情况如果发生错误会给传人的指针赋值,而在Swift中使用的是异常处理机制</span></span><br><span class="line">	<span class="comment">//1.以后但凡看到throws的方法,那么就必须进行try处理,而只要看到try,就需要写上do catch</span></span><br><span class="line">	<span class="comment">//2.do&#123;&#125;catch&#123;&#125;,只有do中的代码发生了错误,才会执行catch&#123;&#125;中的代码</span></span><br><span class="line">	<span class="comment">//3.try  正常处理异常,也就是通过do catch来处理</span></span><br><span class="line">	<span class="comment">//  try! 告诉系统一定不会有异常,也就是说可以不通过do catch来处理 但是需要注意,开发中不推荐这样写,一旦发生异常程序就会崩溃 如果没有异常那么会返回一个确定的值给我们</span></span><br><span class="line">	<span class="comment">//  try? 告诉系统可能有错也可能没错,如果没错系统会自动将结果包装成一个可选类型给我们,如果有错系统会返回nil,如果使用try?那么可以不通过do catch来处理</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		let objc = try</span><br><span class="line">		<span class="built_in">NSJSONSerialization</span><span class="variable">.JSONObjectWithData</span>(data, options:<span class="built_in">NSJSONReadingOptions</span><span class="variable">.MutableContainers</span>) as! [[String:AnyObject]]</span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历数组字典取出每一个字典</span></span><br><span class="line">		<span class="keyword">for</span> dict <span class="keyword">in</span> objc</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//根据遍历到的字典创建控制器</span></span><br><span class="line">			let title = dict[<span class="string">"title"</span>] as? String</span><br><span class="line">			let vcName = dict[<span class="string">"vcName"</span>] as? String</span><br><span class="line">			let imageName = dict[<span class="string">"imageName"</span>] as? String</span><br><span class="line">			addChildViewController(vcName, title: title, imageName: imageName)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;catch&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public   :最大权限,可以在当前framework和其它framework中访问</span></span><br><span class="line"><span class="comment">//internal :默认权限,可以在当前framework中随意访问</span></span><br><span class="line"><span class="comment">//private  :私有权限,只能在当前文件中方访问  </span></span><br><span class="line"><span class="comment">//以上权限可以修饰属性/方法/类</span></span><br><span class="line"><span class="comment">//如果给按钮的点击方法加上private就会报错,报错的原因是因为监听事件是由运行循环出发的,而如果该方法是私有的只能在当前类中访问</span></span><br><span class="line"><span class="comment">//而相同的情况在OC中是没有问题的,因为OC是动态派发的,而Swift不一样,Swift中所有的东西都是编译时确定的</span></span><br><span class="line"><span class="comment">//加上 @objc就代表告诉系统需要动态派发</span></span><br><span class="line">@objc private func compseBtnClick(btn: <span class="built_in">UIButton</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为UIButton添加分类</span></span><br><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line">extension <span class="built_in">UIButton</span></span><br><span class="line">&#123;</span><br><span class="line">	convenience init(imageName: String, backgroundImageName: String)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">self</span><span class="variable">.init</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="常量&amp;变量">常量&amp;变量</h3><ul>
<li>let 定义常量,设置之后不可以修改</li>
<li>var 定义变量,设置之后可以修改</li>
<li>语句末尾不用使用 ;</li>
<li>在Swift中使用print() 替代OC中的NSLog</li>
<li>print 的性能更好</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Quartz2D]]></title>
    <link href="http://yoursite.com/2016/04/14/quartz2d/"/>
    <id>http://yoursite.com/2016/04/14/quartz2d/</id>
    <published>2016-04-14T14:02:11.000Z</published>
    <updated>2016-04-17T13:35:49.000Z</updated>
    <content type="html"><![CDATA[<h3 id="什么是Quartz2D">什么是Quartz2D</h3><ul>
<li>Quartz 2D是一个二维绘图引擎,同时支持iOS和Mac系统</li>
<li>Quartz 2D 能完成的工作<ul>
<li>绘制图形:线条\三角形\矩形\弧等</li>
<li>绘制文字</li>
<li>绘制\生成图片(图像)</li>
<li>读取\生成PDF</li>
<li>截图\裁剪图片</li>
<li>自定义UI控件</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="图形上下文">图形上下文</h3><ul>
<li><p>可以理解为画板</p>
</li>
<li><p>图形上下文(Graphics Context): 是一个CGContextRef类型的数据</p>
</li>
<li><p>图形上下文的作用</p>
<ul>
<li>保存绘图信息、绘图状态</li>
<li>决定绘制的输出目标(绘制到什么地方去?) 输出目标可以是PDF文件、Bitmap或者显示器的窗口上<br>绘制好的图形—保存—&gt;图形上下文—显示—&gt;输出目标</li>
</ul>
</li>
<li><p>相同的一套绘图序列,指定不同的Graphics Context,就可将相同的图像绘制到不同的目标</p>
</li>
<li><p>Quartz 2D提供了以下几种类型的Graphics Context:</p>
<ul>
<li>Bitmap Graphics Context</li>
<li>PDF Graphics Context</li>
<li>Window Graphics Context</li>
<li>Layer Graphics Context</li>
<li>Printer Graphics Context</li>
</ul>
</li>
</ul>
<h3 id="自定义view">自定义view</h3><ul>
<li><p>如何利用Quartz 2D自定义view?(自定义UI控件)</p>
</li>
<li><p>如何利用Quartz 2D绘制东西到view上?</p>
<ul>
<li>首先,得有图像上下文,因为它能保存绘图信息,并且决定着绘制到什么地方去</li>
<li>其次,那个图形上下文必须跟view相关联,才能将内容绘制到view上面</li>
</ul>
</li>
<li><p>自定义view的步骤</p>
<ul>
<li>新建一个类,继承自UIView</li>
<li>实现- (void)drawRect:(CGRect)rect方法,然后在这个方法中<ul>
<li>取得跟当前view相关联的图形上下文</li>
<li>绘制相应的图形内容</li>
<li>利用图形上下文将绘制的所有内容渲染显示到view上面</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么要在- (void)drawRect:(CGRect)rect方法里面绘图?</p>
<ul>
<li>因为只有在这个方法里面才能获取到跟View的layer相关联的图形上下文</li>
</ul>
</li>
<li><p>什么时候调用- (void)drawRect:(CGRect)rect方法?</p>
<ul>
<li>当这个View即将要显示的时候才会调用drawRect绘制图形</li>
</ul>
</li>
<li><p>注意rect是当前控件的Bounds</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"LineView.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LineView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 擦除图片</span></span><br><span class="line">- (<span class="keyword">void</span>)clearImage:(<span class="built_in">UIPanGestureRecognizer</span> *)pan&#123;</span><br><span class="line">	<span class="comment">// 获取当前点</span></span><br><span class="line">    <span class="built_in">CGPoint</span> curP = [pan locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取擦除的矩形范围</span></span><br><span class="line">    <span class="built_in">CGFloat</span> wh = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> x = curP<span class="variable">.x</span> - wh * <span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> y = curP<span class="variable">.y</span> - wh * <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(x, y, wh, wh);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span><span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 控件的layer渲染上去</span></span><br><span class="line">    [_imageView<span class="variable">.layer</span> renderInContext:ctx];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 擦除图片</span></span><br><span class="line">    <span class="built_in">CGContextClearRect</span>(ctx, rect);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一张图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    _imageView<span class="variable">.image</span> = image;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 截屏</span></span><br><span class="line">- (<span class="keyword">void</span>)screenShoot&#123;</span><br><span class="line">	<span class="comment">// 1.开启上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span><span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 2.获取上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将控件上的图层渲染到上下文,layer只能渲染</span></span><br><span class="line">	[<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> renderInContext:ctx];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成一张图片</span></span><br><span class="line">	<span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭上下文</span></span><br><span class="line">	<span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// image转data</span></span><br><span class="line">	<span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将图片写入到文件</span></span><br><span class="line">	[data writeToFile:<span class="string">@"xxxx.png"</span> atomically:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带边框的圆角图片</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithClipImage:(<span class="built_in">UIImage</span> *)image borderWidth:(<span class="built_in">CGFloat</span>)borderWidth borderColor:(<span class="built_in">UIColor</span> *)color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 图片的宽度和高度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> imageWH = image<span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置圆环的宽度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> border = borderWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 圆形的宽度和高度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> ovalWH = imageWH + <span class="number">2</span> * border;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.开启上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="built_in">CGSizeMake</span>(ovalWH, ovalWH), <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.画大圆</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, ovalWH, ovalWH)];</span><br><span class="line">    </span><br><span class="line">    [color set];</span><br><span class="line">    </span><br><span class="line">    [path fill];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.设置裁剪区域</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *clipPath = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(border, border, imageWH, imageWH)];</span><br><span class="line">    [clipPath addClip];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.绘制图片</span></span><br><span class="line">    [image drawAtPoint:<span class="built_in">CGPointMake</span>(border, border)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.获取图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *clipImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6.关闭上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> clipImage;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片裁剪</span></span><br><span class="line">- (<span class="keyword">void</span>)clipImage&#123;</span><br><span class="line">	<span class="comment">// 0.加载图片</span></span><br><span class="line">	<span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx"</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1.开启位图上下文,跟图片尺寸一样大</span></span><br><span class="line">	<span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(image<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.设置圆形裁剪区域,正切于图片</span></span><br><span class="line">	<span class="comment">// 2.1创建圆形的路径</span></span><br><span class="line">	<span class="built_in">UIBerzierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,image<span class="variable">.size</span><span class="variable">.width</span>,image<span class="variable">.size</span><span class="variable">.height</span>)];</span><br><span class="line">	<span class="comment">// 2.2将路径设置为裁剪区域</span></span><br><span class="line">	[path addClip];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.绘制图片</span></span><br><span class="line">	[image drawAtPoint:<span class="built_in">CGPointZero</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.从上下文中获取图片</span></span><br><span class="line">	<span class="built_in">UIImage</span> *imageWater = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5.关闭上下文</span></span><br><span class="line">	<span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片水印</span></span><br><span class="line">- (<span class="keyword">void</span>)waterImage&#123;</span><br><span class="line">	<span class="comment">// 位图上下文需要手动创建和关闭</span></span><br><span class="line">	<span class="comment">// 开启一个位图上下文,注意位图上下文跟view无关联,所以不需要在drawRect中使用</span></span><br><span class="line">	<span class="comment">// size:位图上下文的尺寸(新图片的尺寸)</span></span><br><span class="line">	<span class="comment">// opaque: 不透明度 YES:不透明 NO:透明,通常我们一般都设置为透明的上下文</span></span><br><span class="line">	<span class="comment">// scale: 通常不需要缩放上下文,取值为0,表示不缩放</span></span><br><span class="line">	<span class="comment">// 1.开启图形上下文,绘制原生的图片</span></span><br><span class="line">	<span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx"</span>];</span><br><span class="line">	<span class="comment">//等同于UIGraphicsBeginImageContextWithOptions(image.size, NO, [UIScreen mainScreen].scale);</span></span><br><span class="line">	<span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(image<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1).获取上下文--位图上下文不是layer上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">	<span class="comment">// 2).描述路径</span></span><br><span class="line">	<span class="built_in">CGContextMoveToPoint</span>(ctx, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">	<span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">	<span class="comment">// 3).渲染上下文</span></span><br><span class="line">	<span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.给原生的图片添加文字</span></span><br><span class="line">	<span class="built_in">NSString</span> *text = <span class="string">@"abcd"</span>;</span><br><span class="line">	[text drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>,<span class="number">528</span>) withAttributes:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.生成一张图片,从当前上下文中获取图片</span></span><br><span class="line">	<span class="built_in">UIImage</span> *imageWater = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.关闭上下文</span></span><br><span class="line">	<span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形上下文矩阵操作(平移、缩放、旋转)</span></span><br><span class="line">- (<span class="keyword">void</span>)drawView&#123;</span><br><span class="line">	<span class="comment">// 1.获取上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.描述路径</span></span><br><span class="line">	<span class="comment">// 绘制椭圆</span></span><br><span class="line">	<span class="built_in">UIBerzierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(-<span class="number">100</span>,-<span class="number">50</span>,<span class="number">200</span>,<span class="number">100</span>)];</span><br><span class="line"></span><br><span class="line">	[[<span class="built_in">UIColor</span> redColor] set];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 上下文矩阵操作</span></span><br><span class="line">	<span class="comment">// 平移 </span></span><br><span class="line">	<span class="comment">// 注意:矩阵操作必须要在添加路径之前</span></span><br><span class="line">	<span class="built_in">CGContextTranslateCTM</span>(ctx,<span class="number">100</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缩放</span></span><br><span class="line">	<span class="built_in">CGContextScaleCTM</span>(ctx,<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 旋转</span></span><br><span class="line">	<span class="built_in">CGContextRotateCTM</span>(ctx,M_PI_4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.将路径添加到上下文</span></span><br><span class="line">	<span class="built_in">CGContextAddPath</span>(ctx,path<span class="variable">.CGPath</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.渲染上下文</span></span><br><span class="line">	<span class="built_in">CGContextFillPath</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形上下文状态栈</span></span><br><span class="line"><span class="comment">// 如果用贝瑟尔绘制图形[path stroke],上下文的状态由贝瑟尔路径状态决定</span></span><br><span class="line">- (<span class="keyword">void</span>)drawTwoLines&#123;</span><br><span class="line">	<span class="comment">// 1.获取上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.描述路径 第一根线</span></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line"></span><br><span class="line">	[path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">10</span>,<span class="number">125</span>)];</span><br><span class="line"></span><br><span class="line">	[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">240</span>,<span class="number">125</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.将路径添加到上下文</span></span><br><span class="line">	<span class="built_in">CGContextAddPath</span>(ctx,path<span class="variable">.CGPath</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先保存一份上下文的状态</span></span><br><span class="line">	<span class="built_in">CGContextSaveGState</span>(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.设置上下文状态</span></span><br><span class="line">	<span class="built_in">CGContextSetLineWidth</span>(ctx,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	[[<span class="built_in">UIColor</span> redColr] set];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5.渲染上下文</span></span><br><span class="line">	<span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二根线</span></span><br><span class="line">	path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line"></span><br><span class="line">	[path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">125</span>,<span class="number">10</span>)];</span><br><span class="line"></span><br><span class="line">	[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">125</span>,<span class="number">240</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGContextAddPath</span>(ctx,path<span class="variable">.CGPath</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 恢复上下文状态</span></span><br><span class="line">	<span class="built_in">CGContextRestoreGState</span>(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//CGContextSetLineWidth(ctx,5);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//[[UIColor blackColr] set];</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制雪花</span></span><br><span class="line">- (<span class="keyword">void</span>)drawSnow&#123;</span><br><span class="line">	<span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx"</span>];</span><br><span class="line">	[image drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>,_snowY)];</span><br><span class="line">	_snowY += <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">if</span>(_snowY &gt; rect<span class="variable">.size</span><span class="variable">.height</span>)&#123;</span><br><span class="line">		_snowY = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib&#123;</span><br><span class="line">	<span class="comment">// 创建定时器 </span></span><br><span class="line">	<span class="comment">// CADisplayLink:每次屏幕刷新的时候会调用,屏幕一般一秒刷新60次</span></span><br><span class="line">	<span class="built_in">CADisplayLink</span> *display = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timeChange)];</span><br><span class="line">	<span class="comment">// 添加到主运行循环</span></span><br><span class="line">	[display addToRunLoop:[<span class="built_in">NSRunLoop</span> mainRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timeChange&#123;</span><br><span class="line">	<span class="comment">// 注意:这个方法并不会马上调用drawRect,这个方法只是给当前控件添加一个刷新标记,等下一次屏幕刷新的时候才会调用drawRect</span></span><br><span class="line">	[<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制图片</span></span><br><span class="line">- (<span class="keyword">void</span>)drawPic&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 超出裁剪区域的内容全部裁剪掉</span></span><br><span class="line">	<span class="comment">// 注意:裁剪必须放在绘制之前</span></span><br><span class="line">	<span class="built_in">UIRectClip</span>(<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx"</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认绘制的内容尺寸跟图片尺寸一样大</span></span><br><span class="line">	[image drawAtPoint:<span class="built_in">CGPointZero</span>];</span><br><span class="line">	<span class="comment">// 将图片控制在一定范围内</span></span><br><span class="line">	[image drawInRect:rect];</span><br><span class="line">	<span class="comment">// 将图片平铺</span></span><br><span class="line">	[image drawAsPatternInRect:rect];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制文字和图片</span></span><br><span class="line">- (<span class="keyword">void</span>)drawText&#123;</span><br><span class="line">	<span class="built_in">NSString</span> *words = <span class="string">@"abcdef"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">	<span class="comment">// 设置文字颜色</span></span><br><span class="line">	dict[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置文字字体</span></span><br><span class="line">	dict[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置文字的空心颜色和宽度</span></span><br><span class="line">	dict[<span class="built_in">NSStrokeWidthAttributeName</span>] = @<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	dict[<span class="built_in">NSStrokeColorAttributeName</span>] = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建阴影</span></span><br><span class="line">	<span class="built_in">NSShadow</span> *shadow = [[<span class="built_in">NSShadow</span> alloc] init];</span><br><span class="line">	shadow<span class="variable">.shadowColor</span> = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">	shadow<span class="variable">.shadowOffset</span> = <span class="built_in">CGSizeMake</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">	shadow<span class="variable">.shadowBlurRadius</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	dict[<span class="built_in">NSShadowAttributeName</span>] = shadow;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 文字的起点 不会换行</span></span><br><span class="line">	[words drawAtPoint:<span class="built_in">CGPointZero</span> withAttributes:dict];</span><br><span class="line">	<span class="comment">// 会换行</span></span><br><span class="line">	[words drawAtRect:rect withAttributes:dict];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制柱状图</span></span><br><span class="line">- (<span class="keyword">void</span>)drawZ&#123;</span><br><span class="line">	<span class="built_in">NSArray</span> *arr = @[@<span class="number">25</span>,@<span class="number">25</span>,@<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGFloat</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> y = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> w = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> h = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr<span class="variable">.count</span>;i++)&#123;</span><br><span class="line">		w = rect<span class="variable">.size</span><span class="variable">.width</span> / (<span class="number">2</span>*arr<span class="variable">.count</span> -<span class="number">1</span>);</span><br><span class="line">		x = <span class="number">2</span> * w * i;</span><br><span class="line">		h = [arr[i] floatValue] / <span class="number">100.0</span> * rect<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">		y = rect<span class="variable">.size</span><span class="variable">.height</span> - h;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:<span class="built_in">CGRectMake</span>(x, y, w, h)];</span><br><span class="line"></span><br><span class="line">		[[<span class="keyword">self</span> randomColor] set];</span><br><span class="line"></span><br><span class="line">		[path fill];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制饼图</span></span><br><span class="line">- (<span class="keyword">void</span>)drawBin&#123;</span><br><span class="line">	<span class="built_in">NSArray</span> *arr = @[@<span class="number">25</span>,@<span class="number">25</span>,@<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGFloat</span> radius = rect<span class="variable">.size</span><span class="variable">.width</span>*<span class="number">0.5</span>;</span><br><span class="line">	<span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(radius,radius);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGFloat</span> startA = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> angle = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> endA = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr<span class="variable">.count</span>;i++)&#123;</span><br><span class="line">		startA = endA;</span><br><span class="line">		angle = [arr[i] doubleValue] / <span class="number">100.0</span> *M_PI *<span class="number">2</span>;</span><br><span class="line">		endA = startA + angle;</span><br><span class="line">		<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 添加一根线到圆心</span></span><br><span class="line">		[path addLineToPoint:center];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 描边和填充通用</span></span><br><span class="line">		[[<span class="keyword">self</span> randomColor] set];</span><br><span class="line"></span><br><span class="line">		[path fill];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIColor</span> *)randomColor&#123;</span><br><span class="line">	<span class="built_in">CGFloat</span> r = arc4random_uniform(<span class="number">256</span>) / <span class="number">255.0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> g = arc4random_uniform(<span class="number">256</span>) / <span class="number">255.0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> b = arc4random_uniform(<span class="number">256</span>) / <span class="number">255.0</span>;</span><br><span class="line">	<span class="keyword">return</span> [<span class="built_in">UIColor</span> colorWithRed:r green:g blue:b alpha:<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制下载进度 需要重绘的时候调用[self setNeedDisplay]</span></span><br><span class="line">- (<span class="keyword">void</span>)drawProgress&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGFloat</span> radius = rect<span class="variable">.size</span><span class="variable">.width</span>*<span class="number">0.5</span>;</span><br><span class="line">	<span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(radius,radius);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGFloat</span> endAngle = -M_PI_2 + _progress * M_PI *<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:radius startAngle:-M_PI_2 endAngle:endAngle clockwise:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">	[path stroke];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制扇形</span></span><br><span class="line">- (<span class="keyword">void</span>)drawArc2&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(<span class="number">125</span>,<span class="number">125</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:<span class="number">100</span> startAngle:<span class="number">0</span> endAngle:M_PI_2 clockwise:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加一根线到圆心</span></span><br><span class="line">	[path addLineToPoint:center];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 封闭路径,关闭路径:从路径的终点到起点</span></span><br><span class="line">	[path closePath];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充:必须是一个完整的封闭路径,默认就会自动关闭路径</span></span><br><span class="line">	[path fill];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制圆弧</span></span><br><span class="line">- (<span class="keyword">void</span>)drawArc&#123;</span><br><span class="line">	<span class="comment">// Center: 圆心</span></span><br><span class="line">	<span class="comment">// startAngle: 弧度</span></span><br><span class="line">	<span class="comment">// clockwise: YES是顺时针 NO是逆时针</span></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:<span class="built_in">CGPointMake</span>(<span class="number">125</span>,<span class="number">125</span>) radius:<span class="number">100</span> startAngle:<span class="number">0</span> endAngle:-M_PI_2 clockwise:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line">	[path stroke];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制圆角矩形</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRoundRect&#123;</span><br><span class="line">	<span class="comment">// 圆角矩形  如果圆角半径为矩形宽度的一般 则是圆</span></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(<span class="number">20</span>,<span class="number">20</span>,<span class="number">200</span>,<span class="number">200</span>) cornerRadius:<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//[path stroke];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充</span></span><br><span class="line">	[path fill];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制曲线</span></span><br><span class="line">- (<span class="keyword">void</span>)drawQuadCurve&#123;</span><br><span class="line">	<span class="comment">// 获取上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 描述路径</span></span><br><span class="line">	<span class="built_in">CGContextMoveToPoint</span>(ctx, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// cpx:控制点的x cpy:控制点的y</span></span><br><span class="line">	<span class="built_in">CGContextAddQuadCurveToPoint</span>(ctx,<span class="number">150</span>,<span class="number">20</span>,<span class="number">250</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 渲染上下文</span></span><br><span class="line">	<span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用UIBezierPath绘制有状态信息的线条</span></span><br><span class="line">- (<span class="keyword">void</span>)drawBezierStatus&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置起点</span></span><br><span class="line">	[path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">50</span>,<span class="number">50</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加一根线到某个点</span></span><br><span class="line">	[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>,<span class="number">200</span>)];</span><br><span class="line"></span><br><span class="line">	path<span class="variable">.lineWidth</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	[[<span class="built_in">UIColor</span> redColor] set];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制路径</span></span><br><span class="line">	[path stroke];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path1 = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置起点</span></span><br><span class="line">	[path1 moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>,<span class="number">0</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加一根线到某个点</span></span><br><span class="line">	[path1 addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">30</span>,<span class="number">60</span>)];</span><br><span class="line"></span><br><span class="line">	path1<span class="variable">.lineWidth</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	[[<span class="built_in">UIColor</span> blueColor] set];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制路径</span></span><br><span class="line">	[path1 stroke];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制有状态信息的线条</span></span><br><span class="line">- (<span class="keyword">void</span>)drawCtxStatus&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1.获取图形上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 描述路径</span></span><br><span class="line">	<span class="built_in">CGContextMoveToPoint</span>(ctx, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新设置起点</span></span><br><span class="line">	<span class="built_in">CGContextMoveToPoint</span>(ctx, <span class="number">80</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认下一根线的起点就是上一根线的终点</span></span><br><span class="line">	<span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置绘图状态,一定要在渲染之前</span></span><br><span class="line">	<span class="comment">// 设置描边颜色</span></span><br><span class="line">	[[<span class="built_in">UIColor</span> redColor] setStroke];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置线宽</span></span><br><span class="line">	<span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置连接样式kCGLineJoinBevel、kCGLineJoinMiter、kCGLineJoinRound</span></span><br><span class="line">	<span class="built_in">CGContextSetLineJoin</span>(ctx, k<span class="built_in">CGLineJoinRound</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置顶角样式kCGLineCapButt、kCGLineCapRound、kCGLineCapSquare</span></span><br><span class="line">	<span class="built_in">CGContextSetLineCap</span>(ctx, k<span class="built_in">CGLineCapRound</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 渲染上下文</span></span><br><span class="line">	<span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用UIBezierPath绘制线条</span></span><br><span class="line">- (<span class="keyword">void</span>)drawLine1&#123;</span><br><span class="line">	<span class="comment">// 贝瑟尔路径</span></span><br><span class="line">	<span class="comment">// 创建路径</span></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置起点</span></span><br><span class="line">	[path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">50</span>,<span class="number">50</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加一根线到某个点</span></span><br><span class="line">	[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>,<span class="number">200</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制路径</span></span><br><span class="line">	[path stroke];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制线条</span></span><br><span class="line">- (<span class="keyword">void</span>)drawLine&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1.获取图形上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面4步相当于</span></span><br><span class="line">	<span class="comment">//CGContextMoveToPoint(ctx, 50, 50);</span></span><br><span class="line">	<span class="comment">//CGContextAddLineToPoint(ctx, 200, 200);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.描述路径</span></span><br><span class="line">	<span class="comment">// 创建路径</span></span><br><span class="line">	<span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置起点</span></span><br><span class="line">	<span class="comment">// path: 给哪个路径设置起点</span></span><br><span class="line">	<span class="built_in">CGPathMoveToPoint</span>(path, <span class="literal">NULL</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加一根线到某个点</span></span><br><span class="line">	<span class="built_in">CGPathAddLineToPoint</span>(path, <span class="literal">NULL</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.将路径添加到上下文</span></span><br><span class="line">	<span class="built_in">CGContextAddPath</span>(ctx, path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.渲染上下文</span></span><br><span class="line">	<span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="什么是Quartz2D">什么是Quartz2D</h3><ul>
<li>Quartz 2D是一个二维绘图引擎,同时支持iOS和Mac系统</li>
<li>Quartz 2D 能完成的工作<ul>
<li>绘制图形:线条\三角形\矩形\弧等</li>
<li>绘制文字</li>
<li>绘制\生成图片(图像)</li>
<li>读取\生成PDF</li>
<li>截图\裁剪图片</li>
<li>自定义UI控件</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[UICollectionView的使用]]></title>
    <link href="http://yoursite.com/2016/04/13/uicollectionview/"/>
    <id>http://yoursite.com/2016/04/13/uicollectionview/</id>
    <published>2016-04-13T05:54:05.000Z</published>
    <updated>2016-10-14T12:20:31.000Z</updated>
    <content type="html"><![CDATA[<h3 id="自定义布局_-_继承UICollectionViewFlowLayout">自定义布局 - 继承UICollectionViewFlowLayout</h3><h4 id="重写prepareLayout方法">重写prepareLayout方法</h4><ul>
<li>作用:在这个方法中做一些初始化操作</li>
<li>注意:一定要调用[super prepareLayout]</li>
</ul>
<a id="more"></a>
<h4 id="重写layoutAttributesForElementsInRect:方法">重写layoutAttributesForElementsInRect:方法</h4><ul>
<li>作用:<ul>
<li>这个方法的返回值是个数组</li>
<li>这个数组中存放的都是UICollectionViewLayoutAttributes对象</li>
<li>UICollectionViewLayoutAttributes对象决定了cell的排布方式(frame等)</li>
</ul>
</li>
</ul>
<h4 id="重写shouldInvalidateLayoutForBoundsChange:方法">重写shouldInvalidateLayoutForBoundsChange:方法</h4><ul>
<li>作用:如果返回YES,那么collectionView显示的范围发生改变时,就会重新刷新布局</li>
<li>一旦重新刷新布局,就会按顺序调用下面的方法:<ul>
<li>prepareLayout</li>
<li>layoutAttributesForElementsInRect:</li>
</ul>
</li>
</ul>
<h4 id="重写targetContentOffsetForProposedContentOffset:withScrollingVelocity:方法">重写targetContentOffsetForProposedContentOffset:withScrollingVelocity:方法</h4><ul>
<li>作用:返回值决定了collectionView停止滚动时最终的偏移量(contentOffset)</li>
<li>参数:<ul>
<li>proposedContentOffset:原本情况下,collectionView停止滚动时最终的偏移量</li>
<li>velocity:滚动速率,通过这个参数可以了解滚动的方向</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="自定义布局_-_继承UICollectionViewFlowLayout">自定义布局 - 继承UICollectionViewFlowLayout</h3><h4 id="重写prepareLayout方法">重写prepareLayout方法</h4><ul>
<li>作用:在这个方法中做一些初始化操作</li>
<li>注意:一定要调用[super prepareLayout]</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSInvocation的使用]]></title>
    <link href="http://yoursite.com/2016/04/04/nsinvocation/"/>
    <id>http://yoursite.com/2016/04/04/nsinvocation/</id>
    <published>2016-04-04T12:43:37.000Z</published>
    <updated>2016-04-05T12:42:50.000Z</updated>
    <content type="html"><![CDATA[<h3 id="NSInvocation的简单使用">NSInvocation的简单使用</h3><h5 id="创建方法签名">创建方法签名</h5><ul>
<li>使用NSObject的对象方法或者类方法来创建NSMethodSignature<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSObject的对象方法,任何继承自NSObject的对象都可以调用</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSObject的类方法,任何继承自NSObject的类都可以调用</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)instanceMethodSignatureForSelector:(SEL)aSelector</span><br><span class="line"></span><br><span class="line">SEL selector = <span class="built_in">NSSelectorFromString</span>(methodNameStr);</span><br><span class="line"><span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">self</span> methodSignatureForSelector:selector];</span><br><span class="line"><span class="comment">//或使用下面这种方式</span></span><br><span class="line"><span class="built_in">NSMethodSignature</span> *signature = [[<span class="keyword">self</span> class] instanceMethodSignatureForSelector:selector];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li>NSMethodSignature常用的只读属性<ul>
<li>numberOfArguments:方法参数的个数</li>
<li>methodReturnLength:方法返回值类型的长度,大于0表示有返回值</li>
</ul>
</li>
</ul>
<h4 id="使用方法的签名来创建一个NSInvocation对象">使用方法的签名来创建一个NSInvocation对象</h4><p><code>NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</code></p>
<h4 id="给invocation对象的两个属性赋值">给invocation对象的两个属性赋值</h4><ul>
<li>要执行谁的(target)的哪个方法(selector)<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">invocation<span class="variable">.target</span> = <span class="keyword">self</span>;</span><br><span class="line">invocation<span class="variable">.selector</span> = <span class="keyword">@selector</span>(test:withArg2:andArg3:);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="给要执行的方法设置参数">给要执行的方法设置参数</h4><ul>
<li>使用setArgument:atIndex:方法给要执行的方法设置参数,注意下标从2开始,因为0、1已经被target与selector占用.设置参数,必须传递参数的地址,不能直接传值<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *arg1 = <span class="string">@"a"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *arg2 = <span class="string">@"b"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *arg3 = <span class="string">@"c"</span>;</span><br><span class="line">[invocation setArgument:&amp;arg1 atIndex:<span class="number">2</span>];</span><br><span class="line">[invocation setArgument:&amp;arg2 atIndex:<span class="number">3</span>];</span><br><span class="line">[invocation setArgument:&amp;arg3 atIndex:<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="执行方法">执行方法</h4><p><code>[invocation invoke];</code></p>
<h4 id="获取执行方法的返回值">获取执行方法的返回值</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以在invoke方法前添加,也可以在invoke方法后添加</span></span><br><span class="line"><span class="comment">// 通过方法签名的methodReturnLength判断是否有返回值</span></span><br><span class="line"><span class="keyword">if</span> (signature<span class="variable">.methodReturnLength</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">id</span> *result = <span class="literal">nil</span>;</span><br><span class="line">    [invocation getReturnValue:&amp;result];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为NSObject添加分类封装多个参数的方法调用">为NSObject添加分类封装多个参数的方法调用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Extension</span>)</span></span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)selector withObjects:(<span class="built_in">NSArray</span> *)objects</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法签名(方法的描述)-哪个对象的哪个方法</span></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [[<span class="keyword">self</span> class] instanceMethodSignatureForSelector:selector];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(signature == <span class="literal">nil</span>)&#123;</span><br><span class="line">        <span class="comment">//@throw [NSException exceptionWithName:@"调用错误" reason:@"方法找不到" userInfo:nil];</span></span><br><span class="line">        [<span class="built_in">NSException</span> raise:<span class="string">@"调用错误"</span> format:<span class="string">@"%@方法找不到"</span>,<span class="built_in">NSStringFromSelector</span>(selector)];</span><br><span class="line">        <span class="comment">//return nil;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// NSInvocation: 利用一个NSInvocation对象包装一次方法调用(方法调用者、方法名、方法参数、方法返回值)</span></span><br><span class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    <span class="comment">// 除self、_cmd(方法本身)之外的参数个数</span></span><br><span class="line">    <span class="built_in">NSInteger</span> paramsCount = signature<span class="variable">.numberOfArguments</span>-<span class="number">2</span>;</span><br><span class="line">    paramsCount = MIN(paramsCount, objects<span class="variable">.count</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i=<span class="number">0</span>; i&lt;paramsCount; i++) &#123;</span><br><span class="line">        <span class="keyword">id</span> object = objects[i];</span><br><span class="line">        <span class="keyword">if</span>([object isKindOfClass:[<span class="built_in">NSNull</span> class]]) <span class="keyword">continue</span>;</span><br><span class="line">        [invocation setArgument:&amp;object atIndex:i+<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 谁来调用</span></span><br><span class="line">    invocation<span class="variable">.target</span> = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用哪个方法</span></span><br><span class="line">    invocation<span class="variable">.selector</span> = selector;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    [invocation invoke];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取返回值</span></span><br><span class="line">    <span class="keyword">id</span> returnValue = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有返回值类型,才去获取返回值</span></span><br><span class="line">    <span class="keyword">if</span>(signature<span class="variable">.methodReturnLength</span>)&#123;</span><br><span class="line">        [invocation getReturnValue:&amp;returnValue];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="NSInvocation的简单使用">NSInvocation的简单使用</h3><h5 id="创建方法签名">创建方法签名</h5><ul>
<li>使用NSObject的对象方法或者类方法来创建NSMethodSignature<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSObject的对象方法,任何继承自NSObject的对象都可以调用</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSObject的类方法,任何继承自NSObject的类都可以调用</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)instanceMethodSignatureForSelector:(SEL)aSelector</span><br><span class="line"></span><br><span class="line">SEL selector = <span class="built_in">NSSelectorFromString</span>(methodNameStr);</span><br><span class="line"><span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">self</span> methodSignatureForSelector:selector];</span><br><span class="line"><span class="comment">//或使用下面这种方式</span></span><br><span class="line"><span class="built_in">NSMethodSignature</span> *signature = [[<span class="keyword">self</span> class] instanceMethodSignatureForSelector:selector];</span><br></pre></td></tr></table></figure>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS使用Reachability实时检测网络连接状况]]></title>
    <link href="http://yoursite.com/2016/04/03/reachability/"/>
    <id>http://yoursite.com/2016/04/03/reachability/</id>
    <published>2016-04-03T10:22:04.000Z</published>
    <updated>2016-04-03T14:11:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Reachability能做什么">Reachability能做什么</h3><ul>
<li><p>监测网络是否可用</p>
</li>
<li><p>判断当前处于什么网络环境(2G/3G,WIFI)</p>
</li>
<li><p>监测连接方式的变更</p>
</li>
</ul>
<a id="more"></a>
<h3 id="下载">下载</h3><ul>
<li><p>苹果官方:<a href="https://developer.apple.com/library/ios/samplecode/Reachability/Introduction/Intro.html" target="_blank" rel="external">点击下载</a></p>
</li>
<li><p>Git:<a href="https://github.com/tonymillion/Reachability" target="_blank" rel="external">点击下载</a></p>
</li>
</ul>
<h3 id="安装">安装</h3><ul>
<li>下载Reachability.h和Reachability.m文件,拽入你的工程中,然后添加SystemConfiguration.framework库即可</li>
</ul>
<h3 id="使用">使用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) Reachability  *reachability;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在程序的启动处,开启通知</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)applicationdidFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 开启网络状况的监听</span></span><br><span class="line">	[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(reachabilityChanged:) name:kReachabilityChangedNotification object: <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//self.reachability = [Reachability reachabilityWithHostName:@"www.apple.com"];</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">self</span><span class="variable">.reachability</span> = [Reachability reachabilityForInternetConnection];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始监听,会启动一个RunLoop</span></span><br><span class="line">	[<span class="keyword">self</span><span class="variable">.reachability</span> startNotifier]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Called by Reachability whenever status changes.</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) reachabilityChanged:(<span class="built_in">NSNotification</span> *)note</span><br><span class="line">&#123;</span><br><span class="line">     Reachability* curReach = [note object];</span><br><span class="line"></span><br><span class="line">     <span class="built_in">NSParameterAssert</span>([curReach isKindOfClass:[Reachability class]]);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 更新用户界面,或者在当前状态实现你想要的处理</span></span><br><span class="line">     [<span class="keyword">self</span> updateInterfaceWithReachability:curReach];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理连接改变后的情况</span></span><br><span class="line">- (<span class="keyword">void</span>)updateInterfaceWithReachability: (Reachability*)curReach</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 对连接改变做出响应的处理动作</span></span><br><span class="line">	NetworkStatus status=[curReach currentReachabilityStatus];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(status)&#123;</span><br><span class="line">		<span class="keyword">case</span> NotReachable: <span class="comment">// 没有连接到网络</span></span><br><span class="line">			<span class="built_in">UIAlertView</span> *alert= [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"xxxx"</span> message:<span class="string">@"NotReachable"</span></span><br><span class="line">                         delegate:<span class="literal">nil</span> cancelButtonTitle:<span class="string">@"YES"</span> otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">        	alert show];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ReachableViaWWAN: <span class="comment">// 使用3G网络</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ReachableViaWiFi:  <span class="comment">// 使用WiFi网络 </span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否wifi</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>) IsEnableWIFI</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ([[Reachability reachabilityForLocalWiFi] currentReachabilityStatus] != NotReachable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否3G</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>) IsEnable3G</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> ([[Reachability reachabilityForInternetConnection] currentReachabilityStatus] != NotReachable);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">	[[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">	[<span class="keyword">self</span><span class="variable">.reachability</span> stopNotifier];</span><br><span class="line">	<span class="keyword">self</span><span class="variable">.reachability</span> = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Reachability能做什么">Reachability能做什么</h3><ul>
<li><p>监测网络是否可用</p>
</li>
<li><p>判断当前处于什么网络环境(2G/3G,WIFI)</p>
</li>
<li><p>监测连接方式的变更</p>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS实现图片轮播]]></title>
    <link href="http://yoursite.com/2016/04/03/image_switch/"/>
    <id>http://yoursite.com/2016/04/03/image_switch/</id>
    <published>2016-04-03T03:04:43.000Z</published>
    <updated>2016-04-03T09:40:19.000Z</updated>
    <content type="html"><![CDATA[<h3 id="使用2个UIImageView实现图片轮播">使用2个UIImageView实现图片轮播</h3><h4 id="轮播原理">轮播原理</h4><ul>
<li>假设轮播控件的宽度为x高度为y,我们设置UIScrollView的contentSize.width为3x,并让UIScrollView的水平偏移量为x,既显示最中间内容<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">scrollView<span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="number">3</span>x, y);</span><br><span class="line">scrollView<span class="variable">.contentOffset</span> = <span class="built_in">CGPointMake</span>(x, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>将UIImageView添加到UIScrollView内容视图的中间位置</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_currImageView<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(x, <span class="number">0</span>, x, y);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用KVO来监听direction属性值的改变</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"direction"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过KVO方式监听UIScrollView滚动方向的变化</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span>(change[<span class="built_in">NSKeyValueChangeNewKey</span>] == change[<span class="built_in">NSKeyValueChangeOldKey</span>]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNewKey</span>] intValue] == DirecRight) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.otherImageView</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.height</span>);</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.nextIndex</span> = <span class="keyword">self</span><span class="variable">.currIndex</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.nextIndex</span> &lt; <span class="number">0</span>) <span class="keyword">self</span><span class="variable">.nextIndex</span> = _images<span class="variable">.count</span> - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNewKey</span>] intValue] == DirecLeft)&#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.otherImageView</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="built_in">CGRectGetMaxX</span>(_currImageView<span class="variable">.frame</span>), <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.height</span>);</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.nextIndex</span> = (<span class="keyword">self</span><span class="variable">.currIndex</span> + <span class="number">1</span>) % _images<span class="variable">.count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.otherImageView</span><span class="variable">.image</span> = <span class="keyword">self</span><span class="variable">.images</span>[<span class="keyword">self</span><span class="variable">.nextIndex</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来使用UIScrollView代理方法来监听scrollview的滚动,定义一个枚举变量来记录滚动的方向</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</span><br><span class="line">  DirecNone,</span><br><span class="line">  DirecLeft,</span><br><span class="line">  DirecRight</span><br><span class="line">&#125; Direction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) Direction direction;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动UIScrollView持续会调用这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">  <span class="keyword">self</span><span class="variable">.direction</span> = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span> &gt;x? DirecLeft : DirecRight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手指即将开始拽动UIScrollView</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    [<span class="keyword">self</span> stopTimer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束拖拽</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate&#123;</span><br><span class="line">    [<span class="keyword">self</span> startTimer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手指停止并结束滚动UIScrollView</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    [<span class="keyword">self</span> pauseScroll];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [self.scrollView setContentOffset:CGPointMake(self.width * 2, 0) animated:YES];</span></span><br><span class="line"><span class="comment">// 通过设置动画滚动UIScrollView结束的时候会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    [<span class="keyword">self</span> pauseScroll];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理停止滚动UIScrollView</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// self.scrollView.contentOffset = CGPointMake(self.width, 0);不会调用下面这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)pauseScroll &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.direction</span> = DirecNone;<span class="comment">// 重置方向</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.contentOffset</span><span class="variable">.x</span> / <span class="keyword">self</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">1</span>) <span class="keyword">return</span>;<span class="comment">// 滚动位置未变,则不处理</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.currIndex</span> = <span class="keyword">self</span><span class="variable">.nextIndex</span>;<span class="comment">// 记录当前滚动位置</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.pageControl</span><span class="variable">.currentPage</span> = <span class="keyword">self</span><span class="variable">.currIndex</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.currImageView</span><span class="variable">.image</span> = <span class="keyword">self</span><span class="variable">.otherImageView</span><span class="variable">.image</span>; <span class="comment">// 设置中间UIImageView的UIImage为otherImageView的UIImage</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.contentOffset</span> = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span><span class="variable">.width</span>, <span class="number">0</span>);<span class="comment">// 滚动UIScrollView到中间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="总结">总结</h4><ul>
<li><p>一直保持滑动到中间位置</p>
</li>
<li><p>往左滑动的时候将第二个视图放到最右边并设置其UIImage为下一张图片,滑动结束时还原操作使得UIScrollView滚动到中间位置并更新中间视图和上一个视图</p>
</li>
<li><p>往右滑动的时候将第二个视图放到最左边并设置其UIImage为上一张图片,滑动结束时还原操作使得UIScrollView滚动到中间位置并更新中间视图和上一个视图</p>
</li>
</ul>
<h4 id="使用三个UIImageView实现图片轮播">使用三个UIImageView实现图片轮播</h4><ul>
<li>地址:<a href="http://www.tuicool.com/articles/m6FJr2" target="_blank" rel="external">http://www.tuicool.com/articles/m6FJr2</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="使用2个UIImageView实现图片轮播">使用2个UIImageView实现图片轮播</h3><h4 id="轮播原理">轮播原理</h4><ul>
<li>假设轮播控件的宽度为x高度为y,我们设置UIScrollView的contentSize.width为3x,并让UIScrollView的水平偏移量为x,既显示最中间内容<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">scrollView<span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="number">3</span>x, y);</span><br><span class="line">scrollView<span class="variable">.contentOffset</span> = <span class="built_in">CGPointMake</span>(x, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS网络]]></title>
    <link href="http://yoursite.com/2016/03/28/ios_network/"/>
    <id>http://yoursite.com/2016/03/28/ios_network/</id>
    <published>2016-03-28T03:08:14.000Z</published>
    <updated>2016-03-29T12:16:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="NSURLConnection">NSURLConnection</h3><h4 id="常用类">常用类</h4><ul>
<li><p>NSURL:请求地址</p>
</li>
<li><p>NSURLRequest:一个NSURLRequest对象就代表一个请求,它包含的信息有</p>
<ul>
<li>一个NSURL对象</li>
<li>请求方法、请求头、请求体</li>
<li>请求超时</li>
<li>…</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>NSMutableURLRequest:NSURLRequest的子类</p>
</li>
<li><p>NSURLConnection</p>
<ul>
<li>负责发送请求,建立客户端和服务端的连接</li>
<li>发送数据给服务器,并收集来自服务器的响应数据</li>
</ul>
</li>
</ul>
<h4 id="NSURLConnection的使用步骤">NSURLConnection的使用步骤</h4><ul>
<li>使用发送请求的步骤很简单<ul>
<li>创建一个NSURL对象,设置请求路径</li>
<li>传人NSURL创建一个NSURLRequest对象,设置请求头和请求体</li>
<li>使用NSURLConnection发送请求</li>
</ul>
</li>
</ul>
<h4 id="NSURLConnection发送请求">NSURLConnection发送请求</h4><h4 id="同步请求">同步请求</h4><p><code>+ (nullable NSData *)sendSynchronousRequest:(NSURLRequest *)request returningResponse:(NSURLResponse * __nullable * __nullable)response error:(NSError **)error</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 发送同步请求</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)sync</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="comment">// sendSynchronousRequest阻塞式的方法,等待服务器返回数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSHTTPURLResponse</span> *response = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.解析服务器返回的数据(解析成字符串)</span></span><br><span class="line">    <span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, string, response<span class="variable">.allHeaderFields</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步请求:根据对服务器返回数据的处理方式的不同,又可以分为2种:block回调和代理">异步请求:根据对服务器返回数据的处理方式的不同,又可以分为2种:block回调和代理</h4><p><code>+ (void)sendAsynchronousRequest:(NSURLRequest*) request queue:(NSOperationQueue*) queue completionHandler:(void (^)(NSURLResponse* __nullable response, NSData* __nullable data, NSError* __nullable connectionError)) handler</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 发送异步请求</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)async</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 0.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[[<span class="built_in">NSOperationQueue</span> alloc] init] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="comment">// 请求完毕会来到这个block</span></span><br><span class="line">        <span class="comment">// 3.解析服务器返回的数据(解析成字符串)</span></span><br><span class="line">        <span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, string);</span><br><span class="line">        <span class="built_in">NSHTTPURLResponse</span> *r = (<span class="built_in">NSHTTPURLResponse</span> *)response;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd %@"</span>, r<span class="variable">.statusCode</span>, r<span class="variable">.allHeaderFields</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认会开启线程执行异步请求:">默认会开启线程执行异步请求:</h4><p><code>+ (nullable NSURLConnection*)connectionWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate</code><br><code>- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate</code><br><code>- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate startImmediately:(BOOL)startImmediately</code><br>在startImmediately = NO的情况下,需要调用start方法开始发送请求<br><code>- (void)start</code><br>成为NSURLConnection的代理,最好遵守NSURLConnectionDataDelegate协议<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)delegateAysnc</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 0.请求路径</span></span><br><span class="line">	<span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.创建请求对象</span></span><br><span class="line">	<span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.创建连接对象</span></span><br><span class="line">    <span class="comment">//[[NSURLConnection alloc] initWithRequest:request delegate:self];</span></span><br><span class="line">    <span class="comment">//不是马上发请求,startImmediately如果是YES就不需要strat</span></span><br><span class="line">    <span class="comment">//NSURLConnection *conn = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO];</span></span><br><span class="line">    <span class="comment">//[conn start];</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURLConnection</span> *conn = [<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消</span></span><br><span class="line">    <span class="comment">//[conn cancel];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 接收到服务器的响应</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建data对象</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.responseData</span> = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveResponse"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 接收到服务器的数据(如果数据量比较大,这个方法会被调用多次)</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不断拼接服务器返回的数据</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.responseData</span> appendData:data];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveData -- %zd"</span>, data<span class="variable">.length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 服务器的数据成功接收完毕(回调到主线程)</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"connectionDidFinishLoading"</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithData:<span class="keyword">self</span><span class="variable">.responseData</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, string);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.responseData</span> = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 请求失败(比如请求超时)</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didFailWithError -- %@"</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="NSMutableURLRequest">NSMutableURLRequest</h4><ul>
<li><p>NSMutableURLRequest是NSURLRequest的子类,常用方法有:</p>
<ul>
<li><p>设置请求超时等待时间(超过这个时间就算超时,请求失败)<br><code>- (void)setTimeoutInterval:(NSTimeInterval)seconds;</code></p>
</li>
<li><p>设置请求方法(比如GET和POST)<br><code>- (void)setHTTPMethod:(NSString *)method;</code></p>
</li>
<li><p>设置请求体<br><code>- (void)setHTTPBody:(NSData *)data;</code></p>
</li>
<li><p>设置请求头<br><code>- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;</code><br><code>- (void)addValue:(NSString *)value forHTTPHeaderField:(NSString *)field;</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// 1.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/login"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.创建请求</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改请求方法</span></span><br><span class="line">    request<span class="variable">.HTTPMethod</span> = <span class="string">@"POST"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求体</span></span><br><span class="line">    request<span class="variable">.HTTPBody</span> = [<span class="string">@"xxx"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时(5秒后超时)</span></span><br><span class="line">    request<span class="variable">.timeoutInterval</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    [request setValue:<span class="string">@"iOS 9.0"</span> forHTTPHeaderField:<span class="string">@"User-Agent"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connectionError) &#123; <span class="comment">// 比如请求超时</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"----请求失败"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"------%@"</span>, [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="JSON解析方案">JSON解析方案</h4><ul>
<li><p>在iOS中,JSON的常见解析方式有4种</p>
<ul>
<li>第三方框架:JSONKit、SBJson、TouchJSON(性能从左到右,越差)</li>
<li>苹果原生(自带):NSJSONSerialization(性能最好)</li>
</ul>
</li>
<li><p>NSJSONSerialization的常见方法</p>
<ul>
<li><p>JSON数据 -&gt; OC对象<br><code>+ (nullable id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error;</code></p>
</li>
<li><p>OC对象 -&gt; JSON数据<br><code>+ (nullable NSData *)dataWithJSONObject:(id)obj options:(NSJSONWritingOptions)opt error:(NSError **)error;</code></p>
</li>
<li><p>log输出的时候如果JSON中有中文会显示不出来,可以重写NSDictionary和NSArray的<code>- (NSString *)descriptionWithLocale:(id)locale</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">@implementation NSDictionary (Log)</span><br><span class="line">- (NSString *)descriptionWithLocale:(id)locale</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableString *string = [NSMutableString string];</span><br><span class="line">    </span><br><span class="line">    // 开头有个&#123;</span><br><span class="line">    [string appendString:@"&#123;\n"];</span><br><span class="line">    </span><br><span class="line">    // 遍历所有的键值对</span><br><span class="line">    [self enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        [string appendFormat:@"\t%@", key];</span><br><span class="line">        [string appendString:@" : "];</span><br><span class="line">        [string appendFormat:@"%@,\n", obj];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 结尾有个&#125;</span><br><span class="line">    [string appendString:@"&#125;"];</span><br><span class="line">    </span><br><span class="line">    // 查找最后一个逗号</span><br><span class="line">    NSRange range = [string rangeOfString:@"," options:NSBackwardsSearch];</span><br><span class="line">    if (range.location != NSNotFound)</span><br><span class="line">    [string deleteCharactersInRange:range];</span><br><span class="line">    </span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSArray (Log)</span><br><span class="line"></span><br><span class="line">- (NSString *)descriptionWithLocale:(id)locale</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableString *string = [NSMutableString string];</span><br><span class="line">    </span><br><span class="line">    // 开头有个[</span><br><span class="line">    [string appendString:@"[\n"];</span><br><span class="line">    </span><br><span class="line">    // 遍历所有的元素</span><br><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">        [string appendFormat:@"\t%@,\n", obj];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 结尾有个]</span><br><span class="line">    [string appendString:@"]"];</span><br><span class="line">    </span><br><span class="line">    // 查找最后一个逗号</span><br><span class="line">    NSRange range = [string rangeOfString:@"," options:NSBackwardsSearch];</span><br><span class="line">    if (range.location != NSNotFound)</span><br><span class="line">    [string deleteCharactersInRange:range];</span><br><span class="line">    </span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="iOS中的XML解析">iOS中的XML解析</h4><ul>
<li><p>苹果原生</p>
<ul>
<li>NSXMLParser:SAX方式解析</li>
</ul>
</li>
<li><p>第三方框架</p>
<ul>
<li>libxml2:纯C语言,默认包含在iOS SDK中,同时支持DOM和SAX方式解析</li>
<li>GDataXML:DOM方式解析,由Google开发,基于libxml2</li>
</ul>
</li>
<li><p>XML解析方式的选择建议</p>
<ul>
<li>大文件:NSXMLParser、libxml2</li>
<li>小文件:GDataXML、NSXMLParser、libxml2</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *GDataXML</span><br><span class="line"> */</span>	</span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="comment">// 加载整个文档</span></span><br><span class="line">        GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data options:<span class="number">0</span> error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得所有video元素</span></span><br><span class="line">        <span class="built_in">NSArray</span> *elements = [doc<span class="variable">.rootElement</span> elementsForName:<span class="string">@"video"</span>];</span><br><span class="line">        <span class="keyword">for</span> (GDataXMLElement *ele <span class="keyword">in</span> elements) &#123;</span><br><span class="line">            XMGVideo *video = [[XMGVideo alloc] init];</span><br><span class="line">            video<span class="variable">.name</span> = [ele attributeForName:<span class="string">@"name"</span>]<span class="variable">.stringValue</span>;</span><br><span class="line">            video<span class="variable">.url</span> = [ele attributeForName:<span class="string">@"url"</span>]<span class="variable">.stringValue</span>;</span><br><span class="line">            video<span class="variable">.image</span> = [ele attributeForName:<span class="string">@"image"</span>]<span class="variable">.stringValue</span>;</span><br><span class="line">            video<span class="variable">.length</span> = [ele attributeForName:<span class="string">@"length"</span>]<span class="variable">.stringValue</span><span class="variable">.integerValue</span>;</span><br><span class="line">            </span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.videos</span> addObject:video];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *NSXMLParser</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://120.25.226.186:32812/video?type=XML"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="comment">// 创建XML解析器</span></span><br><span class="line">        <span class="built_in">NSXMLParser</span> *parser = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:data];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置代理</span></span><br><span class="line">        parser<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始解析XML</span></span><br><span class="line">        [parser parse];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新表格</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.tableView</span> reloadData];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSXMLParserDelegate&gt;</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 解析到某个元素的结尾（比如解析&lt;/videos&gt;）</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser didEndElement:(<span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="built_in">NSString</span> *)qName</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    NSLog(@"didEndElement - %@", elementName);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 解析到某个元素的开头（比如解析&lt;videos&gt;）</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser didStartElement:(<span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="built_in">NSString</span> *)qName attributes:(<span class="built_in">NSDictionary</span> *)attributeDict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([elementName isEqualToString:<span class="string">@"videos"</span>]) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//    XMGVideo *video = [[XMGVideo alloc] init];</span></span><br><span class="line"><span class="comment">//    video.keyValues = attributeDict;</span></span><br><span class="line">    </span><br><span class="line">    MCVideo *video = [MCVideo objectWithKeyValues:attributeDict];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.videos</span> addObject:video];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 开始解析XML文档</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)parserDidStartDocument:(<span class="built_in">NSXMLParser</span> *)parser</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    NSLog(@"parserDidStartDocument");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 解析完毕</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)parserDidEndDocument:(<span class="built_in">NSXMLParser</span> *)parser</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    NSLog(@"parserDidEndDocument");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小文件下载">小文件下载</h4><ul>
<li><p>如果文件比较小,下载方式会比较多</p>
<ul>
<li>直接用NSData的<code>+ (id)dataWithContentsOfURL:(NSURL *)url;</code></li>
<li>利用NSURLConnection发送一个HTTP请求去下载</li>
<li>如果是下载图片,还可以利用SDWebImage框架</li>
</ul>
</li>
<li><p>如果是大文件下载,建议使用NSURLSession或者第三方框架</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#define MCFile [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@<span class="title">"minion_15.mp4"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSURLConnectionDataDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIProgressView</span> *progressView;</span><br><span class="line"><span class="comment">/** 文件的总长度 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> contentLength;</span><br><span class="line"><span class="comment">/** 当前下载的总长度 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> currentLength;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 文件句柄对象 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSFileHandle</span> *handle;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxxx/resources/videos/minion_15.mp4"</span>];</span><br><span class="line">    [<span class="built_in">NSURLConnection</span> connectionWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:url] delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLConnectionDataDelegate&gt;</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 接收到响应的时候：创建一个空的文件</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得文件的总长度</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.contentLength</span> = [response<span class="variable">.allHeaderFields</span>[<span class="string">@"Content-Length"</span>] integerValue];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个空的文件</span></span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] createFileAtPath:M<span class="built_in">CFile</span> contents:<span class="literal">nil</span> attributes:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建文件句柄</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.handle</span> = [<span class="built_in">NSFileHandle</span> fileHandleForWritingAtPath:XMGFile];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 接收到具体数据:马上把数据写入一开始创建好的文件</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 指定数据的写入位置 -- 文件内容的最后面</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.handle</span> seekToEndOfFile];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.handle</span> writeData:data];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拼接总长度</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.currentLength</span> += data<span class="variable">.length</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进度</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.progressView</span><span class="variable">.progress</span> = <span class="number">1.0</span> * <span class="keyword">self</span><span class="variable">.currentLength</span> / <span class="keyword">self</span><span class="variable">.contentLength</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 关闭handle</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.handle</span> closeFile];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.handle</span> = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空长度</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.currentLength</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="第三方解压缩框架—SSZipArchive">第三方解压缩框架—SSZipArchive</h4><ul>
<li>下载地址:<a href="https://github.com/ZipArchive/ZipArchive" target="_blank" rel="external">https://github.com/ZipArchive/ZipArchive</a></li>
</ul>
<h4 id="文件上传步骤">文件上传步骤</h4><ul>
<li><p>设置请求头<br><code>[request setValue:@&quot;multipart/form-data;boundary=分隔线&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</code></p>
</li>
<li><p>设置请求体</p>
<ul>
<li><p>非文件参数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">--分隔线\r\n(为了支持不同平台,有些平台只有\r而有些是\n,为了统一所以这样做)</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"参数名"</span>\r\n</span><br><span class="line">\r\n</span><br><span class="line">参数值</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件参数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">--分隔线\r\n(为了支持不同平台,有些平台只有\r而有些是\n,为了统一所以这样做)</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"参数名"</span>;filename=<span class="string">"文件名"</span>\r\n</span><br><span class="line">Content-Type:文件的MIMEType\r\n</span><br><span class="line">\r\n</span><br><span class="line">文件数据</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数结束的标记<br><code>--分隔线--\r\n</code></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#define MCBoundary @<span class="title">"mc"</span></span></span><br><span class="line"><span class="preprocessor">#define MCEncode(string) [string dataUsingEncoding:NSUTF8StringEncoding]</span></span><br><span class="line"><span class="preprocessor">#define MCNewLine [@<span class="title">"\r\n"</span> dataUsingEncoding:NSUTF8StringEncoding]</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建请求</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://120.25.226.186:32812/upload"</span>];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    request<span class="variable">.HTTPMethod</span> = <span class="string">@"POST"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求头(告诉告诉服务器,这是一个文件上传的请求)</span></span><br><span class="line">    [request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"multipart/form-data; boundary=%@"</span>, MCBoundary] forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求体</span></span><br><span class="line">    <span class="built_in">NSMutableData</span> *body = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件参数</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     --分割线\r\n</span><br><span class="line">     Content-Disposition: form-data; name="参数名"; filename="文件名"\r\n</span><br><span class="line">     Content-Type: 文件的MIMEType\r\n</span><br><span class="line">     \r\n</span><br><span class="line">     文件数据</span><br><span class="line">     \r\n</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">// 分割线</span></span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCEncode(MCBoundary)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件参数名</span></span><br><span class="line">    [body appendData:MCEncode([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Content-Disposition: form-data; name=\"file\"; filename=\"test.png\""</span>])];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件的类型</span></span><br><span class="line">    [body appendData:MCEncode([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Content-Type: image/png"</span>])];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件数据</span></span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    <span class="comment">//UIImageJPEGRepresentation(&lt;#UIImage *image#&gt;, &lt;#CGFloat compressionQuality#&gt;)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>];</span><br><span class="line">    [body appendData:<span class="built_in">UIImagePNGRepresentation</span>(image)];</span><br><span class="line">    <span class="comment">//[body appendData:[NSData dataWithContentsOfFile:@"/Users/weifeng/Desktop/test.png"]];</span></span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非文件参数</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     --分割线\r\n</span><br><span class="line">     Content-Disposition: form-data; name="参数名"\r\n</span><br><span class="line">     \r\n</span><br><span class="line">     参数值</span><br><span class="line">     \r\n</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">// 分割线</span></span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCEncode(MCBoundary)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数名</span></span><br><span class="line">    [body appendData:MCEncode([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Content-Disposition: form-data; name=\"username\""</span>])];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数值</span></span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"jack"</span>)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束标记</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     --分割线--\r\n</span><br><span class="line">     */</span></span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCEncode(MCBoundary)];</span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    request<span class="variable">.HTTPBody</span> = body;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="将NSData写入文件的几种方式">将NSData写入文件的几种方式</h4><ul>
<li>NSFileHandle</li>
<li>NSOutputStream</li>
<li>NSData的实例方法<code>- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSURLConnectionDataDelegate</span>&gt;</span></span><br><span class="line"><span class="comment">/** 输出流对象 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOutputStream</span> *stream;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSURLConnection</span> connectionWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxxx/resources/videos/minion_01.mp4"</span>]] delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLConnectionDataDelegate&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// response.suggestedFilename : 服务器那边的文件名</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *caches = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">    <span class="built_in">NSString</span> *file = [caches stringByAppendingPathComponent:response<span class="variable">.suggestedFilename</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, file);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用NSOutputStream往Path中写入数据（append为YES的话，每次写入都是追加到文件尾部）</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.stream</span> = [[<span class="built_in">NSOutputStream</span> alloc] initToFileAtPath:file append:<span class="literal">YES</span>];</span><br><span class="line">    <span class="comment">// 打开流(如果文件不存在，会自动创建)</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.stream</span> open];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.stream</span> write:[data bytes] maxLength:data<span class="variable">.length</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveData-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.stream</span> close];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="子线程中处理回调数据">子线程中处理回调数据</h4><ul>
<li><p>有时候我们想要让接收到的数据放在子线程中处理,比如写文件操作.这个时候可以通过NSURLConnection的<code>- (void)setDelegateQueue:(nullable NSOperationQueue*) queue</code></p>
</li>
<li><p>处理NSURLConnection的<code>+ (nullable NSURLConnection*)connectionWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate</code>放在子线程中并不会执行的问题.</p>
<blockquote>
<p>NSURLConnection跟RunLoop有关系,一旦请求发出去,一直等待服务器请求回来,一点一点接收数据,有一个运行循环等待数据,它是在RunLoop中接收返回数据的.NSURLConnection内部会关联当前线程对应的RunLoop,不断给当前线程的RunLoop发送消息,RunLoop一旦接收到Source,紧接着会去处理.<br>子线程为什么会不好使呢?<br>因为子线程的RunLoop默认是不启动的<br>解决办法就是在子线程中手动启动RunLoop,也需要手动去停止</p>
</blockquote>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSURLConnection</span> *conn = [<span class="built_in">NSURLConnection</span> connectionWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxxx/resources/images/minion_01.png"</span>]] delegate:<span class="keyword">self</span>];</span><br><span class="line">        <span class="comment">// 决定代理方法在哪个队列中执行</span></span><br><span class="line">        [conn setDelegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动子线程的runLoop</span></span><br><span class="line">        <span class="comment">//[[NSRunLoop currentRunLoop] run];</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span><span class="variable">.runLoop</span> = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动runLoop</span></span><br><span class="line">        <span class="built_in">CFRunLoopRun</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLConnectionDataDelegate&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveResponse----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveData----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"connectionDidFinishLoading----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 停止RunLoop</span></span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="keyword">self</span><span class="variable">.runLoop</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NSString和NSData的互相转换">NSString和NSData的互相转换</h4><ul>
<li><p>NSString -&gt; NSData<br><code>NSData *data = [@&quot;&quot; dataUsingEncoding:NSUTF8StringEncoding]</code></p>
</li>
<li><p>NSData -&gt; NSString<br><code>NSString *str = [[NSString alloc] initWithData:dataEncoding:NSUTF8StringEncoding];</code></p>
</li>
</ul>
<h4 id="NSURLSession">NSURLSession</h4><ul>
<li>使用步骤<ul>
<li>使用NSURLSession对象创建Task,然后执行Task</li>
<li>Task的类型:NSURLSessionTask、NSURLSessionDataTask、NSURLSessionDownloadTask、NSURLSessionUploadTask</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)download</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得下载任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDownloadTask</span> *task = [session downloadTaskWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/resources/videos/minion_01.mp4"</span>] completionHandler:^(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="comment">// 文件将来存放的真实路径</span></span><br><span class="line">        <span class="built_in">NSString</span> *file = [[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:response<span class="variable">.suggestedFilename</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 剪切location的临时文件到真实路径</span></span><br><span class="line">        <span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">        [mgr moveItemAtURL:location toURL:[<span class="built_in">NSURL</span> fileURLWithPath:file] error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)post</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建请求</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/login"</span>]];</span><br><span class="line">    request<span class="variable">.HTTPMethod</span> = <span class="string">@"POST"</span>; <span class="comment">// 请求方法</span></span><br><span class="line">    request<span class="variable">.HTTPBody</span> = [<span class="string">@"xxx"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]; <span class="comment">// 请求体</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/login?username=xxx&amp;pwd=xxx"</span>]] completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//NSURLSessionDataTask *task = [session dataTaskWithURL:[NSURL URLWithString:@"http://xxx/login?username=xxx&amp;pwd=xxx"] completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NSURLSession代理方法">NSURLSession代理方法</h4><ul>
<li>NSURLSession的NSURLSessionDataDelegate代理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSURLSessionDataDelegate</span>, <span class="title">NSURLConnectionDataDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/login?username=xxx&amp;pwd=xxx"</span>]]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLSessionDataDelegate&gt;</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 1.接收到服务器的响应</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span>))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许处理服务器的响应,才会继续接收服务器返回的数据</span></span><br><span class="line">    completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// void (^)(NSURLSessionResponseDisposition)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 2.接收到服务器的数据（可能会被调用多次）</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 3.请求成功或者失败（如果失败,error有值）</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="大文件下载">大文件下载</h4><ul>
<li>NSURLSessionDownloadDelegate代理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSURLSessionDownloadDelegate</span>&gt;</span></span><br><span class="line"><span class="comment">/** 下载任务 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDownloadTask</span> *task;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 开始下载</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)start:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得下载任务</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.task</span> = [session downloadTaskWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/resources/videos/minion_01.mp4"</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.task</span> resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 暂停下载</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)pause:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.task</span> suspend];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 继续下载</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)goOn:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.task</span> resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLSessionDownloadDelegate&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didCompleteWithError"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didResumeAtOffset"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 每当写入数据到临时文件时,就会调用一次这个方法</span><br><span class="line"> * totalBytesExpectedToWrite:总大小</span><br><span class="line"> * totalBytesWritten: 已经写入的大小</span><br><span class="line"> * bytesWritten: 这次写入多少</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------%f"</span>, <span class="number">1.0</span> * totalBytesWritten / totalBytesExpectedToWrite);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * </span><br><span class="line"> * 下载完毕就会调用一次这个方法</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 文件将来存放的真实路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *file = [[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:downloadTask<span class="variable">.response</span><span class="variable">.suggestedFilename</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 剪切location的临时文件到真实路径</span></span><br><span class="line">    <span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    [mgr moveItemAtURL:location toURL:[<span class="built_in">NSURL</span> fileURLWithPath:file] error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="NSURLSessionTask">NSURLSessionTask</h4><ul>
<li>常见方法<ul>
<li><code>- (void)suspend;</code></li>
<li><code>- (void)resume;</code></li>
<li><code>- (void)cancel;</code></li>
<li><code>@property (nullable, readonly, copy) NSError *error;</code></li>
<li><code>@property (nullable, readonly, copy) NSURLResponse *response;</code></li>
</ul>
</li>
</ul>
<h4 id="文件上传">文件上传</h4><p><code>- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData completionHandler:(void (^)(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error))completionHandler;</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#define MCBoundary @<span class="title">"520it"</span></span></span><br><span class="line"><span class="preprocessor">#define MCEncode(string) [string dataUsingEncoding:NSUTF8StringEncoding]</span></span><br><span class="line"><span class="preprocessor">#define MCNewLine [@<span class="title">"\r\n"</span> dataUsingEncoding:NSUTF8StringEncoding]</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () </span></span><br><span class="line"><span class="comment">/** session */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> *session;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_session) &#123;</span><br><span class="line">        <span class="built_in">NSURLSessionConfiguration</span> *cfg = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">        cfg<span class="variable">.timeoutIntervalForRequest</span> = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 是否允许使用蜂窝网络（手机自带网络）</span></span><br><span class="line">        cfg<span class="variable">.allowsCellularAccess</span> = <span class="literal">YES</span>;</span><br><span class="line">        _session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:cfg];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/upload"</span>]];</span><br><span class="line">    request<span class="variable">.HTTPMethod</span> = <span class="string">@"POST"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求头(告诉服务器,这是一个文件上传的请求)</span></span><br><span class="line">    [request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"multipart/form-data; boundary=%@"</span>, MCBoundary] forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求体</span></span><br><span class="line">    <span class="built_in">NSMutableData</span> *body = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件参数</span></span><br><span class="line">    <span class="comment">// 分割线</span></span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCEncode(MCBoundary)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件参数名</span></span><br><span class="line">    [body appendData:MCEncode([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Content-Disposition: form-data; name=\"file\"; filename=\"test.png\""</span>])];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件的类型</span></span><br><span class="line">    [body appendData:MCEncode([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Content-Type: image/png"</span>])];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件数据</span></span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    [body appendData:[<span class="built_in">NSData</span> dataWithContentsOfFile:<span class="string">@"/Users/weifeng/Desktop/test.png"</span>]];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束标记</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     --分割线--\r\n</span><br><span class="line">     */</span></span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCEncode(MCBoundary)];</span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    [[<span class="keyword">self</span><span class="variable">.session</span> uploadTaskWithRequest:request fromData:body completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"-------%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;] resume];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="NSURLConnection">NSURLConnection</h3><h4 id="常用类">常用类</h4><ul>
<li><p>NSURL:请求地址</p>
</li>
<li><p>NSURLRequest:一个NSURLRequest对象就代表一个请求,它包含的信息有</p>
<ul>
<li>一个NSURL对象</li>
<li>请求方法、请求头、请求体</li>
<li>请求超时</li>
<li>…</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[RunLoop的基本使用]]></title>
    <link href="http://yoursite.com/2016/03/25/nsrunloop/"/>
    <id>http://yoursite.com/2016/03/25/nsrunloop/</id>
    <published>2016-03-25T07:52:46.000Z</published>
    <updated>2016-04-03T10:13:28.000Z</updated>
    <content type="html"><![CDATA[<h3 id="什么是RunLoop">什么是RunLoop</h3><ul>
<li>从字面意思看<ul>
<li>运行循环</li>
<li>跑圈</li>
</ul>
</li>
<li>基本作用<ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件(比如触摸事件、定时器事件、Selector事件)</li>
<li>节省CPU资源,提高程序性能:该做事情时做事情,该休息时休息</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h4 id="main函数中的RunLoop">main函数中的RunLoop</h4><ul>
<li>UIApplicationMain函数内部就启动了一个RunLoop</li>
<li>所以UIApplicationMain函数一直没有返回,保持程序的持续运行</li>
<li>这个默认启动的RunLoop是跟主线程相关联的</li>
</ul>
<h4 id="RunLoop对象">RunLoop对象</h4><ul>
<li><p>iOS中有2套API来访问和使用RunLoop</p>
<ul>
<li>Foundation <ul>
<li>NSRunLoop</li>
</ul>
</li>
<li>Core Foundation <ul>
<li>CFRunLoopRef</li>
</ul>
</li>
</ul>
</li>
<li><p>NSRunLoop和CFRunLoopRef都代表着RunLoop对象</p>
</li>
<li><p>NSRunLoop是基于CFRunLoopRef的一层OC包装,所以要了解RunLoop内部结构,需要多研究CFRunLoopRef层面的API</p>
</li>
</ul>
<h4 id="RunLoop与线程">RunLoop与线程</h4><ul>
<li><p>每条线程都有唯一的一个与之对应的RunLoop对象</p>
</li>
<li><p>主线程的RunLoop已经创建好了,子线程的RunLoop需要主动创建</p>
</li>
<li><p>RunLoop在第一次获取的时候创建,在线程结束的时候销毁</p>
</li>
</ul>
<h4 id="获取RunLoop">获取RunLoop</h4><ul>
<li>获取当前线程的RunLoop:<code>+ (NSRunLoop *)currentRunLoop;</code></li>
<li>获取主线程的RunLoop:<code>+ (NSRunLoop *)mainRunLoop;</code></li>
<li>获取当前线程的RunLoop:<code>CFRunLoopGetCurrent();</code></li>
<li>获取主线程的RunLoop:<code>CFRunLoopGetMain();</code></li>
</ul>
<h4 id="RunLoop相关类">RunLoop相关类</h4><ul>
<li>Core Foundation中关于RunLoop的5个类<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
</li>
</ul>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/runloop.png" alt=""></p>
<h4 id="CFRunLoopModeRef">CFRunLoopModeRef</h4><ul>
<li><p>CFRunLoopModeRef代表RunLoop的运行模式</p>
</li>
<li><p>一个RunLoop包含若干个Mode,每个Mode又包含若干个Source/Timer/Observer</p>
</li>
<li><p>每次RunLoop启动时,只能指定其中一个Mode,这个Mode被称作CurrentMode<br><code>[[NSRunLoop currentRunLoop] currentMode];</code></p>
</li>
<li><p>如果需要切换Mode,只能退出Loop,再重新指定一个Mode进入</p>
</li>
<li><p>这样做主要是为了分隔开不同组Source/Timer/Observer,让其互不影响</p>
</li>
<li><p>系统默认注册了5个Mode:</p>
<ul>
<li>kCFRunLoopDefaultMode:App的默认Mode,通常主线程是这个Mode下运行</li>
<li>UITrackingRunLoop:界面跟踪Mode,用于ScrollView追踪触摸滑动,保证界面滑动时不受其他Mode影响</li>
<li>UIInitializationRunLoopMode:在刚启动App时进入的第一个Mode,启动完成后就不再使用</li>
<li>GSEventReceiverRunLoopMode:接收系统事件的内部Mode,通常用不到</li>
<li>kCFRunLoopCommonModes:这是一个占位用的Mode,不是一种真正的Mode(等价于kCFRunLoopDefaultMode + UITrackingRunLoop这2种模式)</li>
</ul>
</li>
<li><p>子线程中需要手动创建并启动NSRunLoop</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">NSRunLoop</span> mainRunLoop];</span><br><span class="line">    [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">    <span class="built_in">CFRunLoopGetMain</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line">	[thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">		<span class="comment">// add Source</span></span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[<span class="built_in">NSPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">		<span class="comment">//add Timer</span></span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这句相当于下面那句,如果RunLoop中没有Source、Timer、Observer那么这个RunLoop会自动结束并退出</span></span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">	    </span><br><span class="line">	    [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:&lt;<span class="preprocessor">#(NSString *)#&gt; beforeDate:<span class="title">&lt;#(NSDate *)#&gt;</span>];</span></span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CFRunLoopTimerRef">CFRunLoopTimerRef</h4><ul>
<li>CFRunLoopTimerRef是基于时间的触发器</li>
<li>CFRunLoopTimerRef基本上说的就是NSTimer,它受RunLoop的Mode影响</li>
<li>GCD的定时器不受RunLoop的Mode影响</li>
<li>基本上说的就是NSTimer</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用了scheduledTimer返回的定时器,已经自动被添加到当前RunLoop中,而且是NSDefaultRunLoopMode模式</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 修改模式</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];等价于下面2句</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 定时器只运行在NSDefaultRunLoopMode下,一旦RunLoop进入其他模式,这个定时器就不会工作</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器会跑在标记为common modes的模式下</span></span><br><span class="line"><span class="comment">// 标记为common modes的模式: UITrackingRunLoopMode和kCFRunLoopDefaultMode</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器只运行在UITrackingRunLoopMode下,一旦RunLoop进入其他模式,这个定时器就不会工作</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">UITrackingRunLoopMode</span>];</span><br></pre></td></tr></table></figure>
<h4 id="CFRunLoopSourceRef">CFRunLoopSourceRef</h4><ul>
<li><p>CFRunLoopSourceRef是事件源(输入源)</p>
</li>
<li><p>按照官方文档,Source的分类</p>
<ul>
<li>Port-Based Sources</li>
<li>Custom Input Sources</li>
<li>Cocoa Perform Selector Sources</li>
</ul>
</li>
<li><p>按照函数调用栈,Source的分类</p>
<ul>
<li>Source0:非基于Port</li>
<li>Source1:基于Port的,通过内核和其他线程通信,接收、分发系统事件</li>
</ul>
</li>
</ul>
<h4 id="CFRunLoopObserverRef">CFRunLoopObserverRef</h4><ul>
<li><p>CFRunLoopObserverRef是观察者,能够监听RunLoop的状态改变</p>
</li>
<li><p>可以监听的时间点有以下几个</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    k<span class="built_in">CFRunLoopEntry</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">//1 即将进入Loop </span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeTimers</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">//2 即将处理Timer </span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeSources</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">//4 即将处理Source </span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeWaiting</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">//32 即将进入休眠</span></span><br><span class="line">    k<span class="built_in">CFRunLoopAfterWaiting</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">//64 刚从休眠中唤醒</span></span><br><span class="line">    k<span class="built_in">CFRunLoopExit</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">//128 即将退出Loop</span></span><br><span class="line">    k<span class="built_in">CFRunLoopAllActivities</span> = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建observer</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), k<span class="built_in">CFRunLoopAllActivities</span>, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----监听到RunLoop状态发生改变---%zd"</span>, activity);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者:监听RunLoop的状态</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, k<span class="built_in">CFRunLoopDefaultMode</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    CF的内存管理（Core Foundation）</span><br><span class="line">    1.凡是带有Create、Copy、Retain等字眼的函数,创建出来的对象,都需要在最后做一次release</span><br><span class="line">    * 比如CFRunLoopObserverCreate</span><br><span class="line">    2.release函数:CFRelease(对象);</span><br><span class="line"> 	*/</span></span><br><span class="line">    <span class="comment">// 释放Observer</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/runloop_1.png" alt=""></p>
<h4 id="RunLoop应用">RunLoop应用</h4><ul>
<li>NSTimer</li>
<li>ImageView显示</li>
<li>PerformSelector</li>
<li>常驻线程</li>
<li>自动释放池</li>
</ul>
<h4 id="RunLoop面试题">RunLoop面试题</h4><ul>
<li>什么是RunLoop?<ul>
<li>从字面意思看:运行循环、跑圈</li>
<li>其实它内部就是do-while循环,在这个循环内部不断地处理各种任务(比如Source、Timer、Observer)</li>
<li>一个线程对应一个RunLoop,主线程的RunLoop默认已经启动,子线程的RunLoop得手动启动(调用Run方法)</li>
<li>RunLoop只能选择一个Mode启动,如果当前Mode中没有任何Source(Sources0、Sources1)、Timer,那么久直接退出RunLoop</li>
</ul>
</li>
</ul>
<ul>
<li>你在开发过程中怎么使用RunLoop?什么应用场景?<ul>
<li>开启一个常驻线程(让一个子线程不进入消亡状态,等待其他线程发来消息,处理其他事件)<ul>
<li>在子线程中开启一个定时器</li>
<li>在子线程中进行一些长期监控一些行为</li>
</ul>
</li>
<li>可以控制定时器在特定模式下执行</li>
<li>可以让某些事件(行为、任务)在特定模式下执行</li>
<li>可以添加Observer监听RunLoop的状态,比如监听点击事件的处理(在所有点击事件之前做一些事情)</li>
</ul>
</li>
</ul>
<ul>
<li>自动释放池什么时候释放?<ul>
<li>通过Observer监听RunLoop的状态,一旦监听到RunLoop即将进入睡眠等待状态,就释放自动释放池(kCFRunLoopBeforeWaiting)</li>
<li>监听了3个地方activity = 0x1(kCFRunLoopEntry) 、 0xa0(kCFRunLoopBeforeWaiting | kCFRunLoopExit ) -&gt;(kCFRunLoopEntry创建一个自动释放池、kCFRunLoopBeforeWaiting销毁自动释放池,创建一个新的自动释放池、kCFRunLoopExit 销毁自动释放池)</li>
</ul>
</li>
</ul>
<h4 id="GCD定时器">GCD定时器</h4><ul>
<li><p>创建GCD定时器 <code>dispatch_source_t dispatch_source_create(dispatch_source_type_t type,uintptr_t handle,unsigned long mask,dispatch_queue_t queue);</code></p>
</li>
<li><p>设置定时器的各种属性 <code>dispatch_source_set_timer(dispatch_source_t source,dispatch_time_t start,uint64_t interval,uint64_t leeway);</code></p>
</li>
<li><p>设置定时器处理任务 <code>dispatch_source_set_event_handler(dispatch_source_t source,dispatch_block_t handler);</code></p>
</li>
<li><p>启动定时器 <code>dispatch_resume(dispatch_object_t object);</code></p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="comment">/** 定时器(这里不用带*,因为dispatch_source_t就是个类,内部已经包含了*) */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    dispatch_time_t when = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">    </span><br><span class="line">    dispatch_after(when, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得队列</span></span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//dispatch_queue_t queue = dispatch_get_main_queue();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个定时器(dispatch_source_t本质还是个OC对象)</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.timer</span> = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置定时器的各种属性(何时开始任务,每隔多长时间执行一次)</span></span><br><span class="line">    <span class="comment">// GCD的时间参数,一般是纳秒（1秒 == 10的9次方纳秒）</span></span><br><span class="line">    <span class="comment">// 何时开始执行第一个任务</span></span><br><span class="line">    <span class="comment">// dispatch_time(DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC) 比当前时间晚3秒</span></span><br><span class="line">    dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">    uint64_t interval = (uint64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    dispatch_source_set_timer(<span class="keyword">self</span><span class="variable">.timer</span>, start, interval, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置回调</span></span><br><span class="line">    dispatch_source_set_event_handler(<span class="keyword">self</span><span class="variable">.timer</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"------------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">// 取消定时器</span></span><br><span class="line">            dispatch_cancel(<span class="keyword">self</span><span class="variable">.timer</span>);</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.timer</span> = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    dispatch_resume(<span class="keyword">self</span><span class="variable">.timer</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="什么是RunLoop">什么是RunLoop</h3><ul>
<li>从字面意思看<ul>
<li>运行循环</li>
<li>跑圈</li>
</ul>
</li>
<li>基本作用<ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件(比如触摸事件、定时器事件、Selector事件)</li>
<li>节省CPU资源,提高程序性能:该做事情时做事情,该休息时休息</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS单例模式]]></title>
    <link href="http://yoursite.com/2016/03/25/single_instance/"/>
    <id>http://yoursite.com/2016/03/25/single_instance/</id>
    <published>2016-03-25T02:32:46.000Z</published>
    <updated>2016-04-21T12:57:07.000Z</updated>
    <content type="html"><![CDATA[<h3 id="单例模式">单例模式</h3><ul>
<li>单例模式的作用<ul>
<li>可以保证在程序运行过程,一个类只有一个实例,而且该实例易于供外界访问</li>
<li>从而方便地控制了实例个数,并节约系统资源</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li>ARC中,单例模式的实现步骤<ul>
<li>在.m中保留一个全局的static的实例<code>static id _instance;</code></li>
<li><code>+ (instancetype)alloc</code>内部会调用<code>+ (instancetype)allocWithZone:(struct _NSZone *)zone</code></li>
<li>为了防止分配多个内存,我们需要重写NSObject的<code>+ (instancetype)allocWithZone:(struct _NSZone *)zone</code>,但是我们防止不了init多次,在这里创建唯一的实例(注意需要是线程安全的)</li>
<li>使用GCD的<code>static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^{});</code>来创建唯一的实例.</li>
<li>对外提供一个<code>+ (instancetype)sharedInstance</code>类方法来构造一个对象,这个方法中同样使用dispatch_once</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCPerson</span>() &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> MCPerson *_person;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _person = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedPerson</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _person = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将单例的实现抽成宏<ul>
<li>创建一个MCSingleton.h文件,将头文件和实现文件中的方法定义成宏</li>
<li>在使用的地方导入MCSingleton.h文件,头文件中使用MCSingletonH(Person),实现文件中使用MCSingletonM(Person)</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h文件</span></span><br><span class="line"><span class="preprocessor">#define SingletonH(name) + (instancetype)shared##name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m文件</span></span><br><span class="line"><span class="preprocessor">#define SingletonM(name) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance; \</span><br><span class="line"> \</span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone \</span><br><span class="line">&#123; \</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">        _instance = [<span class="keyword">super</span> allocWithZone:zone]; \</span><br><span class="line">    &#125;); \</span><br><span class="line">    <span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line"> \</span><br><span class="line">+ (instancetype)shared<span class="preprocessor">##name \</span></span><br><span class="line">&#123; \</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">        _instance = [[<span class="keyword">self</span> alloc] init]; \</span><br><span class="line">    &#125;); \</span><br><span class="line">    <span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line"> \</span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone \</span><br><span class="line">&#123; \</span><br><span class="line">    <span class="keyword">return</span> _instance; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>传统方式实现单例<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCPerson</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">nil</span>) &#123;</span><br><span class="line">            _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">nil</span>) &#123;</span><br><span class="line">            _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="单例模式">单例模式</h3><ul>
<li>单例模式的作用<ul>
<li>可以保证在程序运行过程,一个类只有一个实例,而且该实例易于供外界访问</li>
<li>从而方便地控制了实例个数,并节约系统资源</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS中的线程]]></title>
    <link href="http://yoursite.com/2016/03/24/gcd/"/>
    <id>http://yoursite.com/2016/03/24/gcd/</id>
    <published>2016-03-24T06:37:39.000Z</published>
    <updated>2016-03-28T13:28:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="多线程的基本概念">多线程的基本概念</h3><ul>
<li>创建线程是有开销的,iOS下主要成本包括:内核数据结构（大约1KB）、栈空间(子线程512KB、主线程1MB,也可以使用-setStackSize:设置,但必须是4K的倍数,而且最小是16K),创建线程大约需要90毫秒的创建时间</li>
</ul>
<h3 id="多线程的实现方案">多线程的实现方案</h3><a id="more"></a>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/thread.png" alt=""></p>
<h3 id="pthread的使用">pthread的使用</h3><p><code>int pthread_create(pthread_t * __restrict, const pthread_attr_t * __restrict,
        void *(*)(void *), void * __restrict);</code><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> * run(<span class="keyword">void</span> *param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">50000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"------buttonClick---%zd--%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)buttonClick:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    pthread_t thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_t thread2;</span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="NSThread的使用">NSThread的使用</h3><ul>
<li>如何创建并管理NSThread</li>
</ul>
<p><code>+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;// 直接创建并启动</code></p>
<p><code>- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0);//创建线程但是没有启动</code></p>
<p><code>+ (NSThread *)currentThread;</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) object:<span class="string">@"jack"</span>];</span><br><span class="line"><span class="comment">// 线程名字</span></span><br><span class="line">thread<span class="variable">.name</span> = <span class="string">@"mc"</span>;</span><br><span class="line"><span class="comment">// thread 是否是主线程</span></span><br><span class="line">[thread isMainThread];</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">[thread start];</span><br><span class="line"><span class="comment">// 取消线程</span></span><br><span class="line">[thread cancel];</span><br><span class="line"><span class="comment">//线程是否正在执行</span></span><br><span class="line">[thread executing];</span><br><span class="line"><span class="comment">//线程是否完成</span></span><br><span class="line">[thread finished];</span><br><span class="line"><span class="comment">//线程是否被取消</span></span><br><span class="line">[thread cancelled];</span><br><span class="line"><span class="comment">// 方法是否在主线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> isMainThread];</span><br><span class="line"><span class="comment">// 直接退出线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> exit]; </span><br><span class="line"><span class="comment">// 让线程睡眠2秒（阻塞2秒）</span></span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">[<span class="built_in">NSThread</span> sleepUntilDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br></pre></td></tr></table></figure>
<ul>
<li><p>NSObject 线程分类</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">NSThreadPerformAdditions</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(nullable <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line">    <span class="comment">// equivalent to the first method with kCFRunLoopCommonModes</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(nullable <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(nullable <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(nullable <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line">    <span class="comment">// equivalent to the first method with kCFRunLoopCommonModes</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(nullable <span class="keyword">id</span>)arg <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取2个时间间隔</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDate</span> *begin = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSDate</span> *end = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, [end timeIntervalSinceDate:begin]);</span><br><span class="line"><span class="built_in">CFTimeInterval</span> begin = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"><span class="built_in">CFTimeInterval</span> end = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, end - begin);</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程安全</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saleTicket&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">@synchronized</span>(<span class="keyword">self</span>)&#123;</span><br><span class="line">            <span class="comment">// 先取出总数</span></span><br><span class="line">            <span class="built_in">NSInteger</span> count = <span class="keyword">self</span><span class="variable">.ticketCount</span>;</span><br><span class="line">             <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">self</span><span class="variable">.ticketCount</span> = count - <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@卖了一张票，还剩下%zd张"</span>, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>, <span class="keyword">self</span><span class="variable">.ticketCount</span>);</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"票已经卖完了"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="GCD">GCD</h3><ul>
<li>全称是Grand Central Dispatch,可译为”牛逼的中枢调度器”</li>
<li>GCD中有2个核心概念:任务-执行什么操作,队列-用来存放任务</li>
<li>GCD的使用就2个步骤<ul>
<li>定制任务(确定想做的事情)</li>
<li>将任务添加到队列中(GCD会自动将队列中的任务取出,放到对应的线程中执行,任务的取出遵循队列的FIFO)</li>
</ul>
</li>
</ul>
<h4 id="执行任务">执行任务</h4><ul>
<li>GCD中有2个用来执行任务的常用函数<ul>
<li>同步的方式执行任务(只能在当前线程中执行任务,不具备开启新线程的能力)<br><code>dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code></li>
<li>异步的方式执行任务(可以在新的线程中执行任务,具备开启新线程的能力)<br><code>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code></li>
<li><code>dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</code>在前面的任务执行结束后它才执行,而且它后面的任务等它执行完成之后才会执行,这个queue不能是全局的并发队列</li>
</ul>
</li>
</ul>
<h4 id="队列的类型">队列的类型</h4><ul>
<li>并发队列<ul>
<li>可以让多个任务并发(同时)执行(自动开启多个线程同时执行任务)</li>
<li>并发功能只有在异步(dispatch_async)函数下才有效</li>
</ul>
</li>
<li>串行队列<ul>
<li>让任务一个接着一个执行</li>
</ul>
</li>
</ul>
<h4 id="并发队列">并发队列</h4><ul>
<li>使用dispatch_queue_create函数创建队列</li>
<li>GCD默认已经提供全局的并发队列,供整个程序使用,可以无需手动创建<ul>
<li>使用dispatch_get_global_queue函数获取全局的并发队列<br><code>dispatch_queue_t
dispatch_get_global_queue(long identifier, unsigned long flags);//identifier队列的优先级  flags此参数无用,用0即可</code></li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 异步函数 + 并发队列:可以同时开启多条线程</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncConcurrent</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建一个并发队列</span></span><br><span class="line"><span class="comment">// label:队列名字</span></span><br><span class="line"><span class="comment">// attr:队列类型-DISPATCH_QUEUE_SERIAL  DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t attr);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span><br><span class="line"><span class="preprocessor">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span><br><span class="line"><span class="preprocessor">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span><br><span class="line"><span class="preprocessor">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br><span class="line"><span class="comment">// 获得全局的并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将任务加入队列</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 同步函数 + 并发队列:不会开启新的线程</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncConcurrent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.获得全局的并发队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 异步函数 + 串行队列:会开启新的线程,但是任务是串行的,执行完一个任务,再执行下一个任务</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncSerial</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建串行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mc.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 同步函数 + 串行队列:不会开启新的线程,在当前线程执行任务。任务是串行的,执行完一个任务,再执行下一个任务</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncSerial</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建串行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mc.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 异步函数 + 主队列:只在主线程中执行任务</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncMain</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.获得主队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 同步函数 + 主队列:导致等待阻塞</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncMain</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 1.获得主队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>线程间通信<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="GCD的其它常用函数">GCD的其它常用函数</h4><ul>
<li><code>dispatch_barrier_async</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)barrier</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"mc"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----2-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----barrier-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----3-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----4-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>一次性代码,使用dispatch_once函数能保证某代码在程序运行过程中只被执行1次</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">//只执行1次的代码(这里是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>延迟执行</p>
<ul>
<li><code>- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</code></li>
<li><code>dispatch_after(dispatch_time_t when,dispatch_queue_t queue,dispatch_block_t block);</code></li>
<li><code>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</code></li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 延迟执行</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)delay</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(run) withObject:<span class="literal">nil</span> afterDelay:<span class="number">2.0</span>];</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"run-----"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>快速迭代: <code>dispatch_apply(size_t iterations, dispatch_queue_t queue,void (^block)(size_t));</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 快速迭代</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)apply</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *from = <span class="string">@"/Users/weifeng/Desktop/From"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *to = <span class="string">@"/Users/weifeng/Desktop/To"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSArray</span> *subpaths = [mgr subpathsAtPath:from];</span><br><span class="line">    </span><br><span class="line">    dispatch_apply(subpaths<span class="variable">.count</span>, queue, ^(size_t index) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *subpath = subpaths[index];</span><br><span class="line">        <span class="built_in">NSString</span> *fromFullpath = [from stringByAppendingPathComponent:subpath];</span><br><span class="line">        <span class="built_in">NSString</span> *toFullpath = [to stringByAppendingPathComponent:subpath];</span><br><span class="line">        <span class="comment">// 剪切</span></span><br><span class="line">        [mgr moveItemAtPath:fromFullpath toPath:toFullpath error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@---%@"</span>, [<span class="built_in">NSThread</span> currentThread], subpath);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列组">队列组</h4><ul>
<li><code>dispatch_group_async(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block);</code><br><code>dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block);</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)group</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建一个队列组</span></span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.下载图片1</span></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.image1</span> = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.下载图片2</span></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://pic38.nipic.com/20140228/5571398_215900721128_2.jpg"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.image2</span> = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.将图片1、图片2合成一张新的图片</span></span><br><span class="line">    dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">        <span class="comment">// 开启新的图形上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制图片</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.image1</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)];</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.image2</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取得上下文中的图片</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结束上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程显示图片</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="comment">// 4.将新图片显示出来 </span></span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NSOperation">NSOperation</h4><ul>
<li><p>NSOperation的作用</p>
<ul>
<li>配合使用NSOperation和NSOperationQueue也能实现多线程编程</li>
</ul>
</li>
<li><p>NSOperation和NSOperationQueue实现多线程的具体步骤</p>
<ul>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperationQueue中NSOperation取出来</li>
<li>将取出的NSOperation封装的操作放到一条新线程中执行</li>
</ul>
</li>
</ul>
<h4 id="NSOperation的子类">NSOperation的子类</h4><ul>
<li><p>NSOperation是个抽象类,并不具备封装操作的能力,必须使用它的子类</p>
</li>
<li><p>使用NSOperation子类的方式有3种</p>
<ul>
<li>NSInvocationOperation</li>
<li>NSBlockOperation</li>
<li>自定义子类继承NSOperation,实现内部相应的方法</li>
</ul>
</li>
<li><p>将任务包装起来调用NSOperation start就可以执行任务了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invocationOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)blockOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="comment">// 在主线程</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载1------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加额外的任务(在子线程执行)</span></span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载2------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载3------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载4------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="NSOperationQueue">NSOperationQueue</h4><ul>
<li>NSOperationQueue的作用<ul>
<li>NSOperation可以调用start方法执行任务,但默认是同步执行的</li>
<li>如果将NSOperation添加到NSOperationQueue(操作队列)中,系统会自动异步执行NSOperation中的操作</li>
</ul>
</li>
</ul>
<h5 id="GCD的队列类型">GCD的队列类型</h5><ul>
<li>并发队列<ul>
<li>自己创建的</li>
<li>全局的</li>
</ul>
</li>
<li>串行队列<ul>
<li>主队列</li>
<li>自己创建的</li>
</ul>
</li>
</ul>
<h5 id="NSOperationQueue的队列类型">NSOperationQueue的队列类型</h5><ul>
<li><p>主队列</p>
<ul>
<li>[NSOperationQueue mainQueue]</li>
<li>凡是添加到主队列中的任务(NSOperation),都会放到主队列中执行</li>
</ul>
</li>
<li><p>非主队列(其它队列)</p>
<ul>
<li>[[NSOperationQueue alloc] init]</li>
<li>同时包含了:串行、并发功能</li>
<li>添加到这种队列中的任务(NSOperation),就会自动放到子线程中执行</li>
</ul>
</li>
<li><p>NSOperationQueue<br><code>- (void)addOperation:(NSOperation *)op;</code><br><code>- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait;</code><br><code>- (void)addOperationWithBlock:(void (^)(void))block;</code><br><code>@property (readonly) NSUInteger operationCount;//任务数量</code><br><code>@property NSInteger maxConcurrentOperationCount;//最大的并发数量,如果设置为1则是串行,为0则不执行任何任务</code><br><code>@property (getter=isSuspended) BOOL suspended;//获取或者设置是否挂起任务</code><br><code>@property (nullable, copy) NSString *name;//获取或者设置队列名字</code><br><code>- (void)cancelAllOperations;//取消所有任务,但是正在执行的不会被取消</code><br><code>- (void)waitUntilAllOperationsAreFinished;</code><br><code>+ (nullable NSOperationQueue *)currentQueue;当前队列</code><br><code>+ (NSOperationQueue *)mainQueue;//主队列</code></p>
</li>
</ul>
<ul>
<li><p>NSInvocationOperation<br><code>- (nullable instancetype)initWithTarget:(id)target selector:(SEL)sel object:(nullable id)arg;</code><br><code>- (instancetype)initWithInvocation:(NSInvocation *)inv</code></p>
</li>
<li><p>NSBlockOperation<br><code>+ (instancetype)blockOperationWithBlock:(void (^)(void))block;</code><br><code>- (void)addExecutionBlock:(void (^)(void))block;</code><br><code>@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks;</code></p>
</li>
<li><p>NSOperation<br><code>- (void)start;//执行任务</code><br><code>- (void)main;//自定义NSOperation需要重写该方法,将任务需要做的事情写到这个方法当中,官方建议在这个方法当中如果有耗时的操作使用isCancelled判断下是否需结束该任务</code><br><code>- (void)cancel;//取消任务</code><br><code>@property (readonly, getter=isExecuting) BOOL executing;</code><br><code>@property (readonly, getter=isFinished) BOOL finished;</code><br><code>- (void)addDependency:(NSOperation *)op;//添加任务依赖</code><br><code>- (void)removeDependency:(NSOperation *)op;//移除任务依赖</code><br><code>@property (nullable, copy) void (^completionBlock)(void);//监听任务的完成会执行这个block</code></p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)operationQueueTest&#123;</span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置最大并发操作数</span></span><br><span class="line">    <span class="comment">// queue.maxConcurrentOperationCount = 2;</span></span><br><span class="line">    queue<span class="variable">.maxConcurrentOperationCount</span> = <span class="number">1</span>; <span class="comment">// 就变成了串行队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建操作(任务)</span></span><br><span class="line">    <span class="comment">// 创建NSInvocationOperation</span></span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(download) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建NSBlockOperation</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download1 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [op1 addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download2 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加操作到队列中</span></span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download3 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加任务到队列中</span></span><br><span class="line">    [queue addOperation:op1]; <span class="comment">// [op1 start]</span></span><br><span class="line">    [queue addOperation:op2]; <span class="comment">// [op2 start]</span></span><br><span class="line">    [queue addOperation:[[MCOperation alloc] init]];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.queue</span><span class="variable">.isSuspended</span>) &#123;</span><br><span class="line">        <span class="comment">// 恢复队列，继续执行</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.queue</span><span class="variable">.suspended</span> = <span class="literal">NO</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 暂停（挂起）队列，暂停执行</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.queue</span><span class="variable">.suspended</span> = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.queue</span> cancelAllOperations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCOperation</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 需要执行的任务</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download1 -%zd-- %@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download2 -%zd-- %@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download3 -%zd-- %@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)operationDependency</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不能相互依赖</span></span><br><span class="line">    <span class="comment">// 可以在不同queue的NSOperation之间创建依赖关系</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download1----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download2----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download3----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op4 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"download4----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op5 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download5----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 监听op5任务执行完毕会调用这个block</span></span><br><span class="line">    op5<span class="variable">.completionBlock</span> = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"op5执行完毕---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置依赖</span></span><br><span class="line">    [op3 addDependency:op1];</span><br><span class="line">    [op3 addDependency:op2];</span><br><span class="line">    [op3 addDependency:op4];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];</span><br><span class="line">    [queue addOperation:op4];</span><br><span class="line">    [queue addOperation:op5];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="线程之间的通讯">线程之间的通讯</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 线程之间的通信</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    [[[<span class="built_in">NSOperationQueue</span> alloc] init] addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">       <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg"</span>];</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 合成图片</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    __block <span class="built_in">UIImage</span> *image1 = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 下载图片1</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *download1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        image1 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    __block <span class="built_in">UIImage</span> *image2 = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 下载图片2</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *download2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://pic38.nipic.com/20140228/5571398_215900721128_2.jpg"</span>];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        image2 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合成图片</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *combine = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="comment">// 开启新的图形上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制图片</span></span><br><span class="line">        [image1 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)];</span><br><span class="line">        image1 = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        [image2 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)];</span><br><span class="line">        image2 = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取得上下文中的图片</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结束上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    [combine addDependency:download1];</span><br><span class="line">    [combine addDependency:download2];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:download1];</span><br><span class="line">    [queue addOperation:download2];</span><br><span class="line">    [queue addOperation:combine];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="多线程的基本概念">多线程的基本概念</h3><ul>
<li>创建线程是有开销的,iOS下主要成本包括:内核数据结构（大约1KB）、栈空间(子线程512KB、主线程1MB,也可以使用-setStackSize:设置,但必须是4K的倍数,而且最小是16K),创建线程大约需要90毫秒的创建时间</li>
</ul>
<h3 id="多线程的实现方案">多线程的实现方案</h3>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[const和指针]]></title>
    <link href="http://yoursite.com/2016/03/24/const_point/"/>
    <id>http://yoursite.com/2016/03/24/const_point/</id>
    <published>2016-03-24T05:44:56.000Z</published>
    <updated>2016-03-24T13:37:21.000Z</updated>
    <content type="html"><![CDATA[<h3 id="const和宏的区别">const和宏的区别</h3><ul>
<li><p>相同点:</p>
<ul>
<li>值是常量,不能动态更改 </li>
<li>更改后,其它使用到的地方会自动更改</li>
</ul>
</li>
<li><p>不同点:</p>
<ul>
<li>宏:会产生很多临时空间</li>
<li>const:<ul>
<li>只有一份内存</li>
<li>写在外面是全局常量</li>
<li>不能运行时修改常量值</li>
<li>加上static之后只能在本文件访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="const与指针">const与指针</h3><ul>
<li>看const右边整体是什么,什么就不能修改.<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p2;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 定义一个指针变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">NULL</span>;(等同于 <span class="keyword">int</span> <span class="keyword">const</span> *p = <span class="literal">NULL</span>;)</span><br><span class="line"><span class="comment">// p指向a</span></span><br><span class="line">p = &amp;a;(可以修改)</span><br><span class="line"><span class="comment">//*p = 20;(*p不能改,const后面是*p所以不能改)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;c;(p不能被修改,一开始指向什么,以后都不能更改)</span><br><span class="line">*p = <span class="number">30</span>;(但是可以修改它指向的变量c的值)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值传递比较有用,想让别人不更改你的值可以通过这种方式使用</span></span><br><span class="line"><span class="keyword">void</span> test(<span class="keyword">const</span> <span class="keyword">int</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//*p = 100;(不能修改*p的值)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修饰指针,指针不能更改</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> NAME = <span class="string">@""</span>;</span><br><span class="line"><span class="comment">//不能修改</span></span><br><span class="line"><span class="comment">//NAME = @"123";</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="const和宏的区别">const和宏的区别</h3><ul>
<li><p>相同点:</p>
<ul>
<li>值是常量,不能动态更改 </li>
<li>更改后,其它使用到的地方会自动更改</li>
</ul>
</li>
<li><p>不同点:</p>
<ul>
<li>宏:会产生很多临时空间</li>
<li>const:<ul>
<li>只有一份内存</li>
<li>写在外面是全局常量</li>
<li>不能运行时修改常量值</li>
<li>加上static之后只能在本文件访问</li>
</ul>
</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIScrollView常见功能]]></title>
    <link href="http://yoursite.com/2016/03/24/uiscrollview_common_feature/"/>
    <id>http://yoursite.com/2016/03/24/uiscrollview_common_feature/</id>
    <published>2016-03-24T05:25:49.000Z</published>
    <updated>2016-03-28T13:21:20.000Z</updated>
    <content type="html"><![CDATA[<h3 id="子控件悬停">子控件悬停</h3><ul>
<li>获取UIScrollView垂直方向上的滚动距离来动态调整子控件的frame并将子控件添加到最顶层父控件或者UIScrollView上</li>
</ul>
<h3 id="下拉放大">下拉放大</h3><ul>
<li>获取UIScrollView垂直方向上的滚动距离,计算一个scale值,通过改变控件的形变来实现缩放 </li>
</ul>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">UIScrollViewDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *redView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *blueView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIScrollView</span> *scrollView;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="number">0</span>, <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span><span class="variable">.blueView</span><span class="variable">.frame</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;UIScrollViewDelegate&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageH = <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> offsetY = scrollView<span class="variable">.contentOffset</span><span class="variable">.y</span>;</span><br><span class="line">    <span class="keyword">if</span> (offsetY &gt;= imageH) &#123;</span><br><span class="line">        <span class="comment">// 将红色控件添加到控制器的view中,设置Y值为0</span></span><br><span class="line">        <span class="built_in">CGRect</span> redF = <span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.frame</span>;</span><br><span class="line">        redF<span class="variable">.origin</span><span class="variable">.y</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.frame</span> = redF;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.view</span> addSubview:<span class="keyword">self</span><span class="variable">.redView</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将红色控件添加到scrollView中,设置Y值为图片的高度</span></span><br><span class="line">        <span class="built_in">CGRect</span> redF = <span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.frame</span>;</span><br><span class="line">        redF<span class="variable">.origin</span><span class="variable">.y</span> = <span class="number">140</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.frame</span> = redF;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.scrollView</span> addSubview:<span class="keyword">self</span><span class="variable">.redView</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> scale = <span class="number">1</span> - (offsetY / <span class="number">70</span>);</span><br><span class="line">    scale = (scale &gt;= <span class="number">1</span>) ? scale : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeScale</span>(scale, scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="UIScrollView内部子控件添加约束的注意点">UIScrollView内部子控件添加约束的注意点</h3><ul>
<li><p>子控件的尺寸不能通过UIScrollView来计算,可以考虑通过以下方式计算</p>
<ul>
<li>可以设置固定值（width==100,height==300）</li>
<li>可以相对于UIScrollView以外的其他控件来计算尺寸</li>
</ul>
</li>
<li><p>UIScrollView的frame应该通过子控件以外的其他控件来计算</p>
</li>
<li><p>UIScrollView的contentSize通过子控件来计算</p>
<ul>
<li>根据子控件的尺寸以及子控件与UIScrollView之间的间距</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="子控件悬停">子控件悬停</h3><ul>
<li>获取UIScrollView垂直方向上的滚动距离来动态调整子控件的frame并将子控件添加到最顶层父控件或者UIScrollView上</li>
</ul>
<h3 id="下拉放大">下拉放大</h3><ul>
<li>获取UIScrollView垂直方向上的滚动距离,计算一个scale值,通过改变控件的形变来实现缩放 </li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[网易新闻项目]]></title>
    <link href="http://yoursite.com/2016/03/24/ios_news/"/>
    <id>http://yoursite.com/2016/03/24/ios_news/</id>
    <published>2016-03-24T02:08:49.000Z</published>
    <updated>2016-03-24T13:20:49.000Z</updated>
    <content type="html"><![CDATA[<h3 id="网易新闻项目知识点">网易新闻项目知识点</h3><ul>
<li><p>自定义MCHomeViewController继承自UIViewController</p>
</li>
<li><p>Main.storyboard 添加导航控制器为初始化控制器,添加UIViewController为导航控制器的根控制器并设置其Class类型为MCHomeViewController,为UIViewController添加2个UIScrollView并设置好约束,设置contentScrollView代理为MCHomeViewController</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>自定义MCSocialViewController继承自UITableViewController并实现好数据源方法</p>
</li>
<li><p>在MCHomeViewController.m中初始化多个MCSocialViewController并通过addChildViewController方式添加到控制器中</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加子控制器</span></span><br><span class="line">    [<span class="keyword">self</span> setupChildVc];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加标题</span></span><br><span class="line">    [<span class="keyword">self</span> setupTitle];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认显示第0个子控制器</span></span><br><span class="line">    [<span class="keyword">self</span> scrollViewDidEndScrollingAnimation:<span class="keyword">self</span><span class="variable">.contentScrollView</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setupChildVc</span><br><span class="line">&#123;</span><br><span class="line">    MCSocialViewController *social0 = [[MCSocialViewController alloc] init];</span><br><span class="line">    social0<span class="variable">.title</span> = <span class="string">@"国际"</span>;</span><br><span class="line">    [<span class="keyword">self</span> addChildViewController:social0];</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为顶部的titleScrollView添加多个标题并设置其滚动视图的contentSize和contentScrollView的contentSize</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 添加标题</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setupTitle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义临时变量</span></span><br><span class="line">    <span class="built_in">CGFloat</span> labelW = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> labelY = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> labelH = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加label</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">        XMGHomeLabel *label = [[XMGHomeLabel alloc] init];</span><br><span class="line">        label<span class="variable">.text</span> = [<span class="keyword">self</span><span class="variable">.childViewControllers</span>[i] title];</span><br><span class="line">        <span class="built_in">CGFloat</span> labelX = i * labelW;</span><br><span class="line">        label<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(labelX, labelY, labelW, labelH);</span><br><span class="line">        [label addGestureRecognizer:[[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(labelClick:)]];</span><br><span class="line">        label<span class="variable">.tag</span> = i;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.titleScrollView</span> addSubview:label];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 最前面的label</span></span><br><span class="line">            label<span class="variable">.scale</span> = <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置contentSize</span></span><br><span class="line">	<span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="number">7</span> * labelW, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 这里设置contentScrollView.contentSize宽高不能根据self.contentScrollView.frame.size 因为viewDidLoad从storyboard加载的时候尺寸是600*600,在执行- (void)viewDidAppear:(BOOL)animated时候能得到真正的尺寸,并且contentScrollView添加过约束,所以最后才能得到其准确的frame</span></span><br><span class="line">	<span class="keyword">self</span><span class="variable">.contentScrollView</span><span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="number">7</span> * [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理顶部标题点击事件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)labelClick:(<span class="built_in">UITapGestureRecognizer</span> *)tap</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出被点击label的索引</span></span><br><span class="line">    <span class="built_in">NSInteger</span> index = tap<span class="variable">.view</span><span class="variable">.tag</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让底部的内容scrollView滚动到对应位置</span></span><br><span class="line">    <span class="built_in">CGPoint</span> offset = <span class="keyword">self</span><span class="variable">.contentScrollView</span><span class="variable">.contentOffset</span>;</span><br><span class="line">    offset<span class="variable">.x</span> = index * <span class="keyword">self</span><span class="variable">.contentScrollView</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.contentScrollView</span> setContentOffset:offset animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理滚动动画结束后,显示对应位置的控制器并将对应位置的标题显示在中间</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * scrollView结束了滚动动画以后就会调用这个方法(比如- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;方法执行的动画完毕后)</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一些临时变量</span></span><br><span class="line">    <span class="built_in">CGFloat</span> width = scrollView<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> height = scrollView<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> offsetX = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前位置需要显示的控制器的索引</span></span><br><span class="line">    <span class="built_in">NSInteger</span> index = offsetX / width;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让对应的顶部标题居中显示</span></span><br><span class="line">    <span class="built_in">UILabel</span> *label = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span>[index];</span><br><span class="line">    <span class="built_in">CGPoint</span> titleOffset = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.contentOffset</span>;</span><br><span class="line">    titleOffset<span class="variable">.x</span> = label<span class="variable">.center</span><span class="variable">.x</span> - width * <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 左边超出处理</span></span><br><span class="line">    <span class="keyword">if</span> (titleOffset<span class="variable">.x</span> &lt; <span class="number">0</span>) titleOffset<span class="variable">.x</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 右边超出处理</span></span><br><span class="line">    <span class="built_in">CGFloat</span> maxTitleOffsetX = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.contentSize</span><span class="variable">.width</span> - width;</span><br><span class="line">    <span class="keyword">if</span> (titleOffset<span class="variable">.x</span> &gt; maxTitleOffsetX) titleOffset<span class="variable">.x</span> = maxTitleOffsetX;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.titleScrollView</span> setContentOffset:titleOffset animated:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让其他label回到最初的状态</span></span><br><span class="line">    <span class="keyword">for</span> (MCHomeLabel *otherLabel <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (otherLabel != label) otherLabel<span class="variable">.scale</span> = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出需要显示的控制器</span></span><br><span class="line">    <span class="built_in">UIViewController</span> *willShowVc = <span class="keyword">self</span><span class="variable">.childViewControllers</span>[index];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前位置的位置已经显示过了,就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ([willShowVc isViewLoaded]) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//if (willShowVc.view.superview) return;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加控制器的view到contentScrollView中;</span></span><br><span class="line">    willShowVc<span class="variable">.view</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(offsetX, <span class="number">0</span>, width, height);</span><br><span class="line">    [scrollView addSubview:willShowVc<span class="variable">.view</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理手指滑动松开scrollView后显示对应位置的控制器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 手指松开scrollView后,scrollView停止减速完毕就会调用这个</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> scrollViewDidEndScrollingAnimation:scrollView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理滚动contentScrollView时标题缩放变色</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 只要scrollView在滚动，就会调用</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span> / scrollView<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="keyword">if</span> (scale &lt; <span class="number">0</span> || scale &gt; <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span><span class="variable">.count</span> - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得需要操作的左边label</span></span><br><span class="line">    <span class="built_in">NSInteger</span> leftIndex = scale;</span><br><span class="line">    MCHomeLabel *leftLabel = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span>[leftIndex];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得需要操作的右边label</span></span><br><span class="line">    <span class="built_in">NSInteger</span> rightIndex = leftIndex + <span class="number">1</span>;</span><br><span class="line">    MCHomeLabel *rightLabel = (rightIndex == <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span><span class="variable">.count</span>) ? <span class="literal">nil</span> : <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span>[rightIndex];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右边比例</span></span><br><span class="line">    <span class="built_in">CGFloat</span> rightScale = scale - leftIndex;</span><br><span class="line">    <span class="comment">// 左边比例</span></span><br><span class="line">    <span class="built_in">CGFloat</span> leftScale = <span class="number">1</span> - rightScale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置label的比例</span></span><br><span class="line">    leftLabel<span class="variable">.scale</span> = leftScale;</span><br><span class="line">    rightLabel<span class="variable">.scale</span> = rightScale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装titleLabel</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCHomeLabel</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.font</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> colorWithRed:MCRed green:M<span class="built_in">CGreen</span> blue:MCBlue alpha:<span class="number">1.0</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.textAlignment</span> = <span class="built_in">NSTextAlignmentCenter</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.userInteractionEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setScale:(<span class="built_in">CGFloat</span>)scale</span><br><span class="line">&#123;</span><br><span class="line">    _scale = scale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//      R G B</span></span><br><span class="line">    <span class="comment">// 默认：0.4 0.6 0.7</span></span><br><span class="line">    <span class="comment">// 红色：1   0   0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> red = MCRed + (<span class="number">1</span> - XMGRed) * scale;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = M<span class="built_in">CGreen</span> + (<span class="number">0</span> - XMGGreen) * scale;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = MCBlue + (<span class="number">0</span> - XMGBlue) * scale;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大小缩放比例</span></span><br><span class="line">    <span class="built_in">CGFloat</span> transformScale = <span class="number">1</span> + scale * <span class="number">0.3</span>; <span class="comment">// [1, 1.3]</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeScale</span>(transformScale, transformScale);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="网易新闻项目知识点">网易新闻项目知识点</h3><ul>
<li><p>自定义MCHomeViewController继承自UIViewController</p>
</li>
<li><p>Main.storyboard 添加导航控制器为初始化控制器,添加UIViewController为导航控制器的根控制器并设置其Class类型为MCHomeViewController,为UIViewController添加2个UIScrollView并设置好约束,设置contentScrollView代理为MCHomeViewController</p>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[static与copy关键字]]></title>
    <link href="http://yoursite.com/2016/03/23/static_copy/"/>
    <id>http://yoursite.com/2016/03/23/static_copy/</id>
    <published>2016-03-23T06:55:35.000Z</published>
    <updated>2016-03-25T13:16:53.000Z</updated>
    <content type="html"><![CDATA[<h3 id="static的作用">static的作用</h3><h4 id="修饰局部变量">修饰局部变量</h4><ul>
<li>让局部变量只初始化一次</li>
<li>局部变量在程序中只有一份内存</li>
<li>并不会改变局部变量的作用域,仅仅是改变了局部变量的生命周期(只到程序结束，这个局部变量才会销毁)</li>
</ul>
<a id="more"></a>
<h4 id="static修饰全局变量">static修饰全局变量</h4><ul>
<li>全局变量的作用域仅限于当前文件</li>
</ul>
<h4 id="全局变量">全局变量</h4><ul>
<li>作用范围:整个程序</li>
<li>外部通过extern来访问全局变量(例如:<code>extern int age;</code>)</li>
<li>任何全局变量是不安全的,随时都可能被外部修改</li>
</ul>
<h3 id="实现拷贝的方法">实现拷贝的方法</h3><ul>
<li><p>copy</p>
<ul>
<li>只会产生不可变的副本对象(比如NSString),如果对不可变对象调用copy,不会产生新对象(浅拷贝-指针拷贝),反之会产生新对象(深度拷贝-内容拷贝)</li>
</ul>
</li>
<li><p>mutableCopy</p>
<ul>
<li>只会产生可变的副本对象(比如NSMutableString),都会产生新对象(深度拷贝-内容拷贝)</li>
</ul>
</li>
<li><p>自定义对象的copy</p>
<ul>
<li>自定义对象需要遵守NSCopying协议实现下面的方法<br><code>- (id)copyWithZone:(nullable NSZone *)zone;</code><br><code>- (id)mutableCopyWithZone:(nullable NSZone *)zone;</code></li>
<li>copy 会调用自定义对象的 copyWithZone</li>
<li><p>mutableCopy 会调用自定义对象的 mutableCopyWithZone</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCPerson</span>() &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    MCPerson *person = [[MCPerson allocWithZone:zone] init];</span><br><span class="line">    person<span class="variable">.age</span> = <span class="keyword">self</span><span class="variable">.age</span>;</span><br><span class="line">    person<span class="variable">.money</span> = <span class="keyword">self</span><span class="variable">.money</span>;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>@property中的copy</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">//如果是strong则其set方法是:</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">//如果是copy则其set方法是:</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    _name = [name <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> copyProperty()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *string = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"jack"</span>];</span><br><span class="line">    </span><br><span class="line">    MCPerson *p = [[MCPerson alloc] init];</span><br><span class="line">    p<span class="variable">.name</span> = string;</span><br><span class="line">    <span class="comment">//[p setName:string];</span></span><br><span class="line">    </span><br><span class="line">    [string appendString:<span class="string">@" rose"</span>];</span><br><span class="line">    <span class="comment">//如果property中是strong 则输出是"jack rose",copy则输出"jack"</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, p<span class="variable">.name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** name属性值永远是不可变，所以定义为NSMutableString是不合理的 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableString</span> *name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="static的作用">static的作用</h3><h4 id="修饰局部变量">修饰局部变量</h4><ul>
<li>让局部变量只初始化一次</li>
<li>局部变量在程序中只有一份内存</li>
<li>并不会改变局部变量的作用域,仅仅是改变了局部变量的生命周期(只到程序结束，这个局部变量才会销毁)</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
</feed>