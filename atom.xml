<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Mobile Development]]></title>
  <subtitle><![CDATA[移动开发]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com//"/>
  <updated>2016-03-29T00:18:08.000Z</updated>
  <id>http://yoursite.com//</id>
  
  <author>
    <name><![CDATA[weifeng]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[iOS网络]]></title>
    <link href="http://yoursite.com/2016/03/28/ios_network/"/>
    <id>http://yoursite.com/2016/03/28/ios_network/</id>
    <published>2016-03-28T03:08:14.000Z</published>
    <updated>2016-03-29T00:18:08.000Z</updated>
    <content type="html"><![CDATA[<h3 id="NSURLConnection">NSURLConnection</h3><h4 id="常用类">常用类</h4><ul>
<li><p>NSURL:请求地址</p>
</li>
<li><p>NSURLRequest:一个NSURLRequest对象就代表一个请求,它包含的信息有</p>
<ul>
<li>一个NSURL对象</li>
<li>请求方法、请求头、请求体</li>
<li>请求超时</li>
<li>…</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>NSMutableURLRequest:NSURLRequest的子类</p>
</li>
<li><p>NSURLConnection</p>
<ul>
<li>负责发送请求,建立客户端和服务端的连接</li>
<li>发送数据给服务器,并收集来自服务器的响应数据</li>
</ul>
</li>
</ul>
<h4 id="NSURLConnection的使用步骤">NSURLConnection的使用步骤</h4><ul>
<li>使用使用发送请求的步骤很简单<ul>
<li>创建一个NSURL对象,设置请求路径</li>
<li>传人NSURL创建一个NSURLRequest对象,设置请求头和请求体</li>
<li>使用NSURLConnection发送请求</li>
</ul>
</li>
</ul>
<h4 id="NSURLConnection发送请求">NSURLConnection发送请求</h4><ul>
<li><p>NSURLConnection常用的发送请求方法有以下几种</p>
<ul>
<li><p>同步请求:<code>+ (nullable NSData *)sendSynchronousRequest:(NSURLRequest *)request returningResponse:(NSURLResponse * __nullable * __nullable)response error:(NSError **)error</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 发送同步请求</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)sync</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 0.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="comment">// sendSynchronousRequest阻塞式的方法,等待服务器返回数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSHTTPURLResponse</span> *response = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.解析服务器返回的数据(解析成字符串)</span></span><br><span class="line">    <span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, string, response<span class="variable">.allHeaderFields</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步请求:根据对服务器返回数据的处理方式的不同,又可以分为2种:block回调和代理<code>+ (void)sendAsynchronousRequest:(NSURLRequest*) request queue:(NSOperationQueue*) queue completionHandler:(void (^)(NSURLResponse* __nullable response, NSData* __nullable data, NSError* __nullable connectionError)) handler</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span><br><span class="line"> * 发送异步请求</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)async</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 0.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[[<span class="built_in">NSOperationQueue</span> alloc] init] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="comment">// 请求完毕会来到这个block</span></span><br><span class="line">        <span class="comment">// 3.解析服务器返回的数据(解析成字符串)</span></span><br><span class="line">        <span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, string);</span><br><span class="line">        <span class="built_in">NSHTTPURLResponse</span> *r = (<span class="built_in">NSHTTPURLResponse</span> *)response;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd %@"</span>, r<span class="variable">.statusCode</span>, r<span class="variable">.allHeaderFields</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认会开启线程执行异步请求:<br><code>+ (nullable NSURLConnection*)connectionWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate</code><br><code>- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate</code><br><code>- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate startImmediately:(BOOL)startImmediately</code><br>在startImmediately = NO的情况下,需要调用start方法开始发送请求<br><code>- (void)start</code><br>成为NSURLConnection的代理,最好遵守NSURLConnectionDataDelegate协议</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)delegateAysnc</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 0.请求路径</span></span><br><span class="line">   	<span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 1.创建请求对象</span></span><br><span class="line">   	<span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 2.创建连接对象</span></span><br><span class="line">    <span class="comment">//[[NSURLConnection alloc] initWithRequest:request delegate:self];</span></span><br><span class="line">    <span class="comment">//不是马上发请求,startImmediately如果是YES就不需要strat</span></span><br><span class="line">    <span class="comment">//NSURLConnection *conn = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO];</span></span><br><span class="line">    <span class="comment">//[conn start];</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURLConnection</span> *conn = [<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消</span></span><br><span class="line">    <span class="comment">//[conn cancel];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 接收到服务器的响应</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建data对象</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.responseData</span> = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveResponse"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 接收到服务器的数据(如果数据量比较大,这个方法会被调用多次)</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不断拼接服务器返回的数据</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.responseData</span> appendData:data];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveData -- %zd"</span>, data<span class="variable">.length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 服务器的数据成功接收完毕(回调到主线程)</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"connectionDidFinishLoading"</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithData:<span class="keyword">self</span><span class="variable">.responseData</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, string);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.responseData</span> = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 请求失败(比如请求超时)</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didFailWithError -- %@"</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="NSMutableURLRequest">NSMutableURLRequest</h4><ul>
<li><p>NSMutableURLRequest是NSURLRequest的子类,常用方法有:</p>
<ul>
<li><p>设置请求超时等待时间(超过这个时间就算超时,请求失败)<br><code>- (void)setTimeoutInterval:(NSTimeInterval)seconds;</code></p>
</li>
<li><p>设置请求方法(比如GET和POST)<br><code>- (void)setHTTPMethod:(NSString *)method;</code></p>
</li>
<li><p>设置请求体<br><code>- (void)setHTTPBody:(NSData *)data;</code></p>
</li>
<li><p>设置请求头<br><code>- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;</code><br><code>- (void)addValue:(NSString *)value forHTTPHeaderField:(NSString *)field;</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// 1.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://120.25.226.186:32812/login"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.创建请求</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改请求方法</span></span><br><span class="line">    request<span class="variable">.HTTPMethod</span> = <span class="string">@"POST"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求体</span></span><br><span class="line">    request<span class="variable">.HTTPBody</span> = [<span class="string">@"username=520it&amp;pwd=520it"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时(5秒后超时)</span></span><br><span class="line">    request<span class="variable">.timeoutInterval</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    [request setValue:<span class="string">@"iOS 9.0"</span> forHTTPHeaderField:<span class="string">@"User-Agent"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connectionError) &#123; <span class="comment">// 比如请求超时</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"----请求失败"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"------%@"</span>, [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="JSON解析方案">JSON解析方案</h4><ul>
<li><p>在iOS中,JSON的常见解析方式有4种</p>
<ul>
<li>第三方框架:JSONKit、SBJson、TouchJSON(性能从左到右,越差)</li>
<li>苹果原生(自带):NSJSONSerialization(性能最好)</li>
</ul>
</li>
<li><p>NSJSONSerialization的常见方法</p>
<ul>
<li><p>JSON数据 -&gt; OC对象<br><code>+ (nullable id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error;</code></p>
</li>
<li><p>OC对象 -&gt; JSON数据<br><code>+ (nullable NSData *)dataWithJSONObject:(id)obj options:(NSJSONWritingOptions)opt error:(NSError **)error;</code></p>
</li>
<li><p>log输出的时候如果JSON中有中文会显示不出来,可以重写NSDictionary和NSArray的<code>- (NSString *)descriptionWithLocale:(id)locale</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">@implementation NSDictionary (Log)</span><br><span class="line">- (NSString *)descriptionWithLocale:(id)locale</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableString *string = [NSMutableString string];</span><br><span class="line">    </span><br><span class="line">    // 开头有个&#123;</span><br><span class="line">    [string appendString:@"&#123;\n"];</span><br><span class="line">    </span><br><span class="line">    // 遍历所有的键值对</span><br><span class="line">    [self enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        [string appendFormat:@"\t%@", key];</span><br><span class="line">        [string appendString:@" : "];</span><br><span class="line">        [string appendFormat:@"%@,\n", obj];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 结尾有个&#125;</span><br><span class="line">    [string appendString:@"&#125;"];</span><br><span class="line">    </span><br><span class="line">    // 查找最后一个逗号</span><br><span class="line">    NSRange range = [string rangeOfString:@"," options:NSBackwardsSearch];</span><br><span class="line">    if (range.location != NSNotFound)</span><br><span class="line">    [string deleteCharactersInRange:range];</span><br><span class="line">    </span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSArray (Log)</span><br><span class="line"></span><br><span class="line">- (NSString *)descriptionWithLocale:(id)locale</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableString *string = [NSMutableString string];</span><br><span class="line">    </span><br><span class="line">    // 开头有个[</span><br><span class="line">    [string appendString:@"[\n"];</span><br><span class="line">    </span><br><span class="line">    // 遍历所有的元素</span><br><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">        [string appendFormat:@"\t%@,\n", obj];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 结尾有个]</span><br><span class="line">    [string appendString:@"]"];</span><br><span class="line">    </span><br><span class="line">    // 查找最后一个逗号</span><br><span class="line">    NSRange range = [string rangeOfString:@"," options:NSBackwardsSearch];</span><br><span class="line">    if (range.location != NSNotFound)</span><br><span class="line">    [string deleteCharactersInRange:range];</span><br><span class="line">    </span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="iOS中的XML解析">iOS中的XML解析</h4><ul>
<li><p>苹果原生</p>
<ul>
<li>NSXMLParser:SAX方式解析</li>
</ul>
</li>
<li><p>第三方框架</p>
<ul>
<li>libxml2:纯C语言,默认包含在iOS SDK中,同时支持DOM和SAX方式解析</li>
<li>GDataXML:DOM方式解析,由Google开发,基于libxml2</li>
</ul>
</li>
<li><p>XML解析方式的选择建议</p>
<ul>
<li>大文件:NSXMLParser、libxml2</li>
<li>小文件:GDataXML、NSXMLParser、libxml2</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *GDataXML</span><br><span class="line"> */</span>	</span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="comment">// 加载整个文档</span></span><br><span class="line">        GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data options:<span class="number">0</span> error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得所有video元素</span></span><br><span class="line">        <span class="built_in">NSArray</span> *elements = [doc<span class="variable">.rootElement</span> elementsForName:<span class="string">@"video"</span>];</span><br><span class="line">        <span class="keyword">for</span> (GDataXMLElement *ele <span class="keyword">in</span> elements) &#123;</span><br><span class="line">            XMGVideo *video = [[XMGVideo alloc] init];</span><br><span class="line">            video<span class="variable">.name</span> = [ele attributeForName:<span class="string">@"name"</span>]<span class="variable">.stringValue</span>;</span><br><span class="line">            video<span class="variable">.url</span> = [ele attributeForName:<span class="string">@"url"</span>]<span class="variable">.stringValue</span>;</span><br><span class="line">            video<span class="variable">.image</span> = [ele attributeForName:<span class="string">@"image"</span>]<span class="variable">.stringValue</span>;</span><br><span class="line">            video<span class="variable">.length</span> = [ele attributeForName:<span class="string">@"length"</span>]<span class="variable">.stringValue</span><span class="variable">.integerValue</span>;</span><br><span class="line">            </span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.videos</span> addObject:video];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *NSXMLParser</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://120.25.226.186:32812/video?type=XML"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="comment">// 创建XML解析器</span></span><br><span class="line">        <span class="built_in">NSXMLParser</span> *parser = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:data];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置代理</span></span><br><span class="line">        parser<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始解析XML</span></span><br><span class="line">        [parser parse];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新表格</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.tableView</span> reloadData];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSXMLParserDelegate&gt;</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 解析到某个元素的结尾（比如解析&lt;/videos&gt;）</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser didEndElement:(<span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="built_in">NSString</span> *)qName</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    NSLog(@"didEndElement - %@", elementName);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 解析到某个元素的开头（比如解析&lt;videos&gt;）</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser didStartElement:(<span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="built_in">NSString</span> *)qName attributes:(<span class="built_in">NSDictionary</span> *)attributeDict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([elementName isEqualToString:<span class="string">@"videos"</span>]) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//    XMGVideo *video = [[XMGVideo alloc] init];</span></span><br><span class="line"><span class="comment">//    video.keyValues = attributeDict;</span></span><br><span class="line">    </span><br><span class="line">    MCVideo *video = [MCVideo objectWithKeyValues:attributeDict];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.videos</span> addObject:video];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 开始解析XML文档</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)parserDidStartDocument:(<span class="built_in">NSXMLParser</span> *)parser</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    NSLog(@"parserDidStartDocument");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 解析完毕</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)parserDidEndDocument:(<span class="built_in">NSXMLParser</span> *)parser</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    NSLog(@"parserDidEndDocument");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小文件下载">小文件下载</h4><ul>
<li><p>如果文件比较小,下载方式会比较多</p>
<ul>
<li>直接用NSData的<code>+ (id)dataWithContentsOfURL:(NSURL *)url;</code></li>
<li>利用NSURLConnection发送一个HTTP请求去下载</li>
<li>如果是下载图片,还可以利用SDWebImage框架</li>
</ul>
</li>
<li><p>如果是大文件下载,建议使用NSURLSession或者第三方框架</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#define MCFile [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@<span class="title">"minion_15.mp4"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSURLConnectionDataDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIProgressView</span> *progressView;</span><br><span class="line"><span class="comment">/** 文件的总长度 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> contentLength;</span><br><span class="line"><span class="comment">/** 当前下载的总长度 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> currentLength;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 文件句柄对象 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSFileHandle</span> *handle;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxxx/resources/videos/minion_15.mp4"</span>];</span><br><span class="line">    [<span class="built_in">NSURLConnection</span> connectionWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:url] delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLConnectionDataDelegate&gt;</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 接收到响应的时候：创建一个空的文件</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得文件的总长度</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.contentLength</span> = [response<span class="variable">.allHeaderFields</span>[<span class="string">@"Content-Length"</span>] integerValue];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个空的文件</span></span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] createFileAtPath:M<span class="built_in">CFile</span> contents:<span class="literal">nil</span> attributes:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建文件句柄</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.handle</span> = [<span class="built_in">NSFileHandle</span> fileHandleForWritingAtPath:XMGFile];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 接收到具体数据:马上把数据写入一开始创建好的文件</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 指定数据的写入位置 -- 文件内容的最后面</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.handle</span> seekToEndOfFile];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.handle</span> writeData:data];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拼接总长度</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.currentLength</span> += data<span class="variable">.length</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进度</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.progressView</span><span class="variable">.progress</span> = <span class="number">1.0</span> * <span class="keyword">self</span><span class="variable">.currentLength</span> / <span class="keyword">self</span><span class="variable">.contentLength</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 关闭handle</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.handle</span> closeFile];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.handle</span> = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空长度</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.currentLength</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="第三方解压缩框架—SSZipArchive">第三方解压缩框架—SSZipArchive</h4><ul>
<li>下载地址:<a href="https://github.com/ZipArchive/ZipArchive" target="_blank" rel="external">https://github.com/ZipArchive/ZipArchive</a></li>
</ul>
<h4 id="文件上传步骤">文件上传步骤</h4><ul>
<li><p>设置请求头<br><code>[request setValue:@&quot;multipart/form-data;boundary=分隔线&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</code></p>
</li>
<li><p>设置请求体</p>
<ul>
<li><p>非文件参数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">--分隔线\r\n(为了支持不同平台,有些平台只有\r而有些是\n,为了统一所以这样做)</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"参数名"</span>\r\n</span><br><span class="line">\r\n</span><br><span class="line">参数值</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件参数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">--分隔线\r\n(为了支持不同平台,有些平台只有\r而有些是\n,为了统一所以这样做)</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"参数名"</span>;filename=<span class="string">"文件名"</span>\r\n</span><br><span class="line">Content-Type:文件的MIMEType\r\n</span><br><span class="line">\r\n</span><br><span class="line">文件数据</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数结束的标记<br><code>--分隔线--\r\n</code></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#define MCBoundary @<span class="title">"mc"</span></span></span><br><span class="line"><span class="preprocessor">#define MCEncode(string) [string dataUsingEncoding:NSUTF8StringEncoding]</span></span><br><span class="line"><span class="preprocessor">#define MCNewLine [@<span class="title">"\r\n"</span> dataUsingEncoding:NSUTF8StringEncoding]</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建请求</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://120.25.226.186:32812/upload"</span>];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    request<span class="variable">.HTTPMethod</span> = <span class="string">@"POST"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求头(告诉告诉服务器,这是一个文件上传的请求)</span></span><br><span class="line">    [request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"multipart/form-data; boundary=%@"</span>, MCBoundary] forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求体</span></span><br><span class="line">    <span class="built_in">NSMutableData</span> *body = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件参数</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     --分割线\r\n</span><br><span class="line">     Content-Disposition: form-data; name="参数名"; filename="文件名"\r\n</span><br><span class="line">     Content-Type: 文件的MIMEType\r\n</span><br><span class="line">     \r\n</span><br><span class="line">     文件数据</span><br><span class="line">     \r\n</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">// 分割线</span></span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCEncode(MCBoundary)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件参数名</span></span><br><span class="line">    [body appendData:MCEncode([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Content-Disposition: form-data; name=\"file\"; filename=\"test.png\""</span>])];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件的类型</span></span><br><span class="line">    [body appendData:MCEncode([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Content-Type: image/png"</span>])];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件数据</span></span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    <span class="comment">//UIImageJPEGRepresentation(&lt;#UIImage *image#&gt;, &lt;#CGFloat compressionQuality#&gt;)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>];</span><br><span class="line">    [body appendData:<span class="built_in">UIImagePNGRepresentation</span>(image)];</span><br><span class="line">    <span class="comment">//[body appendData:[NSData dataWithContentsOfFile:@"/Users/weifeng/Desktop/test.png"]];</span></span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非文件参数</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     --分割线\r\n</span><br><span class="line">     Content-Disposition: form-data; name="参数名"\r\n</span><br><span class="line">     \r\n</span><br><span class="line">     参数值</span><br><span class="line">     \r\n</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">// 分割线</span></span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCEncode(MCBoundary)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数名</span></span><br><span class="line">    [body appendData:MCEncode([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Content-Disposition: form-data; name=\"username\""</span>])];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数值</span></span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"jack"</span>)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束标记</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     --分割线--\r\n</span><br><span class="line">     */</span></span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCEncode(MCBoundary)];</span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    request<span class="variable">.HTTPBody</span> = body;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="将NSData写入文件的几种方式">将NSData写入文件的几种方式</h4><ul>
<li>NSFileHandle</li>
<li>NSOutputStream</li>
<li>NSData的实例方法<code>- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSURLConnectionDataDelegate</span>&gt;</span></span><br><span class="line"><span class="comment">/** 输出流对象 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOutputStream</span> *stream;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSURLConnection</span> connectionWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxxx/resources/videos/minion_01.mp4"</span>]] delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLConnectionDataDelegate&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// response.suggestedFilename : 服务器那边的文件名</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *caches = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">    <span class="built_in">NSString</span> *file = [caches stringByAppendingPathComponent:response<span class="variable">.suggestedFilename</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, file);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用NSOutputStream往Path中写入数据（append为YES的话，每次写入都是追加到文件尾部）</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.stream</span> = [[<span class="built_in">NSOutputStream</span> alloc] initToFileAtPath:file append:<span class="literal">YES</span>];</span><br><span class="line">    <span class="comment">// 打开流(如果文件不存在，会自动创建)</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.stream</span> open];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.stream</span> write:[data bytes] maxLength:data<span class="variable">.length</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveData-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.stream</span> close];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="子线程中处理回调数据">子线程中处理回调数据</h4><ul>
<li><p>有时候我们想要让接收到的数据放在子线程中处理,比如写文件操作.这个时候可以通过NSURLConnection的<code>- (void)setDelegateQueue:(nullable NSOperationQueue*) queue</code></p>
</li>
<li><p>处理NSURLConnection的<code>+ (nullable NSURLConnection*)connectionWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate</code>放在子线程中并不会执行的问题.</p>
<blockquote>
<p>NSURLConnection跟RunLoop有关系,一旦请求发出去,一直等待服务器请求回来,一点一点接收数据,有一个运行循环等待数据,它是在RunLoop中接收返回数据的.NSURLConnection内部会关联当前线程对应的RunLoop,不断给当前线程的RunLoop发送消息,RunLoop一旦接收到Source,紧接着会去处理.<br>子线程为什么会不好使呢?<br>因为子线程的RunLoop默认是不启动的<br>解决办法就是在子线程中手动启动RunLoop,也需要手动去停止</p>
</blockquote>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSURLConnection</span> *conn = [<span class="built_in">NSURLConnection</span> connectionWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxxx/resources/images/minion_01.png"</span>]] delegate:<span class="keyword">self</span>];</span><br><span class="line">        <span class="comment">// 决定代理方法在哪个队列中执行</span></span><br><span class="line">        [conn setDelegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动子线程的runLoop</span></span><br><span class="line">        <span class="comment">//[[NSRunLoop currentRunLoop] run];</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span><span class="variable">.runLoop</span> = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动runLoop</span></span><br><span class="line">        <span class="built_in">CFRunLoopRun</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLConnectionDataDelegate&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveResponse----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveData----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"connectionDidFinishLoading----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 停止RunLoop</span></span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="keyword">self</span><span class="variable">.runLoop</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NSString和NSData的互相转换">NSString和NSData的互相转换</h4><ul>
<li><p>NSString -&gt; NSData<br><code>NSData *data = [@&quot;&quot; dataUsingEncoding:NSUTF8StringEncoding]</code></p>
</li>
<li><p>NSData -&gt; NSString<br><code>NSString *str = [[NSString alloc] initWithData:dataencoding:NSUTF8StringEncoding];</code></p>
</li>
</ul>
<h4 id="NSURLSession">NSURLSession</h4><ul>
<li>使用步骤<ul>
<li>使用NSURLSession对象创建Task,然后执行Task</li>
<li>Task的类型:NSURLSessionTask、NSURLSessionDataTask、NSURLSessionDownloadTask、NSURLSessionUploadTask</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)download</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得下载任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDownloadTask</span> *task = [session downloadTaskWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/resources/videos/minion_01.mp4"</span>] completionHandler:^(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="comment">// 文件将来存放的真实路径</span></span><br><span class="line">        <span class="built_in">NSString</span> *file = [[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:response<span class="variable">.suggestedFilename</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 剪切location的临时文件到真实路径</span></span><br><span class="line">        <span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">        [mgr moveItemAtURL:location toURL:[<span class="built_in">NSURL</span> fileURLWithPath:file] error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)post</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建请求</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/login"</span>]];</span><br><span class="line">    request<span class="variable">.HTTPMethod</span> = <span class="string">@"POST"</span>; <span class="comment">// 请求方法</span></span><br><span class="line">    request<span class="variable">.HTTPBody</span> = [<span class="string">@"xxx"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]; <span class="comment">// 请求体</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/login?username=xxx&amp;pwd=xxx"</span>]] completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//NSURLSessionDataTask *task = [session dataTaskWithURL:[NSURL URLWithString:@"http://xxx/login?username=xxx&amp;pwd=xxx"] completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NSURLSession代理方法">NSURLSession代理方法</h4><ul>
<li>NSURLSession的NSURLSessionDataDelegate代理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSURLSessionDataDelegate</span>, <span class="title">NSURLConnectionDataDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/login?username=xxx&amp;pwd=xxx"</span>]]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLSessionDataDelegate&gt;</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 1.接收到服务器的响应</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span>))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许处理服务器的响应,才会继续接收服务器返回的数据</span></span><br><span class="line">    completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// void (^)(NSURLSessionResponseDisposition)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 2.接收到服务器的数据（可能会被调用多次）</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 3.请求成功或者失败（如果失败,error有值）</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="大文件下载">大文件下载</h4><ul>
<li>NSURLSessionDownloadDelegate代理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSURLSessionDownloadDelegate</span>&gt;</span></span><br><span class="line"><span class="comment">/** 下载任务 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDownloadTask</span> *task;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 开始下载</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)start:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得下载任务</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.task</span> = [session downloadTaskWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/resources/videos/minion_01.mp4"</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.task</span> resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 暂停下载</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)pause:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.task</span> suspend];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 继续下载</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)goOn:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.task</span> resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLSessionDownloadDelegate&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didCompleteWithError"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didResumeAtOffset"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 每当写入数据到临时文件时,就会调用一次这个方法</span><br><span class="line"> * totalBytesExpectedToWrite:总大小</span><br><span class="line"> * totalBytesWritten: 已经写入的大小</span><br><span class="line"> * bytesWritten: 这次写入多少</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------%f"</span>, <span class="number">1.0</span> * totalBytesWritten / totalBytesExpectedToWrite);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * </span><br><span class="line"> * 下载完毕就会调用一次这个方法</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 文件将来存放的真实路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *file = [[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:downloadTask<span class="variable">.response</span><span class="variable">.suggestedFilename</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 剪切location的临时文件到真实路径</span></span><br><span class="line">    <span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    [mgr moveItemAtURL:location toURL:[<span class="built_in">NSURL</span> fileURLWithPath:file] error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="NSURLConnection">NSURLConnection</h3><h4 id="常用类">常用类</h4><ul>
<li><p>NSURL:请求地址</p>
</li>
<li><p>NSURLRequest:一个NSURLRequest对象就代表一个请求,它包含的信息有</p>
<ul>
<li>一个NSURL对象</li>
<li>请求方法、请求头、请求体</li>
<li>请求超时</li>
<li>…</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[RunLoop的基本使用]]></title>
    <link href="http://yoursite.com/2016/03/25/nsrunloop/"/>
    <id>http://yoursite.com/2016/03/25/nsrunloop/</id>
    <published>2016-03-25T07:52:46.000Z</published>
    <updated>2016-03-27T14:10:18.000Z</updated>
    <content type="html"><![CDATA[<h3 id="什么是RunLoop">什么是RunLoop</h3><ul>
<li>从字面意思看<ul>
<li>运行循环</li>
<li>跑圈</li>
</ul>
</li>
<li>基本作用<ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件(比如触摸事件、定时器事件、Selector事件)</li>
<li>节省CPU资源,提高程序性能:该做事情时做事情,该休息时休息</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h4 id="main函数中的RunLoop">main函数中的RunLoop</h4><ul>
<li>UIApplicationMain函数内部就启动了一个RunLoop</li>
<li>所以UIApplicationMain函数一直没有返回,保持程序的持续运行</li>
<li>这个默认启动的RunLoop是跟主线程相关联的</li>
</ul>
<h4 id="RunLoop对象">RunLoop对象</h4><ul>
<li><p>iOS中有2套API来访问和使用RunLoop</p>
<ul>
<li>Foundation <ul>
<li>NSRunLoop</li>
</ul>
</li>
<li>Core Foundation <ul>
<li>CFRunLoopRef</li>
</ul>
</li>
</ul>
</li>
<li><p>NSRunLoop和CFRunLoopRef都代表着RunLoop对象</p>
</li>
<li><p>NSRunLoop是基于CFRunLoopRef的一层OC包装,所以要了解RunLoop内部结构,需要多研究CFRunLoopRef层面的API</p>
</li>
</ul>
<h4 id="RunLoop与线程">RunLoop与线程</h4><ul>
<li><p>每条线程都有唯一的一个与之对应的RunLoop对象</p>
</li>
<li><p>主线程的RunLoop已经创建好了,子线程的RunLoop需要主动创建</p>
</li>
<li><p>RunLoop在第一次获取的时候创建,在线程结束的时候销毁</p>
</li>
</ul>
<h4 id="获取RunLoop">获取RunLoop</h4><ul>
<li>获取当前线程的RunLoop:<code>+ (NSRunLoop *)currentRunLoop;</code></li>
<li>获取主线程的RunLoop:<code>+ (NSRunLoop *)mainRunLoop;</code></li>
<li>获取当前线程的RunLoop:<code>CFRunLoopGetCurrent();</code></li>
<li>获取主线程的RunLoop:<code>CFRunLoopGetMain();</code></li>
</ul>
<h4 id="RunLoop相关类">RunLoop相关类</h4><ul>
<li>Core Foundation中关于RunLoop的5个类<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
</li>
</ul>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/runloop.png" alt=""></p>
<h4 id="CFRunLoopModeRef">CFRunLoopModeRef</h4><ul>
<li><p>CFRunLoopModeRef代表RunLoop的运行模式</p>
</li>
<li><p>一个RunLoop包含若干个Mode,每个Mode又包含若干个Source/Timer/Observer</p>
</li>
<li><p>每次RunLoop启动时,只能指定其中一个Mode,这个Mode被称作CurrentMode<br><code>[[NSRunLoop currentRunLoop] currentMode];</code></p>
</li>
<li><p>如果需要切换Mode,只能退出Loop,再重新指定一个Mode进入</p>
</li>
<li><p>这样做主要是为了分隔开不同组Source/Timer/Observer,让其互不影响</p>
</li>
<li><p>系统默认注册了5个Mode:</p>
<ul>
<li>kCFRunLoopDefaultMode:App的默认Mode,通常主线程是这个Mode下运行</li>
<li>UITrackingRunLoop:界面跟踪Mode,用于ScrollView追踪触摸滑动,保证界面滑动时不受其他Mode影响</li>
<li>UIInitializationRunLoopMode:在刚启动App时进入的第一个Mode,启动完成后就不再使用</li>
<li>GSEventReceiverRunLoopMode:接收系统事件的内部Mode,通常用不到</li>
<li>kCFRunLoopCommonModes:这是一个占位用的Mode,不是一种真正的Mode(等价于kCFRunLoopDefaultMode + UITrackingRunLoop这2种模式)</li>
</ul>
</li>
<li><p>子线程中需要手动创建并启动NSRunLoop</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">NSRunLoop</span> mainRunLoop];</span><br><span class="line">    [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">    <span class="built_in">CFRunLoopGetMain</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line">	[thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">		<span class="comment">// add Source</span></span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[<span class="built_in">NSPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">		<span class="comment">//add Timer</span></span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这句相当于下面那句,如果RunLoop中没有Source、Timer、Observer那么这个RunLoop会自动结束并退出</span></span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">	    </span><br><span class="line">	    [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:&lt;<span class="preprocessor">#(NSString *)#&gt; beforeDate:<span class="title">&lt;#(NSDate *)#&gt;</span>];</span></span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CFRunLoopTimerRef">CFRunLoopTimerRef</h4><ul>
<li>CFRunLoopTimerRef是基于时间的触发器</li>
<li>CFRunLoopTimerRef基本上说的就是NSTimer,它受RunLoop的Mode影响</li>
<li>GCD的定时器不受RunLoop的Mode影响</li>
<li>基本上说的就是NSTimer</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用了scheduledTimer返回的定时器,已经自动被添加到当前RunLoop中,而且是NSDefaultRunLoopMode模式</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 修改模式</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];等价于下面2句</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 定时器只运行在NSDefaultRunLoopMode下,一旦RunLoop进入其他模式,这个定时器就不会工作</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器会跑在标记为common modes的模式下</span></span><br><span class="line"><span class="comment">// 标记为common modes的模式: UITrackingRunLoopMode和kCFRunLoopDefaultMode</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器只运行在UITrackingRunLoopMode下,一旦RunLoop进入其他模式,这个定时器就不会工作</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">UITrackingRunLoopMode</span>];</span><br></pre></td></tr></table></figure>
<h4 id="CFRunLoopSourceRef">CFRunLoopSourceRef</h4><ul>
<li><p>CFRunLoopSourceRef是事件源(输入源)</p>
</li>
<li><p>按照官方文档,Source的分类</p>
<ul>
<li>Port-Based Sources</li>
<li>Custom Input Sources</li>
<li>Cocoa Perform Selector Sources</li>
</ul>
</li>
<li><p>按照函数调用栈,Source的分类</p>
<ul>
<li>Source0:非基于Port</li>
<li>Source1:基于Port的,通过内核和其他线程通信,接收、分发系统事件</li>
</ul>
</li>
</ul>
<h4 id="CFRunLoopObserverRef">CFRunLoopObserverRef</h4><ul>
<li><p>CFRunLoopObserverRef是观察者,能够监听RunLoop的状态改变</p>
</li>
<li><p>可以监听的时间点有以下几个</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    k<span class="built_in">CFRunLoopEntry</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">//1 即将进入Loop </span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeTimers</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">//2 即将处理Timer </span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeSources</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">//4 即将处理Source </span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeWaiting</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">//32 即将进入休眠</span></span><br><span class="line">    k<span class="built_in">CFRunLoopAfterWaiting</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">//64 刚从休眠中唤醒</span></span><br><span class="line">    k<span class="built_in">CFRunLoopExit</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">//128 即将退出Loop</span></span><br><span class="line">    k<span class="built_in">CFRunLoopAllActivities</span> = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建observer</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), k<span class="built_in">CFRunLoopAllActivities</span>, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----监听到RunLoop状态发生改变---%zd"</span>, activity);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者:监听RunLoop的状态</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, k<span class="built_in">CFRunLoopDefaultMode</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    CF的内存管理（Core Foundation）</span><br><span class="line">    1.凡是带有Create、Copy、Retain等字眼的函数,创建出来的对象,都需要在最后做一次release</span><br><span class="line">    * 比如CFRunLoopObserverCreate</span><br><span class="line">    2.release函数:CFRelease(对象);</span><br><span class="line"> 	*/</span></span><br><span class="line">    <span class="comment">// 释放Observer</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/runloop_1.png" alt=""></p>
<h4 id="RunLoop应用">RunLoop应用</h4><ul>
<li>NSTimer</li>
<li>ImageView显示</li>
<li>PerformSelector</li>
<li>常驻线程</li>
<li>自动释放池</li>
</ul>
<h4 id="RunLoop面试题">RunLoop面试题</h4><ul>
<li>什么事RunLoop?<ul>
<li>从字面意思看:运行循环、跑圈</li>
<li>其实它内部就是do-while循环,在这个循环内部不断地处理各种任务(比如Source、Timer、Observer)</li>
<li>一个线程对应一个RunLoop,主线程的RunLoop默认已经启动,子线程的RunLoop得手动启动(调用Run方法)</li>
<li>RunLoop只能选择一个Mode启动,如果当前Mode中没有任何Source、Timer、Observer,那么久直接退出RunLoop</li>
</ul>
</li>
</ul>
<ul>
<li>你在开发过程中怎么使用RunLoop?什么应用场景?<ul>
<li>开启一个常驻线程(让一个子线程不进入消亡状态,等待其他线程发来消息,处理其他事件)<ul>
<li>在子线程中开启一个定时器</li>
<li>在子线程中进行一些长期监控一些行为</li>
</ul>
</li>
<li>可以控制定时器在特定模式下执行</li>
<li>可以让某些事件(行为、任务)在特定模式下执行</li>
<li>可以添加Observer监听RunLoop的状态,比如监听点击事件的处理(在所有点击事件之前做一些事情)</li>
</ul>
</li>
</ul>
<ul>
<li>自动释放池什么时候释放?<ul>
<li>在RunLoop睡眠之前释放(kCFRunLoopBeforeWaiting)</li>
</ul>
</li>
</ul>
<h4 id="GCD定时器">GCD定时器</h4><ul>
<li><p>创建GCD定时器 <code>dispatch_source_t dispatch_source_create(dispatch_source_type_t type,uintptr_t handle,unsigned long mask,dispatch_queue_t queue);</code></p>
</li>
<li><p>设置定时器的各种属性 <code>dispatch_source_set_timer(dispatch_source_t source,dispatch_time_t start,uint64_t interval,uint64_t leeway);</code></p>
</li>
<li><p>设置定时器处理任务 <code>dispatch_source_set_event_handler(dispatch_source_t source,dispatch_block_t handler);</code></p>
</li>
<li><p>启动定时器 <code>dispatch_resume(dispatch_object_t object);</code></p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="comment">/** 定时器(这里不用带*,因为dispatch_source_t就是个类,内部已经包含了*) */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    dispatch_time_t when = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">    </span><br><span class="line">    dispatch_after(when, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得队列</span></span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//dispatch_queue_t queue = dispatch_get_main_queue();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个定时器(dispatch_source_t本质还是个OC对象)</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.timer</span> = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置定时器的各种属性(何时开始任务,每隔多长时间执行一次)</span></span><br><span class="line">    <span class="comment">// GCD的时间参数,一般是纳秒（1秒 == 10的9次方纳秒）</span></span><br><span class="line">    <span class="comment">// 何时开始执行第一个任务</span></span><br><span class="line">    <span class="comment">// dispatch_time(DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC) 比当前时间晚3秒</span></span><br><span class="line">    dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">    uint64_t interval = (uint64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    dispatch_source_set_timer(<span class="keyword">self</span><span class="variable">.timer</span>, start, interval, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置回调</span></span><br><span class="line">    dispatch_source_set_event_handler(<span class="keyword">self</span><span class="variable">.timer</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"------------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">// 取消定时器</span></span><br><span class="line">            dispatch_cancel(<span class="keyword">self</span><span class="variable">.timer</span>);</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.timer</span> = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    dispatch_resume(<span class="keyword">self</span><span class="variable">.timer</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="什么是RunLoop">什么是RunLoop</h3><ul>
<li>从字面意思看<ul>
<li>运行循环</li>
<li>跑圈</li>
</ul>
</li>
<li>基本作用<ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件(比如触摸事件、定时器事件、Selector事件)</li>
<li>节省CPU资源,提高程序性能:该做事情时做事情,该休息时休息</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS单例模式]]></title>
    <link href="http://yoursite.com/2016/03/25/single_instance/"/>
    <id>http://yoursite.com/2016/03/25/single_instance/</id>
    <published>2016-03-25T02:32:46.000Z</published>
    <updated>2016-03-25T13:17:22.000Z</updated>
    <content type="html"><![CDATA[<h3 id="单例模式">单例模式</h3><ul>
<li>单例模式的作用<ul>
<li>可以保证在程序运行过程,一个类只有一个实例,而且该实例易于供外界访问</li>
<li>从而方便地控制了实例个数,并节约系统资源</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li>ARC中,单例模式的实现步骤<ul>
<li>在.m中保留一个全局的static的实例<code>static id _instance;</code></li>
<li><code>+ (instancetype)alloc</code>内部会调用<code>+ (instancetype)allocWithZone:(struct _NSZone *)zone</code></li>
<li>为了防止分配多个内存,我们需要重写NSObject的<code>+ (instancetype)allocWithZone:(struct _NSZone *)zone</code>,但是我们防止不了init多次,在这里创建唯一的实例(注意需要是线程安全的)</li>
<li>使用GCD的<code>static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^{});</code>来创建唯一的实例.</li>
<li>对外提供一个<code>+ (instancetype)sharedInstance</code>类方法来构造一个对象,这个方法中同样使用dispatch_once</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCPerson</span>() &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> MCPerson *_person;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _person = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedPerson</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _person = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将单例的实现抽成宏<ul>
<li>创建一个MCSingleton.h文件,将头文件和实现文件中的方法定义成宏</li>
<li>在使用的地方导入MCSingleton.h文件,头文件中使用MCSingletonH(Person),实现文件中使用MCSingletonM(Person)</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h文件</span></span><br><span class="line"><span class="preprocessor">#define XMGSingletonH(name) + (instancetype)shared##name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m文件</span></span><br><span class="line"><span class="preprocessor">#define XMGSingletonM(name) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance; \</span><br><span class="line"> \</span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone \</span><br><span class="line">&#123; \</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">        _instance = [<span class="keyword">super</span> allocWithZone:zone]; \</span><br><span class="line">    &#125;); \</span><br><span class="line">    <span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line"> \</span><br><span class="line">+ (instancetype)shared<span class="preprocessor">##name \</span></span><br><span class="line">&#123; \</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">        _instance = [[<span class="keyword">self</span> alloc] init]; \</span><br><span class="line">    &#125;); \</span><br><span class="line">    <span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line"> \</span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone \</span><br><span class="line">&#123; \</span><br><span class="line">    <span class="keyword">return</span> _instance; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>传统方式实现单例<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCPerson</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">nil</span>) &#123;</span><br><span class="line">            _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">nil</span>) &#123;</span><br><span class="line">            _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="单例模式">单例模式</h3><ul>
<li>单例模式的作用<ul>
<li>可以保证在程序运行过程,一个类只有一个实例,而且该实例易于供外界访问</li>
<li>从而方便地控制了实例个数,并节约系统资源</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS中的线程]]></title>
    <link href="http://yoursite.com/2016/03/24/gcd/"/>
    <id>http://yoursite.com/2016/03/24/gcd/</id>
    <published>2016-03-24T06:37:39.000Z</published>
    <updated>2016-03-28T13:28:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="多线程的基本概念">多线程的基本概念</h3><ul>
<li>创建线程是有开销的,iOS下主要成本包括:内核数据结构（大约1KB）、栈空间(子线程512KB、主线程1MB,也可以使用-setStackSize:设置,但必须是4K的倍数,而且最小是16K),创建线程大约需要90毫秒的创建时间</li>
</ul>
<h3 id="多线程的实现方案">多线程的实现方案</h3><a id="more"></a>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/thread.png" alt=""></p>
<h3 id="pthread的使用">pthread的使用</h3><p><code>int pthread_create(pthread_t * __restrict, const pthread_attr_t * __restrict,
        void *(*)(void *), void * __restrict);</code><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> * run(<span class="keyword">void</span> *param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">50000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"------buttonClick---%zd--%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)buttonClick:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    pthread_t thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_t thread2;</span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="NSThread的使用">NSThread的使用</h3><ul>
<li>如何创建并管理NSThread</li>
</ul>
<p><code>+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;// 直接创建并启动</code></p>
<p><code>- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0);//创建线程但是没有启动</code></p>
<p><code>+ (NSThread *)currentThread;</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) object:<span class="string">@"jack"</span>];</span><br><span class="line"><span class="comment">// 线程名字</span></span><br><span class="line">thread<span class="variable">.name</span> = <span class="string">@"mc"</span>;</span><br><span class="line"><span class="comment">// thread 是否是主线程</span></span><br><span class="line">[thread isMainThread];</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">[thread start];</span><br><span class="line"><span class="comment">// 取消线程</span></span><br><span class="line">[thread cancel];</span><br><span class="line"><span class="comment">//线程是否正在执行</span></span><br><span class="line">[thread executing];</span><br><span class="line"><span class="comment">//线程是否完成</span></span><br><span class="line">[thread finished];</span><br><span class="line"><span class="comment">//线程是否被取消</span></span><br><span class="line">[thread cancelled];</span><br><span class="line"><span class="comment">// 方法是否在主线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> isMainThread];</span><br><span class="line"><span class="comment">// 直接退出线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> exit]; </span><br><span class="line"><span class="comment">// 让线程睡眠2秒（阻塞2秒）</span></span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">[<span class="built_in">NSThread</span> sleepUntilDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br></pre></td></tr></table></figure>
<ul>
<li><p>NSObject 线程分类</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">NSThreadPerformAdditions</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(nullable <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line">    <span class="comment">// equivalent to the first method with kCFRunLoopCommonModes</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(nullable <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(nullable <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(nullable <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line">    <span class="comment">// equivalent to the first method with kCFRunLoopCommonModes</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(nullable <span class="keyword">id</span>)arg <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取2个时间间隔</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDate</span> *begin = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSDate</span> *end = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, [end timeIntervalSinceDate:begin]);</span><br><span class="line"><span class="built_in">CFTimeInterval</span> begin = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"><span class="built_in">CFTimeInterval</span> end = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, end - begin);</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程安全</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saleTicket&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">@synchronized</span>(<span class="keyword">self</span>)&#123;</span><br><span class="line">            <span class="comment">// 先取出总数</span></span><br><span class="line">            <span class="built_in">NSInteger</span> count = <span class="keyword">self</span><span class="variable">.ticketCount</span>;</span><br><span class="line">             <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">self</span><span class="variable">.ticketCount</span> = count - <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@卖了一张票，还剩下%zd张"</span>, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>, <span class="keyword">self</span><span class="variable">.ticketCount</span>);</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"票已经卖完了"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="GCD">GCD</h3><ul>
<li>全称是Grand Central Dispatch,可译为”牛逼的中枢调度器”</li>
<li>GCD中有2个核心概念:任务-执行什么操作,队列-用来存放任务</li>
<li>GCD的使用就2个步骤<ul>
<li>定制任务(确定想做的事情)</li>
<li>将任务添加到队列中(GCD会自动将队列中的任务取出,放到对应的线程中执行,任务的取出遵循队列的FIFO)</li>
</ul>
</li>
</ul>
<h4 id="执行任务">执行任务</h4><ul>
<li>GCD中有2个用来执行任务的常用函数<ul>
<li>同步的方式执行任务(只能在当前线程中执行任务,不具备开启新线程的能力)<br><code>dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code></li>
<li>异步的方式执行任务(可以在新的线程中执行任务,具备开启新线程的能力)<br><code>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code></li>
<li><code>dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</code>在前面的任务执行结束后它才执行,而且它后面的任务等它执行完成之后才会执行,这个queue不能是全局的并发队列</li>
</ul>
</li>
</ul>
<h4 id="队列的类型">队列的类型</h4><ul>
<li>并发队列<ul>
<li>可以让多个任务并发(同时)执行(自动开启多个线程同时执行任务)</li>
<li>并发功能只有在异步(dispatch_async)函数下才有效</li>
</ul>
</li>
<li>串行队列<ul>
<li>让任务一个接着一个执行</li>
</ul>
</li>
</ul>
<h4 id="并发队列">并发队列</h4><ul>
<li>使用dispatch_queue_create函数创建队列</li>
<li>GCD默认已经提供全局的并发队列,供整个程序使用,可以无需手动创建<ul>
<li>使用dispatch_get_global_queue函数获取全局的并发队列<br><code>dispatch_queue_t
dispatch_get_global_queue(long identifier, unsigned long flags);//identifier队列的优先级  flags此参数无用,用0即可</code></li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 异步函数 + 并发队列:可以同时开启多条线程</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncConcurrent</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建一个并发队列</span></span><br><span class="line"><span class="comment">// label:队列名字</span></span><br><span class="line"><span class="comment">// attr:队列类型-DISPATCH_QUEUE_SERIAL  DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t attr);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span><br><span class="line"><span class="preprocessor">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span><br><span class="line"><span class="preprocessor">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span><br><span class="line"><span class="preprocessor">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br><span class="line"><span class="comment">// 获得全局的并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将任务加入队列</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 同步函数 + 并发队列:不会开启新的线程</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncConcurrent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.获得全局的并发队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 异步函数 + 串行队列:会开启新的线程,但是任务是串行的,执行完一个任务,再执行下一个任务</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncSerial</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建串行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mc.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 同步函数 + 串行队列:不会开启新的线程,在当前线程执行任务。任务是串行的,执行完一个任务,再执行下一个任务</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncSerial</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建串行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mc.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 异步函数 + 主队列:只在主线程中执行任务</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncMain</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.获得主队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 同步函数 + 主队列:导致等待阻塞</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncMain</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 1.获得主队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>线程间通信<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="GCD的其它常用函数">GCD的其它常用函数</h4><ul>
<li><code>dispatch_barrier_async</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)barrier</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"mc"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----2-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----barrier-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----3-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----4-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>一次性代码,使用dispatch_once函数能保证某代码在程序运行过程中只被执行1次</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">//只执行1次的代码(这里是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>延迟执行</p>
<ul>
<li><code>- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</code></li>
<li><code>dispatch_after(dispatch_time_t when,dispatch_queue_t queue,dispatch_block_t block);</code></li>
<li><code>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</code></li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 延迟执行</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)delay</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(run) withObject:<span class="literal">nil</span> afterDelay:<span class="number">2.0</span>];</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"run-----"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>快速迭代: <code>dispatch_apply(size_t iterations, dispatch_queue_t queue,void (^block)(size_t));</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 快速迭代</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)apply</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *from = <span class="string">@"/Users/weifeng/Desktop/From"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *to = <span class="string">@"/Users/weifeng/Desktop/To"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSArray</span> *subpaths = [mgr subpathsAtPath:from];</span><br><span class="line">    </span><br><span class="line">    dispatch_apply(subpaths<span class="variable">.count</span>, queue, ^(size_t index) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *subpath = subpaths[index];</span><br><span class="line">        <span class="built_in">NSString</span> *fromFullpath = [from stringByAppendingPathComponent:subpath];</span><br><span class="line">        <span class="built_in">NSString</span> *toFullpath = [to stringByAppendingPathComponent:subpath];</span><br><span class="line">        <span class="comment">// 剪切</span></span><br><span class="line">        [mgr moveItemAtPath:fromFullpath toPath:toFullpath error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@---%@"</span>, [<span class="built_in">NSThread</span> currentThread], subpath);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列组">队列组</h4><ul>
<li><code>dispatch_group_async(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block);</code><br><code>dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block);</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)group</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建一个队列组</span></span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.下载图片1</span></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.image1</span> = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.下载图片2</span></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://pic38.nipic.com/20140228/5571398_215900721128_2.jpg"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.image2</span> = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.将图片1、图片2合成一张新的图片</span></span><br><span class="line">    dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">        <span class="comment">// 开启新的图形上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制图片</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.image1</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)];</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.image2</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取得上下文中的图片</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结束上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程显示图片</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="comment">// 4.将新图片显示出来 </span></span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NSOperation">NSOperation</h4><ul>
<li><p>NSOperation的作用</p>
<ul>
<li>配合使用NSOperation和NSOperationQueue也能实现多线程编程</li>
</ul>
</li>
<li><p>NSOperation和NSOperationQueue实现多线程的具体步骤</p>
<ul>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperationQueue中NSOperation取出来</li>
<li>将取出的NSOperation封装的操作放到一条新线程中执行</li>
</ul>
</li>
</ul>
<h4 id="NSOperation的子类">NSOperation的子类</h4><ul>
<li><p>NSOperation是个抽象类,并不具备封装操作的能力,必须使用它的子类</p>
</li>
<li><p>使用NSOperation子类的方式有3种</p>
<ul>
<li>NSInvocationOperation</li>
<li>NSBlockOperation</li>
<li>自定义子类继承NSOperation,实现内部相应的方法</li>
</ul>
</li>
<li><p>将任务包装起来调用NSOperation start就可以执行任务了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invocationOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)blockOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="comment">// 在主线程</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载1------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加额外的任务(在子线程执行)</span></span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载2------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载3------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载4------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="NSOperationQueue">NSOperationQueue</h4><ul>
<li>NSOperationQueue的作用<ul>
<li>NSOperation可以调用start方法执行任务,但默认是同步执行的</li>
<li>如果将NSOperation添加到NSOperationQueue(操作队列)中,系统会自动异步执行NSOperation中的操作</li>
</ul>
</li>
</ul>
<h5 id="GCD的队列类型">GCD的队列类型</h5><ul>
<li>并发队列<ul>
<li>自己创建的</li>
<li>全局的</li>
</ul>
</li>
<li>串行队列<ul>
<li>主队列</li>
<li>自己创建的</li>
</ul>
</li>
</ul>
<h5 id="NSOperationQueue的队列类型">NSOperationQueue的队列类型</h5><ul>
<li><p>主队列</p>
<ul>
<li>[NSOperationQueue mainQueue]</li>
<li>凡是添加到主队列中的任务(NSOperation),都会放到主队列中执行</li>
</ul>
</li>
<li><p>非主队列(其它队列)</p>
<ul>
<li>[[NSOperationQueue alloc] init]</li>
<li>同时包含了:串行、并发功能</li>
<li>添加到这种队列中的任务(NSOperation),就会自动放到子线程中执行</li>
</ul>
</li>
<li><p>NSOperationQueue<br><code>- (void)addOperation:(NSOperation *)op;</code><br><code>- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait;</code><br><code>- (void)addOperationWithBlock:(void (^)(void))block;</code><br><code>@property (readonly) NSUInteger operationCount;//任务数量</code><br><code>@property NSInteger maxConcurrentOperationCount;//最大的并发数量,如果设置为1则是串行,为0则不执行任何任务</code><br><code>@property (getter=isSuspended) BOOL suspended;//获取或者设置是否挂起任务</code><br><code>@property (nullable, copy) NSString *name;//获取或者设置队列名字</code><br><code>- (void)cancelAllOperations;//取消所有任务,但是正在执行的不会被取消</code><br><code>- (void)waitUntilAllOperationsAreFinished;</code><br><code>+ (nullable NSOperationQueue *)currentQueue;当前队列</code><br><code>+ (NSOperationQueue *)mainQueue;//主队列</code></p>
</li>
</ul>
<ul>
<li><p>NSInvocationOperation<br><code>- (nullable instancetype)initWithTarget:(id)target selector:(SEL)sel object:(nullable id)arg;</code><br><code>- (instancetype)initWithInvocation:(NSInvocation *)inv</code></p>
</li>
<li><p>NSBlockOperation<br><code>+ (instancetype)blockOperationWithBlock:(void (^)(void))block;</code><br><code>- (void)addExecutionBlock:(void (^)(void))block;</code><br><code>@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks;</code></p>
</li>
<li><p>NSOperation<br><code>- (void)start;//执行任务</code><br><code>- (void)main;//自定义NSOperation需要重写该方法,将任务需要做的事情写到这个方法当中,官方建议在这个方法当中如果有耗时的操作使用isCancelled判断下是否需结束该任务</code><br><code>- (void)cancel;//取消任务</code><br><code>@property (readonly, getter=isExecuting) BOOL executing;</code><br><code>@property (readonly, getter=isFinished) BOOL finished;</code><br><code>- (void)addDependency:(NSOperation *)op;//添加任务依赖</code><br><code>- (void)removeDependency:(NSOperation *)op;//移除任务依赖</code><br><code>@property (nullable, copy) void (^completionBlock)(void);//监听任务的完成会执行这个block</code></p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)operationQueueTest&#123;</span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置最大并发操作数</span></span><br><span class="line">    <span class="comment">// queue.maxConcurrentOperationCount = 2;</span></span><br><span class="line">    queue<span class="variable">.maxConcurrentOperationCount</span> = <span class="number">1</span>; <span class="comment">// 就变成了串行队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建操作(任务)</span></span><br><span class="line">    <span class="comment">// 创建NSInvocationOperation</span></span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(download) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建NSBlockOperation</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download1 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [op1 addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download2 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加操作到队列中</span></span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download3 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加任务到队列中</span></span><br><span class="line">    [queue addOperation:op1]; <span class="comment">// [op1 start]</span></span><br><span class="line">    [queue addOperation:op2]; <span class="comment">// [op2 start]</span></span><br><span class="line">    [queue addOperation:[[MCOperation alloc] init]];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.queue</span><span class="variable">.isSuspended</span>) &#123;</span><br><span class="line">        <span class="comment">// 恢复队列，继续执行</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.queue</span><span class="variable">.suspended</span> = <span class="literal">NO</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 暂停（挂起）队列，暂停执行</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.queue</span><span class="variable">.suspended</span> = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.queue</span> cancelAllOperations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCOperation</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 需要执行的任务</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download1 -%zd-- %@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download2 -%zd-- %@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download3 -%zd-- %@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)operationDependency</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不能相互依赖</span></span><br><span class="line">    <span class="comment">// 可以在不同queue的NSOperation之间创建依赖关系</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download1----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download2----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download3----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op4 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"download4----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op5 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download5----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 监听op5任务执行完毕会调用这个block</span></span><br><span class="line">    op5<span class="variable">.completionBlock</span> = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"op5执行完毕---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置依赖</span></span><br><span class="line">    [op3 addDependency:op1];</span><br><span class="line">    [op3 addDependency:op2];</span><br><span class="line">    [op3 addDependency:op4];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];</span><br><span class="line">    [queue addOperation:op4];</span><br><span class="line">    [queue addOperation:op5];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="线程之间的通讯">线程之间的通讯</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 线程之间的通信</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    [[[<span class="built_in">NSOperationQueue</span> alloc] init] addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">       <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg"</span>];</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 合成图片</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    __block <span class="built_in">UIImage</span> *image1 = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 下载图片1</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *download1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        image1 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    __block <span class="built_in">UIImage</span> *image2 = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 下载图片2</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *download2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://pic38.nipic.com/20140228/5571398_215900721128_2.jpg"</span>];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        image2 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合成图片</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *combine = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="comment">// 开启新的图形上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制图片</span></span><br><span class="line">        [image1 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)];</span><br><span class="line">        image1 = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        [image2 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)];</span><br><span class="line">        image2 = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取得上下文中的图片</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结束上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    [combine addDependency:download1];</span><br><span class="line">    [combine addDependency:download2];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:download1];</span><br><span class="line">    [queue addOperation:download2];</span><br><span class="line">    [queue addOperation:combine];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="多线程的基本概念">多线程的基本概念</h3><ul>
<li>创建线程是有开销的,iOS下主要成本包括:内核数据结构（大约1KB）、栈空间(子线程512KB、主线程1MB,也可以使用-setStackSize:设置,但必须是4K的倍数,而且最小是16K),创建线程大约需要90毫秒的创建时间</li>
</ul>
<h3 id="多线程的实现方案">多线程的实现方案</h3>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[const和指针]]></title>
    <link href="http://yoursite.com/2016/03/24/const_point/"/>
    <id>http://yoursite.com/2016/03/24/const_point/</id>
    <published>2016-03-24T05:44:56.000Z</published>
    <updated>2016-03-24T13:37:21.000Z</updated>
    <content type="html"><![CDATA[<h3 id="const和宏的区别">const和宏的区别</h3><ul>
<li><p>相同点:</p>
<ul>
<li>值是常量,不能动态更改 </li>
<li>更改后,其它使用到的地方会自动更改</li>
</ul>
</li>
<li><p>不同点:</p>
<ul>
<li>宏:会产生很多临时空间</li>
<li>const:<ul>
<li>只有一份内存</li>
<li>写在外面是全局常量</li>
<li>不能运行时修改常量值</li>
<li>加上static之后只能在本文件访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="const与指针">const与指针</h3><ul>
<li>看const右边整体是什么,什么就不能修改.<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p2;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 定义一个指针变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">NULL</span>;(等同于 <span class="keyword">int</span> <span class="keyword">const</span> *p = <span class="literal">NULL</span>;)</span><br><span class="line"><span class="comment">// p指向a</span></span><br><span class="line">p = &amp;a;(可以修改)</span><br><span class="line"><span class="comment">//*p = 20;(*p不能改,const后面是*p所以不能改)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;c;(p不能被修改,一开始指向什么,以后都不能更改)</span><br><span class="line">*p = <span class="number">30</span>;(但是可以修改它指向的变量c的值)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值传递比较有用,想让别人不更改你的值可以通过这种方式使用</span></span><br><span class="line"><span class="keyword">void</span> test(<span class="keyword">const</span> <span class="keyword">int</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//*p = 100;(不能修改*p的值)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修饰指针,指针不能更改</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> NAME = <span class="string">@""</span>;</span><br><span class="line"><span class="comment">//不能修改</span></span><br><span class="line"><span class="comment">//NAME = @"123";</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="const和宏的区别">const和宏的区别</h3><ul>
<li><p>相同点:</p>
<ul>
<li>值是常量,不能动态更改 </li>
<li>更改后,其它使用到的地方会自动更改</li>
</ul>
</li>
<li><p>不同点:</p>
<ul>
<li>宏:会产生很多临时空间</li>
<li>const:<ul>
<li>只有一份内存</li>
<li>写在外面是全局常量</li>
<li>不能运行时修改常量值</li>
<li>加上static之后只能在本文件访问</li>
</ul>
</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIScrollView常见功能]]></title>
    <link href="http://yoursite.com/2016/03/24/uiscrollview_common_feature/"/>
    <id>http://yoursite.com/2016/03/24/uiscrollview_common_feature/</id>
    <published>2016-03-24T05:25:49.000Z</published>
    <updated>2016-03-28T13:21:20.000Z</updated>
    <content type="html"><![CDATA[<h3 id="子控件悬停">子控件悬停</h3><ul>
<li>获取UIScrollView垂直方向上的滚动距离来动态调整子控件的frame并将子控件添加到最顶层父控件或者UIScrollView上</li>
</ul>
<h3 id="下拉放大">下拉放大</h3><ul>
<li>获取UIScrollView垂直方向上的滚动距离,计算一个scale值,通过改变控件的形变来实现缩放 </li>
</ul>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">UIScrollViewDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *redView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *blueView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIScrollView</span> *scrollView;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="number">0</span>, <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span><span class="variable">.blueView</span><span class="variable">.frame</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;UIScrollViewDelegate&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageH = <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> offsetY = scrollView<span class="variable">.contentOffset</span><span class="variable">.y</span>;</span><br><span class="line">    <span class="keyword">if</span> (offsetY &gt;= imageH) &#123;</span><br><span class="line">        <span class="comment">// 将红色控件添加到控制器的view中,设置Y值为0</span></span><br><span class="line">        <span class="built_in">CGRect</span> redF = <span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.frame</span>;</span><br><span class="line">        redF<span class="variable">.origin</span><span class="variable">.y</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.frame</span> = redF;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.view</span> addSubview:<span class="keyword">self</span><span class="variable">.redView</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将红色控件添加到scrollView中,设置Y值为图片的高度</span></span><br><span class="line">        <span class="built_in">CGRect</span> redF = <span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.frame</span>;</span><br><span class="line">        redF<span class="variable">.origin</span><span class="variable">.y</span> = <span class="number">140</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.frame</span> = redF;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.scrollView</span> addSubview:<span class="keyword">self</span><span class="variable">.redView</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> scale = <span class="number">1</span> - (offsetY / <span class="number">70</span>);</span><br><span class="line">    scale = (scale &gt;= <span class="number">1</span>) ? scale : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeScale</span>(scale, scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="UIScrollView内部子控件添加约束的注意点">UIScrollView内部子控件添加约束的注意点</h3><ul>
<li><p>子控件的尺寸不能通过UIScrollView来计算,可以考虑通过以下方式计算</p>
<ul>
<li>可以设置固定值（width==100,height==300）</li>
<li>可以相对于UIScrollView以外的其他控件来计算尺寸</li>
</ul>
</li>
<li><p>UIScrollView的frame应该通过子控件以外的其他控件来计算</p>
</li>
<li><p>UIScrollView的contentSize通过子控件来计算</p>
<ul>
<li>根据子控件的尺寸以及子控件与UIScrollView之间的间距</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="子控件悬停">子控件悬停</h3><ul>
<li>获取UIScrollView垂直方向上的滚动距离来动态调整子控件的frame并将子控件添加到最顶层父控件或者UIScrollView上</li>
</ul>
<h3 id="下拉放大">下拉放大</h3><ul>
<li>获取UIScrollView垂直方向上的滚动距离,计算一个scale值,通过改变控件的形变来实现缩放 </li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[网易新闻项目]]></title>
    <link href="http://yoursite.com/2016/03/24/ios_news/"/>
    <id>http://yoursite.com/2016/03/24/ios_news/</id>
    <published>2016-03-24T02:08:49.000Z</published>
    <updated>2016-03-24T13:20:49.000Z</updated>
    <content type="html"><![CDATA[<h3 id="网易新闻项目知识点">网易新闻项目知识点</h3><ul>
<li><p>自定义MCHomeViewController继承自UIViewController</p>
</li>
<li><p>Main.storyboard 添加导航控制器为初始化控制器,添加UIViewController为导航控制器的根控制器并设置其Class类型为MCHomeViewController,为UIViewController添加2个UIScrollView并设置好约束,设置contentScrollView代理为MCHomeViewController</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>自定义MCSocialViewController继承自UITableViewController并实现好数据源方法</p>
</li>
<li><p>在MCHomeViewController.m中初始化多个MCSocialViewController并通过addChildViewController方式添加到控制器中</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加子控制器</span></span><br><span class="line">    [<span class="keyword">self</span> setupChildVc];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加标题</span></span><br><span class="line">    [<span class="keyword">self</span> setupTitle];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认显示第0个子控制器</span></span><br><span class="line">    [<span class="keyword">self</span> scrollViewDidEndScrollingAnimation:<span class="keyword">self</span><span class="variable">.contentScrollView</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setupChildVc</span><br><span class="line">&#123;</span><br><span class="line">    MCSocialViewController *social0 = [[MCSocialViewController alloc] init];</span><br><span class="line">    social0<span class="variable">.title</span> = <span class="string">@"国际"</span>;</span><br><span class="line">    [<span class="keyword">self</span> addChildViewController:social0];</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为顶部的titleScrollView添加多个标题并设置其滚动视图的contentSize和contentScrollView的contentSize</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 添加标题</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setupTitle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义临时变量</span></span><br><span class="line">    <span class="built_in">CGFloat</span> labelW = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> labelY = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> labelH = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加label</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">        XMGHomeLabel *label = [[XMGHomeLabel alloc] init];</span><br><span class="line">        label<span class="variable">.text</span> = [<span class="keyword">self</span><span class="variable">.childViewControllers</span>[i] title];</span><br><span class="line">        <span class="built_in">CGFloat</span> labelX = i * labelW;</span><br><span class="line">        label<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(labelX, labelY, labelW, labelH);</span><br><span class="line">        [label addGestureRecognizer:[[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(labelClick:)]];</span><br><span class="line">        label<span class="variable">.tag</span> = i;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.titleScrollView</span> addSubview:label];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 最前面的label</span></span><br><span class="line">            label<span class="variable">.scale</span> = <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置contentSize</span></span><br><span class="line">	<span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="number">7</span> * labelW, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 这里设置contentScrollView.contentSize宽高不能根据self.contentScrollView.frame.size 因为viewDidLoad从storyboard加载的时候尺寸是600*600,在执行- (void)viewDidAppear:(BOOL)animated时候能得到真正的尺寸,并且contentScrollView添加过约束,所以最后才能得到其准确的frame</span></span><br><span class="line">	<span class="keyword">self</span><span class="variable">.contentScrollView</span><span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="number">7</span> * [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理顶部标题点击事件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)labelClick:(<span class="built_in">UITapGestureRecognizer</span> *)tap</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出被点击label的索引</span></span><br><span class="line">    <span class="built_in">NSInteger</span> index = tap<span class="variable">.view</span><span class="variable">.tag</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让底部的内容scrollView滚动到对应位置</span></span><br><span class="line">    <span class="built_in">CGPoint</span> offset = <span class="keyword">self</span><span class="variable">.contentScrollView</span><span class="variable">.contentOffset</span>;</span><br><span class="line">    offset<span class="variable">.x</span> = index * <span class="keyword">self</span><span class="variable">.contentScrollView</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.contentScrollView</span> setContentOffset:offset animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理滚动动画结束后,显示对应位置的控制器并将对应位置的标题显示在中间</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * scrollView结束了滚动动画以后就会调用这个方法(比如- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;方法执行的动画完毕后)</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一些临时变量</span></span><br><span class="line">    <span class="built_in">CGFloat</span> width = scrollView<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> height = scrollView<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> offsetX = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前位置需要显示的控制器的索引</span></span><br><span class="line">    <span class="built_in">NSInteger</span> index = offsetX / width;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让对应的顶部标题居中显示</span></span><br><span class="line">    <span class="built_in">UILabel</span> *label = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span>[index];</span><br><span class="line">    <span class="built_in">CGPoint</span> titleOffset = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.contentOffset</span>;</span><br><span class="line">    titleOffset<span class="variable">.x</span> = label<span class="variable">.center</span><span class="variable">.x</span> - width * <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 左边超出处理</span></span><br><span class="line">    <span class="keyword">if</span> (titleOffset<span class="variable">.x</span> &lt; <span class="number">0</span>) titleOffset<span class="variable">.x</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 右边超出处理</span></span><br><span class="line">    <span class="built_in">CGFloat</span> maxTitleOffsetX = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.contentSize</span><span class="variable">.width</span> - width;</span><br><span class="line">    <span class="keyword">if</span> (titleOffset<span class="variable">.x</span> &gt; maxTitleOffsetX) titleOffset<span class="variable">.x</span> = maxTitleOffsetX;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.titleScrollView</span> setContentOffset:titleOffset animated:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让其他label回到最初的状态</span></span><br><span class="line">    <span class="keyword">for</span> (MCHomeLabel *otherLabel <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (otherLabel != label) otherLabel<span class="variable">.scale</span> = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出需要显示的控制器</span></span><br><span class="line">    <span class="built_in">UIViewController</span> *willShowVc = <span class="keyword">self</span><span class="variable">.childViewControllers</span>[index];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前位置的位置已经显示过了,就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ([willShowVc isViewLoaded]) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//if (willShowVc.view.superview) return;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加控制器的view到contentScrollView中;</span></span><br><span class="line">    willShowVc<span class="variable">.view</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(offsetX, <span class="number">0</span>, width, height);</span><br><span class="line">    [scrollView addSubview:willShowVc<span class="variable">.view</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理手指滑动松开scrollView后显示对应位置的控制器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 手指松开scrollView后,scrollView停止减速完毕就会调用这个</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> scrollViewDidEndScrollingAnimation:scrollView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理滚动contentScrollView时标题缩放变色</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 只要scrollView在滚动，就会调用</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span> / scrollView<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="keyword">if</span> (scale &lt; <span class="number">0</span> || scale &gt; <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span><span class="variable">.count</span> - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得需要操作的左边label</span></span><br><span class="line">    <span class="built_in">NSInteger</span> leftIndex = scale;</span><br><span class="line">    MCHomeLabel *leftLabel = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span>[leftIndex];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得需要操作的右边label</span></span><br><span class="line">    <span class="built_in">NSInteger</span> rightIndex = leftIndex + <span class="number">1</span>;</span><br><span class="line">    MCHomeLabel *rightLabel = (rightIndex == <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span><span class="variable">.count</span>) ? <span class="literal">nil</span> : <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span>[rightIndex];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右边比例</span></span><br><span class="line">    <span class="built_in">CGFloat</span> rightScale = scale - leftIndex;</span><br><span class="line">    <span class="comment">// 左边比例</span></span><br><span class="line">    <span class="built_in">CGFloat</span> leftScale = <span class="number">1</span> - rightScale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置label的比例</span></span><br><span class="line">    leftLabel<span class="variable">.scale</span> = leftScale;</span><br><span class="line">    rightLabel<span class="variable">.scale</span> = rightScale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装titleLabel</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCHomeLabel</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.font</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> colorWithRed:MCRed green:M<span class="built_in">CGreen</span> blue:MCBlue alpha:<span class="number">1.0</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.textAlignment</span> = <span class="built_in">NSTextAlignmentCenter</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.userInteractionEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setScale:(<span class="built_in">CGFloat</span>)scale</span><br><span class="line">&#123;</span><br><span class="line">    _scale = scale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//      R G B</span></span><br><span class="line">    <span class="comment">// 默认：0.4 0.6 0.7</span></span><br><span class="line">    <span class="comment">// 红色：1   0   0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> red = MCRed + (<span class="number">1</span> - XMGRed) * scale;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = M<span class="built_in">CGreen</span> + (<span class="number">0</span> - XMGGreen) * scale;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = MCBlue + (<span class="number">0</span> - XMGBlue) * scale;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大小缩放比例</span></span><br><span class="line">    <span class="built_in">CGFloat</span> transformScale = <span class="number">1</span> + scale * <span class="number">0.3</span>; <span class="comment">// [1, 1.3]</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeScale</span>(transformScale, transformScale);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="网易新闻项目知识点">网易新闻项目知识点</h3><ul>
<li><p>自定义MCHomeViewController继承自UIViewController</p>
</li>
<li><p>Main.storyboard 添加导航控制器为初始化控制器,添加UIViewController为导航控制器的根控制器并设置其Class类型为MCHomeViewController,为UIViewController添加2个UIScrollView并设置好约束,设置contentScrollView代理为MCHomeViewController</p>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[static与copy关键字]]></title>
    <link href="http://yoursite.com/2016/03/23/static_copy/"/>
    <id>http://yoursite.com/2016/03/23/static_copy/</id>
    <published>2016-03-23T06:55:35.000Z</published>
    <updated>2016-03-25T13:16:53.000Z</updated>
    <content type="html"><![CDATA[<h3 id="static的作用">static的作用</h3><h4 id="修饰局部变量">修饰局部变量</h4><ul>
<li>让局部变量只初始化一次</li>
<li>局部变量在程序中只有一份内存</li>
<li>并不会改变局部变量的作用域,仅仅是改变了局部变量的生命周期(只到程序结束，这个局部变量才会销毁)</li>
</ul>
<a id="more"></a>
<h4 id="static修饰全局变量">static修饰全局变量</h4><ul>
<li>全局变量的作用域仅限于当前文件</li>
</ul>
<h4 id="全局变量">全局变量</h4><ul>
<li>作用范围:整个程序</li>
<li>外部通过extern来访问全局变量(例如:<code>extern int age;</code>)</li>
<li>任何全局变量是不安全的,随时都可能被外部修改</li>
</ul>
<h3 id="实现拷贝的方法">实现拷贝的方法</h3><ul>
<li><p>copy</p>
<ul>
<li>只会产生不可变的副本对象(比如NSString),如果对不可变对象调用copy,不会产生新对象(浅拷贝-指针拷贝),反之会产生新对象(深度拷贝-内容拷贝)</li>
</ul>
</li>
<li><p>mutableCopy</p>
<ul>
<li>只会产生可变的副本对象(比如NSMutableString),都会产生新对象(深度拷贝-内容拷贝)</li>
</ul>
</li>
<li><p>自定义对象的copy</p>
<ul>
<li>自定义对象需要遵守NSCopying协议实现下面的方法<br><code>- (id)copyWithZone:(nullable NSZone *)zone;</code><br><code>- (id)mutableCopyWithZone:(nullable NSZone *)zone;</code></li>
<li>copy 会调用自定义对象的 copyWithZone</li>
<li><p>mutableCopy 会调用自定义对象的 mutableCopyWithZone</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCPerson</span>() &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    MCPerson *person = [[MCPerson allocWithZone:zone] init];</span><br><span class="line">    person<span class="variable">.age</span> = <span class="keyword">self</span><span class="variable">.age</span>;</span><br><span class="line">    person<span class="variable">.money</span> = <span class="keyword">self</span><span class="variable">.money</span>;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>@property中的copy</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">//如果是strong则其set方法是:</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">//如果是copy则其set方法是:</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    _name = [name <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> copyProperty()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *string = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"jack"</span>];</span><br><span class="line">    </span><br><span class="line">    MCPerson *p = [[MCPerson alloc] init];</span><br><span class="line">    p<span class="variable">.name</span> = string;</span><br><span class="line">    <span class="comment">//[p setName:string];</span></span><br><span class="line">    </span><br><span class="line">    [string appendString:<span class="string">@" rose"</span>];</span><br><span class="line">    <span class="comment">//如果property中是strong 则输出是"jack rose",copy则输出"jack"</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, p<span class="variable">.name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** name属性值永远是不可变，所以定义为NSMutableString是不合理的 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableString</span> *name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="static的作用">static的作用</h3><h4 id="修饰局部变量">修饰局部变量</h4><ul>
<li>让局部变量只初始化一次</li>
<li>局部变量在程序中只有一份内存</li>
<li>并不会改变局部变量的作用域,仅仅是改变了局部变量的生命周期(只到程序结束，这个局部变量才会销毁)</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS父子控制器]]></title>
    <link href="http://yoursite.com/2016/03/23/parent_childs_vc/"/>
    <id>http://yoursite.com/2016/03/23/parent_childs_vc/</id>
    <published>2016-03-23T02:09:28.000Z</published>
    <updated>2016-03-23T13:46:23.000Z</updated>
    <content type="html"><![CDATA[<h3 id="父子控制器">父子控制器</h3><ul>
<li><p>UIViewController 添加子控制器<br><code>- (void)addChildViewController:(UIViewController *)childController</code></p>
</li>
<li><p>将当前控制器从父控制器中移除<br><code>- (void) removeFromParentViewController</code></p>
</li>
<li><p>获取当前控制器的所有子控制器<br><code>@property(nonatomic,readonly) NSArray&lt;__kindof UIViewController *&gt; *childViewControllers</code></p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>获取当前控制器的父控制器<br><code>@property(nullable,nonatomic,weak,readonly) UIViewController *parentViewController;</code></p>
</li>
<li><p>获取当前控制器的所属导航控制器<br>系统会通过父子关系的链条来找到它的导航控制器,如果找不到则<code>self.navigationController</code>的值为nil<br><code>@property(nullable, nonatomic,readonly,strong) UINavigationController *navigationController;</code></p>
</li>
<li><p><code>[self dismissViewControllerAnimated:YES completion:nil];</code> 系统会检测当前控制器是不是被Modal出来的,如果不是则会检测它的父控制器,如果都不是则不能dismiss.</p>
</li>
<li><p>默认情况下,所有控制器view的autoresizingMask属性都包含了UIViewAutoresizingFlexibleWidth和UIViewAutoresizingFlexibleHeight两个值.如果从xib中加载控制器 尺寸是600*600,往控制器里面添加子控制器或者view的时候可能导致看不见,这个时候需要关掉子控制器的自动伸缩功能<br><code>vc.view.autoresizingMask = UIViewAutoresizingNone;</code></p>
</li>
<li><p>当前控制器已经被添加到某个父控制器上或者从父控制器上移除的时候就会调用这个方法,如果是通过addChildViewController方式添加的子控制器是不会调用didMoveToParentViewController,但是可以在addChildViewController之后手动调用didMoveToParentViewController<br><code>- (void)didMoveToParentViewController:(nullable UIViewController *)parent</code></p>
</li>
<li><p>控制器automaticallyAdjustsScrollViewInsets属性默认值为YES,如果当前控制器是导航控制器并且第一个子View是UIScrollView则会自动调整第一个UIScrollView内边距,但是不会自动调整后面的UIScrollView内边距.如果第一个View不是UIScrollView则不会调整后面UIScrollView的内边距<br><code>self.automaticallyAdjustsScrollViewInsets = NO;//不会自动去调整uiscrollView的contentInset属性</code></p>
</li>
</ul>
<h3 id="转场动画">转场动画</h3><ul>
<li><p>动画效果:<br>@”cube” @”moveIn” @”reveal” @”fade”(default) @”pageCurl” @”pageUnCurl” @”suckEffect” @”rippleEffect” @”oglFlip” @”push”</p>
</li>
<li><p>动画方向:<br>kCATransitionFromRight;<br>kCATransitionFromLeft;<br>kCATransitionFromTop;<br>kCATransitionFromBottom;</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CATransition</span> *animation = [<span class="built_in">CATransition</span> animation];</span><br><span class="line">animation<span class="variable">.type</span> = <span class="string">@"cube"</span>;</span><br><span class="line">animation<span class="variable">.subtype</span> = index &gt; oldIndex ? k<span class="built_in">CATransitionFromRight</span> : k<span class="built_in">CATransitionFromLeft</span>;</span><br><span class="line">animation<span class="variable">.duration</span> = <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">//动画的开始与结束的快慢</span></span><br><span class="line">animation<span class="variable">.timingFunction</span> = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:k<span class="built_in">CAMediaTimingFunctionEaseInEaseOut</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.navigationController</span><span class="variable">.view</span><span class="variable">.layer</span> addAnimation:animation forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="父子控制器">父子控制器</h3><ul>
<li><p>UIViewController 添加子控制器<br><code>- (void)addChildViewController:(UIViewController *)childController</code></p>
</li>
<li><p>将当前控制器从父控制器中移除<br><code>- (void) removeFromParentViewController</code></p>
</li>
<li><p>获取当前控制器的所有子控制器<br><code>@property(nonatomic,readonly) NSArray&lt;__kindof UIViewController *&gt; *childViewControllers</code></p>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[彩票项目主要知识点]]></title>
    <link href="http://yoursite.com/2016/03/22/color_card/"/>
    <id>http://yoursite.com/2016/03/22/color_card/</id>
    <published>2016-03-22T01:00:00.000Z</published>
    <updated>2016-03-22T14:38:13.000Z</updated>
    <content type="html"><![CDATA[<h3 id="自定义UITabBar">自定义UITabBar</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUpTabBar</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    MCTabBar *tabBar = [[MCTabBar alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储UITabBarItem</span></span><br><span class="line">    tabBar<span class="variable">.items</span> = <span class="keyword">self</span><span class="variable">.items</span>;</span><br><span class="line">    </span><br><span class="line">    tabBar<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    tabBar<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除系统的tabBar,相当于将tabBar上的所有按钮移除</span></span><br><span class="line">	<span class="comment">//将一个控件从父控件中移除并不会马上销毁,一般在下一次运行循环的时候,就会判断这个对象有没有强引用,如果没有,才会销毁</span></span><br><span class="line">	<span class="comment">//[self.tabBar removeFromSuperview];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//tabBar.frame = self.tabBar.frame;</span></span><br><span class="line"></span><br><span class="line">    tabBar<span class="variable">.frame</span> = <span class="keyword">self</span><span class="variable">.tabBar</span><span class="variable">.bounds</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.tabBar</span> addSubview:tabBar];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把系统的tabBar上的按钮干掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *childView <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.tabBar</span><span class="variable">.subviews</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![childView isKindOfClass:[MCTabBar class]]) &#123;</span><br><span class="line">            [childView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="自定义导航控制器">自定义导航控制器</h3><ul>
<li><p>处理目标控制器滑动返回(整个页面都可以滑动返回)方式一</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用运行时机制获取某个类里面的属性</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCNavigationController</span> ()&lt;<span class="title">UIGestureRecognizerDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCNavigationController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止手势冲突</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.enabled</span> = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历某个类里面所有属性 Ivar:表示成员属性</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copyIvarList:只能获取哪个类下面的属性,并不会越界（不会把它的父类的属性给遍历出来）</span></span><br><span class="line">    <span class="comment">//Class:获取哪个类的成员属性</span></span><br><span class="line">    <span class="comment">//count:告诉你当前类里面成员属性的总数</span></span><br><span class="line">    <span class="comment">//返回成员属性的数组</span></span><br><span class="line">    Ivar *ivars = class_copyIvarList([<span class="built_in">UIGestureRecognizer</span> class], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">       <span class="comment">// 取出成员变量</span></span><br><span class="line">       Ivar ivar = ivars[i];</span><br><span class="line">            </span><br><span class="line">       <span class="comment">// 获取属性名</span></span><br><span class="line">       <span class="built_in">NSString</span> *ivarName = @(ivar_getName(ivar));</span><br><span class="line">            </span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,ivarName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//_targets:属性名 value</span></span><br><span class="line">    <span class="built_in">NSArray</span> *targets = [<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span> valueForKeyPath:<span class="string">@"_targets"</span>];</span><br><span class="line">    <span class="keyword">id</span> objc = [targets firstObject];</span><br><span class="line">    <span class="keyword">id</span> target = [objc valueForKeyPath:<span class="string">@"_target"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其实target就是self.interactivePopGestureRecognizer.delegate</span></span><br><span class="line">    <span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:target action:<span class="keyword">@selector</span>(handleNavigationTransition:)];</span><br><span class="line">    </span><br><span class="line">    pan<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addGestureRecognizer:pan];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 手势代理方法</span></span><br><span class="line"><span class="comment">// 是否开始触发手势</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断下当前控制器是否是根控制器</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span><span class="variable">.topViewController</span> != [<span class="keyword">self</span><span class="variable">.viewControllers</span> firstObject]);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.viewControllers</span><span class="variable">.count</span> != <span class="number">0</span>) &#123; <span class="comment">// 非根控制器</span></span><br><span class="line">        viewController<span class="variable">.hidesBottomBarWhenPushed</span> = <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置导航条左边按钮的内容,把系统的返回按钮给覆盖,导航控制器的滑动返回功能就木有啦</span></span><br><span class="line">        viewController<span class="variable">.navigationItem</span><span class="variable">.leftBarButtonItem</span> = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"NavBack"</span>] style:<span class="built_in">UIBarButtonItemStyleBordered</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(back)];</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> pushViewController:viewController animated:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)back</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>处理目标控制器滑动返回(从左边沿滑动返回)方式二</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCNavigationController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> popDelegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCNavigationController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理做了一些滑动返回功能,而且做了一系列的判断</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.popDelegate</span> = <span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.delegate</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 导航控制器的代理方法</span></span><br><span class="line"><span class="comment">// 完全展示完调用</span></span><br><span class="line">- (<span class="keyword">void</span>)navigationController:(<span class="built_in">UINavigationController</span> *)navigationController didShowViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果展示的控制器是根控制器，就还原pop手势代理</span></span><br><span class="line">    <span class="keyword">if</span> (viewController == [<span class="keyword">self</span><span class="variable">.viewControllers</span> firstObject]) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.delegate</span> = <span class="keyword">self</span><span class="variable">.popDelegate</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复写导航控制器方法,push的时候隐藏底部UITabBar</span></span><br><span class="line">- (<span class="keyword">void</span>)pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.viewControllers</span><span class="variable">.count</span> != <span class="number">0</span>) &#123; <span class="comment">// 非根控制器</span></span><br><span class="line">        viewController<span class="variable">.hidesBottomBarWhenPushed</span> = <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置导航条左边按钮的内容,把系统的返回按钮给覆盖,导航控制器的滑动返回功能就木有啦</span></span><br><span class="line">        viewController<span class="variable">.navigationItem</span><span class="variable">.leftBarButtonItem</span> = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"NavBack"</span>] style:<span class="built_in">UIBarButtonItemStyleBordered</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(back)];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 就有滑动返回功能</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.delegate</span> = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> pushViewController:viewController animated:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)back</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="自定义导航条样式">自定义导航条样式</h3><ul>
<li>修改导航条背景图片、文字颜色、标题、返回按钮<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果要设置导航条背景图片,必须使用UIBarMetricsDefault,默认导航控制器的子控制器的view尺寸会变化</span></span><br><span class="line"><span class="comment">//设置导航条背景图片一定要在导航条显示之前设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前类或者他的子类第一次使用的时候才会调用</span></span><br><span class="line">+ (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置导航条的内容</span></span><br><span class="line">    <span class="comment">//获取当前应用下所有的导航条,可能会修改系统相册的导航条,因此推荐使用下面的那种方式修改导航条样式</span></span><br><span class="line">    <span class="built_in">UINavigationBar</span> *bar = [<span class="built_in">UINavigationBar</span> appearance];</span><br><span class="line">    <span class="comment">//获取哪个类下的导航条</span></span><br><span class="line">    <span class="built_in">UINavigationBar</span> *bar = [<span class="built_in">UINavigationBar</span> appearanceWhenContainedIn:<span class="keyword">self</span>,<span class="literal">nil</span>];</span><br><span class="line">    [bar setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过setTintColor设置导航条文字的颜色</span></span><br><span class="line">    [bar setTintColor:[<span class="built_in">UIColor</span> whiteColor]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置导航条标题的颜色</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *titleAttr = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    titleAttr[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    <span class="comment">//titleAttr[NSFontAttributeName] = [NSFont systemFontOfSize:20];</span></span><br><span class="line">    titleAttr[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">NSFont</span> boldSystemFontOfSize:<span class="number">20</span>];</span><br><span class="line">    [bar setTitleTextAttributes:(<span class="built_in">NSDictonary</span> *)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以调整返回按钮文字的偏移量</span></span><br><span class="line">    <span class="comment">//[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -100) forBarMetrics:UIBarMetricsDefault];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="我的彩票模块">我的彩票模块</h3><ul>
<li>设置导航条左右2边的按钮<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载类的时候调用</span></span><br><span class="line"><span class="comment">//当程序一启动的时候就会调用</span></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setUpNav</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//设置导航条左右2边的按钮</span></span><br><span class="line">	<span class="built_in">UIButton</span> *btn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">	[btn setTitle:<span class="string">@"客服"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">	[btn setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自适应尺寸</span></span><br><span class="line">	[btn sizeToFit];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UIBarButtonItem</span> *lefItem = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithCustomView:(<span class="built_in">UIView</span> *)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置左边</span></span><br><span class="line">	<span class="keyword">self</span><span class="variable">.navigationItem</span><span class="variable">.leftBarButtonItem</span> = leftItem;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>];</span><br><span class="line">	image = [image imageWithRenderingMode:<span class="built_in">UIImageRenderingModeAlwaysOriginal</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置右边</span></span><br><span class="line">	<span class="keyword">self</span><span class="variable">.navigationItem</span><span class="variable">.rightBarButtonItem</span> = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>] style:<span class="built_in">UIBarButtonItemStylePlain</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(settings)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@property 如果在分类里面只会生成get,set方法的声明,并不会生成成员属性和方法实现.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用pch">使用pch</h3><ul>
<li>配置.pch文件路径:配置预编译文件路径:Build Settings-&gt;Prefix Header-&gt;填写.pch文件的路径<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef __OBJC__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="购彩大厅模块">购彩大厅模块</h3><ul>
<li><p>自定义活动菜单</p>
<ul>
<li>添加蒙版-自定义半透明CoverView:<br>  1.设置frame为[UIScreen mainScreen].bounds;<br>  2.设置背景颜色为黑色<br>  3.透明度为0.7<br>  4.最后将其加到主窗口上</li>
<li>自定义ActiveMenuView<br>  1.使用xib设置宽高各位200<br>  2.添加ImageView为其添加相对于父控件上下左右为0的约束<br>  3.右上角加入取消按钮<br>  4.从xib加载自定义view<br>  5.修改形变  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1</span> animations:^&#123;</span><br><span class="line">	<span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">	transform = <span class="built_in">CGAffineTransformTranslate</span>(transform,<span class="keyword">self</span><span class="variable">.center</span><span class="variable">.x</span>+<span class="number">44</span>,-<span class="keyword">self</span><span class="variable">.center</span><span class="variable">.y</span>+<span class="number">44</span>);</span><br><span class="line">	transform = <span class="built_in">CGAffineTransformScale</span>(transform,<span class="number">0.01</span>,<span class="number">0.01</span>);</span><br><span class="line">	<span class="keyword">self</span><span class="variable">.transform</span> = transform;</span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished)&#123;</span><br><span class="line">	[<span class="keyword">self</span> removeFromSuperview];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>自定义pop菜单</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">rows = (count-<span class="number">1</span>) / cols + <span class="number">1</span>;</span><br><span class="line">menu<span class="variable">.transform</span> = <span class="built_in">CGAffineformMakeTranslation</span>(<span class="number">0</span>,-menu<span class="variable">.height</span>);</span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span> delay:<span class="number">0</span> usingSpringWithDamping:<span class="number">0.3</span> initialSpringVelocity:<span class="number">0</span> options:<span class="built_in">UIViewAnimationOptionCurveEaseInOut</span> animations:^&#123;</span><br><span class="line">	menu<span class="variable">.transform</span> = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//将menu添加到控制器view上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//隐藏menu</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1</span> animations:^&#123;</span><br><span class="line">	<span class="keyword">self</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeTranslate</span>(<span class="number">0</span>,-<span class="keyword">self</span><span class="variable">.height</span>);</span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished)&#123;</span><br><span class="line">	[<span class="keyword">self</span> removeFromSuperview];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="竞技场模块">竞技场模块</h3><ul>
<li>修改导航条背景图片和自定义标题视图<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UISegmentedControl</span> *seg = [[<span class="built_in">UISegmentedControl</span> alloc] initWithItems:@[<span class="string">@"足球"</span>,<span class="string">@"篮球"</span>]];</span><br><span class="line">    seg<span class="variable">.width</span> += <span class="number">40</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置UISegmentedControl背景图片</span></span><br><span class="line">[seg setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"CPArenaSegmentBG"</span>] forState:<span class="built_in">UIControlStateNormal</span> barMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">[seg setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"CPArenaSegmentSelectedBG"</span>] forState:<span class="built_in">UIControlStateSelected</span> barMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">seg<span class="variable">.selectedSegmentIndex</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 设置边框颜色</span></span><br><span class="line">seg<span class="variable">.tintColor</span> = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0</span>/<span class="number">255.0</span> green:<span class="number">142</span>/<span class="number">255.0</span> blue:<span class="number">143</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">dict[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">[seg setTitleTextAttributes:dict forState:<span class="built_in">UIControlStateSelected</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">self</span><span class="variable">.navigationItem</span><span class="variable">.titleView</span> = seg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置导航条背景图片并处理图片拉伸</span></span><br><span class="line">+ (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前类下面的所有导航条去设置</span></span><br><span class="line">    <span class="built_in">UINavigationBar</span> *bar = [<span class="built_in">UINavigationBar</span> appearanceWhenContainedIn:<span class="keyword">self</span>, <span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    [bar setBackgroundImage:[<span class="built_in">UIImage</span> imageWithStretchableImageName:<span class="string">@"NLArenaNavBar64"</span>] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">&#125;</span><br><span class="line">+ (instancetype)imageWithStretchableImageName:(<span class="built_in">NSString</span> *)imageName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">    <span class="keyword">return</span> [image stretchableImageWithLeftCapWidth:image<span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span> topCapHeight:image<span class="variable">.size</span><span class="variable">.height</span> * <span class="number">0.5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="发现模块">发现模块</h3><ul>
<li><p>从storyboard加载控制器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIStoryboard</span> *storyboard = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"MCDiscoverViewController"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">MCDiscoverViewController *discover = [storyboard instantiateInitialViewController];</span><br><span class="line"><span class="comment">//MCDiscoverViewController *discover = [storyboard instantiateViewControllerWithIdentifier:(NSString *)identifier];</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当push目标控制器之前隐藏底部UITabBar</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *vc = segue<span class="variable">.destinationViewController</span>;</span><br><span class="line">    </span><br><span class="line">    vc<span class="variable">.hidesBottomBarWhenPushed</span> = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为UIImageView加载多张图片动画</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:(nullable <span class="built_in">UIImage</span> *)image];</span><br><span class="line">imageView<span class="variable">.animationImages</span> = @[<span class="built_in">UIImage</span>,<span class="built_in">UIImage</span>];</span><br><span class="line">imageView<span class="variable">.animationDuration</span> = <span class="number">1</span>;</span><br><span class="line">[imageView startAnimating];</span><br></pre></td></tr></table></figure>
</li>
<li><p>xib中图片拉伸处理<br>选中图片,修改XCode右侧属性栏中Stretching<br>x:0.5 y:0.5 width:0 height:0<br>x为图片左边一半不拉伸,y为图片上边一半不拉伸,只拉伸中间1像素点.</p>
</li>
<li>处理按钮图片拉伸<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>];</span><br><span class="line">image = [image stretchableImageWithLeftCapWidth:image<span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span> topCapHeight:image<span class="variable">.size</span><span class="variable">.height</span> * <span class="number">0.5</span>];</span><br><span class="line">[btn setBackgroundImage:image forState:<span class="built_in">UIControlStateNormal</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="比较APP版本">比较APP版本</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从info.plist获取用户最新的版本号</span></span><br><span class="line"><span class="built_in">NSString</span> *curVersion = [<span class="built_in">NSBundle</span> mainBundle]<span class="variable">.infoDictionary</span>[<span class="string">@"CFBundleShortVersionString"</span>];</span><br><span class="line"><span class="comment">// 获取上一次版本号</span></span><br><span class="line"><span class="built_in">NSString</span> *oldVersion = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:MCVersionKey];</span><br></pre></td></tr></table></figure>
<h3 id="自定义引导页">自定义引导页</h3><ul>
<li>继承UICollectionViewController</li>
<li>初始化的时候必须设置布局参数,通常使用系统提供的流水布局UICollectionViewFlowLayout</li>
<li>cell必须通过注册</li>
<li>自定义cell</li>
<li>实现UICollectionView数据源方法</li>
<li>封装Guide工具类,比较版本号,跳转到不同的页面</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 流水布局对象,设置cell的尺寸和位置</span></span><br><span class="line">    <span class="built_in">UICollectionViewFlowLayout</span> *layout  = [[<span class="built_in">UICollectionViewFlowLayout</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置滚动的方向</span></span><br><span class="line">    layout<span class="variable">.scrollDirection</span> = <span class="built_in">UICollectionViewScrollDirectionHorizontal</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置cell的尺寸</span></span><br><span class="line">    layout<span class="variable">.itemSize</span> = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span>;</span><br><span class="line">    <span class="comment">// 设置cell之间间距</span></span><br><span class="line">    layout<span class="variable">.minimumInteritemSpacing</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置行距</span></span><br><span class="line">    layout<span class="variable">.minimumLineSpacing</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置每一组的内间距</span></span><br><span class="line">    <span class="comment">//layout.sectionInset = UIEdgeInsetsMake(0, 10, 0, 10);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  [<span class="keyword">super</span> initWithCollectionViewLayout:layout];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.bounces</span> = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.showsHorizontalScrollIndicator</span> = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.pagingEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册cell</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> registerClass:[MCNewFeatureCell class] forCellWithReuseIdentifier:ID];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> setUpAllChildView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - UICollectionView有多少组</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInCollectionView:(<span class="built_in">UICollectionView</span> *)collectionView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 返回第section组有多少个cell</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView numberOfItemsInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 返回每个cell长什么样</span></span><br><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    MCNewFeatureCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:ID forIndexPath:indexPath];</span><br><span class="line">    <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"guide%ldBackground"</span>,indexPath<span class="variable">.item</span> + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    cell<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 添加所有子控件</span></span><br><span class="line">- (<span class="keyword">void</span>)setUpAllChildView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// guide1</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *guide = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"guide1"</span>]];</span><br><span class="line">    _guideView = guide;</span><br><span class="line">    guide<span class="variable">.centetX</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centetX</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> addSubview:guide];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// guideLine</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *guideLine = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"guideLine"</span>]];</span><br><span class="line">    guideLine<span class="variable">.x</span> -= <span class="number">170</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> addSubview:guideLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// largerText</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *largerText = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"guideLargeText1"</span>]];</span><br><span class="line">    largerText<span class="variable">.centetX</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centetX</span>;</span><br><span class="line">    largerText<span class="variable">.centetY</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.height</span> * <span class="number">0.7</span>;</span><br><span class="line">    _guideLargetView = largerText;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> addSubview:largerText];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// smallText</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *smallText = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"guideSmallText1"</span>]];</span><br><span class="line">    _guideSmallView = smallText;</span><br><span class="line">    smallText<span class="variable">.centetX</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centetX</span>;</span><br><span class="line">    smallText<span class="variable">.centetY</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.height</span> * <span class="number">0.8</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> addSubview:smallText];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减速完成</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</span><br><span class="line">    <span class="comment">// 获取当前x偏移量</span></span><br><span class="line">    <span class="built_in">CGFloat</span> curOffsetX = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取差值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> delta = curOffsetX - _lastOffsetX;</span><br><span class="line">    </span><br><span class="line">    _guideView<span class="variable">.x</span> += <span class="number">2</span> *  delta;</span><br><span class="line">    _guideLargetView<span class="variable">.x</span> += <span class="number">2</span> * delta;</span><br><span class="line">    _guideSmallView<span class="variable">.x</span> +=  <span class="number">2</span> * delta;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.25</span> animations:^&#123;</span><br><span class="line">        _guideView<span class="variable">.x</span> -=  delta;</span><br><span class="line">        _guideLargetView<span class="variable">.x</span> -= delta;</span><br><span class="line">        _guideSmallView<span class="variable">.x</span> -=   delta;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> page = curOffsetX / <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.width</span> + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改控件的内容</span></span><br><span class="line">    _guideView<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"guide%d"</span>,page]];</span><br><span class="line">    _lastOffsetX = curOffsetX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义cell继承自UICollectionViewCell</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCNewFeatureCell</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCNewFeatureCell</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImageView</span> *)imageView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_imageView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">UIImageView</span> *imageV = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="keyword">self</span><span class="variable">.bounds</span>];</span><br><span class="line">        </span><br><span class="line">        _imageView = imageV;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.contentView</span> addSubview:imageV];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _imageView;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    _image = image;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="设置模块">设置模块</h3><ul>
<li><p>封装一个设置控制器的基类(MCBaseSettingViewController)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCBaseSettingViewController</span> : <span class="title">UITableViewController</span></span></span><br><span class="line"><span class="comment">// 记录当前tableView的所有数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *groups;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>封装不同类型的item模型(image、title、subTitle、itemOpertionBlock、跳转的控制器Class、UISwitch状态)</p>
</li>
<li>封装group模型(items、headTitle、footTitle)</li>
<li>自定义cell</li>
<li>实现数据源方法和代理方法(点击不同的item执行不同的block来处理跳转)<br><code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath</code></li>
</ul>
<h3 id="Block">Block</h3><ul>
<li>block会把代码里所有强指针全部强引用</li>
<li><p>处理block引起的循环引用的问题,需要将所有block代码里面的self转为弱引用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typeof获取括号里面的类型</span></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>block内部对外部的变量只可以读取;</p>
</li>
<li>默认情况下,block内部不能修改外面的变量，修改编译器就会报错；</li>
<li>给局部变量加上__block关键字,这个局部变量可以在block内部修改。</li>
</ul>
<h3 id="JSON解析与KVC">JSON解析与KVC</h3><ul>
<li><p>使用NSJSONSerialization解析json</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *filePath =  [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"help.json"</span> ofType:<span class="literal">nil</span>];      </span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath];</span><br><span class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingAllowFragments</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>kvc 处理字典转模型</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果模型中的key与字典中的key不一致时,需要重写模型中的</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCHtmlItem</span></span></span><br><span class="line">+ (instancetype)itemWithDict:(<span class="built_in">NSDictionary</span> *)dict</span><br><span class="line">&#123;</span><br><span class="line">    MCHtmlItem *item = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    [item setValuesForKeysWithDictionary:dict];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历字典里面的所有key去模型中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"id"</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> setValue:value forKeyPath:<span class="string">@"ID"</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">super</span> setValue:value forKey:key];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面这个方式使用起来有很多弊端.</span></span><br><span class="line"><span class="comment">//所以我们为NSObject做一个分类,来反向查询字典并为model属性赋值</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Model</span>)</span></span><br><span class="line"></span><br><span class="line">+ (instancetype)objcWithDict:(<span class="built_in">NSDictionary</span> *)dict mapDict:(<span class="built_in">NSDictionary</span> *)mapDict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历模型中属性</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Ivar *ivars = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 属性名称</span></span><br><span class="line">        <span class="built_in">NSString</span> *ivarName = @(ivar_getName(ivar));</span><br><span class="line">        </span><br><span class="line">        ivarName = [ivarName substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">id</span> value = dict[ivarName];</span><br><span class="line">        <span class="comment">// 需要由外界通知内部,模型中属性名对应字典里面的哪个key</span></span><br><span class="line">        <span class="comment">// ID -&gt; id</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapDict) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *keyName = mapDict[ivarName];</span><br><span class="line">                </span><br><span class="line">            value = dict[keyName];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">            [objc setValue:value forKeyPath:ivarName];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> objc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="自定义UITabBar">自定义UITabBar</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUpTabBar</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    MCTabBar *tabBar = [[MCTabBar alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储UITabBarItem</span></span><br><span class="line">    tabBar<span class="variable">.items</span> = <span class="keyword">self</span><span class="variable">.items</span>;</span><br><span class="line">    </span><br><span class="line">    tabBar<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    tabBar<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除系统的tabBar,相当于将tabBar上的所有按钮移除</span></span><br><span class="line">	<span class="comment">//将一个控件从父控件中移除并不会马上销毁,一般在下一次运行循环的时候,就会判断这个对象有没有强引用,如果没有,才会销毁</span></span><br><span class="line">	<span class="comment">//[self.tabBar removeFromSuperview];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//tabBar.frame = self.tabBar.frame;</span></span><br><span class="line"></span><br><span class="line">    tabBar<span class="variable">.frame</span> = <span class="keyword">self</span><span class="variable">.tabBar</span><span class="variable">.bounds</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.tabBar</span> addSubview:tabBar];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把系统的tabBar上的按钮干掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *childView <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.tabBar</span><span class="variable">.subviews</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![childView isKindOfClass:[MCTabBar class]]) &#123;</span><br><span class="line">            [childView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS数据存储]]></title>
    <link href="http://yoursite.com/2016/03/17/ios_save_data/"/>
    <id>http://yoursite.com/2016/03/17/ios_save_data/</id>
    <published>2016-03-17T12:00:00.000Z</published>
    <updated>2016-03-19T10:17:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="如何定义block">如何定义block</h3><ul>
<li>快捷键inline<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">returnType(^blockName)(parameterTypes) = ^(parameters) &#123;</span><br><span class="line">        statements</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h3 id="iOS应用数据存储的常用方式">iOS应用数据存储的常用方式</h3><ul>
<li>XML属性列表(plist)归档</li>
<li>Preference(偏好设置)</li>
<li>NSKeyedArchiver归档(NSCoding)</li>
<li>SQLite3</li>
<li>Core Data</li>
</ul>
<h3 id="应用沙盒">应用沙盒</h3><p>应用沙盒的文件系统目录</p>
<ul>
<li>应用程序包:包含了所有的资源文件和可执行文件</li>
<li>Documents:保持应用运行时生成的需要持久化的数据,iTunes同步设备时会备份该目录.</li>
<li>Library<ul>
<li>Caches:保存应用运行时生成的需要持久化的数据,iTunes同步设备时不会备份该目录.一般存储体积大、不需要备份的非重要数据</li>
<li>Preferences:保存应用的所有偏好设置,iOS的Settings(设置)应用会在该目录中查找应用的设置信息.iTunes同步设备时会备份该目录</li>
</ul>
</li>
<li>tmp:保存应用运行时所需要的临时数据,使用完毕后再将相应的文件从该目录删除.应用没有运行时,系统也可能会清除该目录下的文件,iTunes同步设备时不会备份该目录</li>
</ul>
<h5 id="模拟器应用沙盒的根路径在:(apple是用户名,8-0是模拟器版本)">模拟器应用沙盒的根路径在:(apple是用户名,8.0是模拟器版本)</h5><p><code>/Users/apple/Library/Application Support/iPhone Simulator/8.0/Applications</code></p>
<h5 id="获取应用的文件夹(应用沙盒)">获取应用的文件夹(应用沙盒)</h5><p><code>NSString *homePath = NSHomeDirectory();</code></p>
<h5 id="获取沙盒中的文件夹">获取沙盒中的文件夹</h5><p><code>NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory,NSSearchPathDomainMask domainMask,BOOL expandTilde);</code></p>
<p>NSSearchPathDirectory:搜索的目录 <code>NSCacheDirectory</code><br>NSSearchPathDomainMask:搜索的范围 <code>NSUserDomainMask</code>:表示在用户的手机上查找<br>expandTilde:是否展开全路径,如果没展开,应用的沙盒路径就是~</p>
<h5 id="获取Cache文件夹">获取Cache文件夹</h5><p><code>NSSearchPathForDirectoriesInDomains(NSCacheDirectory,NSUserDomainMask,YES)</code></p>
<h5 id="获取Documents文件夹">获取Documents文件夹</h5><p><code>NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)</code></p>
<h5 id="获取tmp临时文件夹">获取tmp临时文件夹</h5><p><code>NSTemporaryDirectory()</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Cache文件夹路径</span></span><br><span class="line"><span class="built_in">NSString</span> *cachePath = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCacheDirectory</span>,<span class="built_in">NSUserDomainMask</span>,<span class="literal">YES</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//拼接文件名</span></span><br><span class="line"><span class="built_in">NSString</span> *filePath = [cachePath stringByAppendingPathComponent:<span class="string">@"arr.plist"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *arr = @[<span class="string">@"A"</span>,<span class="string">@"123"</span>];</span><br><span class="line"><span class="comment">//写入plist文件</span></span><br><span class="line">[arr writeToFile:filePath atomically:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取plist中的内容</span></span><br><span class="line">[<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</span><br><span class="line"></span><br><span class="line"><span class="comment">//plist 不能存储自定义对象</span></span><br></pre></td></tr></table></figure>
<h3 id="偏好设置存储">偏好设置存储</h3><ul>
<li>存放在<code>Library/Preferences/xxx.plist</code><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">[userDefaults setObject:<span class="string">@"value"</span> forKey:<span class="string">@"key"</span>];</span><br><span class="line">[userDefaults setBOOL:<span class="literal">YES</span> forKey:<span class="string">@"key"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在iOS7之前,默认不会马上将数据写到文件中</span></span><br><span class="line"><span class="comment">// 这个方法会立即将缓存中的数据写入到文件中</span></span><br><span class="line">[userDefaults synchronize];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从偏好设置中读取数据</span></span><br><span class="line"><span class="built_in">NSString</span> *value = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:<span class="string">@"key"</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="NSKeyedArchiver归档和NSKeyedUnarchiver解档">NSKeyedArchiver归档和NSKeyedUnarchiver解档</h3><ul>
<li><p>归档(<code>NSKeyedArchiver</code>)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Cache文件夹路径</span></span><br><span class="line"><span class="built_in">NSString</span> *cachePath = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCacheDirectory</span>,<span class="built_in">NSUserDomainMask</span>,<span class="literal">YES</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//拼接文件名</span></span><br><span class="line"><span class="built_in">NSString</span> *filePath = [cachePath stringByAppendingPathComponent:<span class="string">@"person.data"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义对象想要归档,必须遵守NSCoding协议,实现协议方法</span></span><br><span class="line"><span class="comment">//- (void)encodeWithCoder:(NSCoder *)aCoder : 用来描述当前对象的哪些属性需要归档</span></span><br><span class="line"><span class="comment">//[aCoder encodeObject:(id) forKey:(NSString *)];</span></span><br><span class="line"><span class="comment">//[aCoder encodeInt:(int) forKey:(NSString *)];</span></span><br><span class="line"></span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">//将自定义对象归档</span></span><br><span class="line">[<span class="built_in">NSKeyedArchiver</span> archiveRootObject:p toFile:filePath];</span><br></pre></td></tr></table></figure>
</li>
<li><p>解档(<code>NSKeyedUnarchiver</code>)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:(<span class="built_in">NSString</span> *)];</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义对象想要解档,必须遵守NSCoding协议,实现协议方法</span></span><br><span class="line"><span class="comment">//- (id)initWithCoder:(NSCoder *)aDecoder: 用来描述当前对象的哪些属性需要解档,当解档对象的时候调用</span></span><br><span class="line"><span class="comment">//解析文件会调用这个方法</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> init])&#123;</span><br><span class="line">		<span class="comment">//一定要给成员变量赋值</span></span><br><span class="line">		_xxx = [aCoder decodeObjectForKey:(<span class="built_in">NSString</span> *)];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义View,从xib加载的时候系统会自动调用initWithCoder方法</span></span><br><span class="line"><span class="comment">//只要父类遵守了NSCoding协议就要调用initWithCoder</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder])&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过代码初始化的时候,调用init方法,底层会调用initWithFrame</span></span><br><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">self</span>=[<span class="keyword">super</span> initWithFrame:frame])&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="如何定义block">如何定义block</h3><ul>
<li>快捷键inline<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">returnType(^blockName)(parameterTypes) = ^(parameters) &#123;</span><br><span class="line">        statements</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS界面跳转传值]]></title>
    <link href="http://yoursite.com/2016/03/14/contact/"/>
    <id>http://yoursite.com/2016/03/14/contact/</id>
    <published>2016-03-14T14:00:00.000Z</published>
    <updated>2016-03-20T06:34:57.000Z</updated>
    <content type="html"><![CDATA[<h3 id="监听文本框内容改变">监听文本框内容改变</h3><ul>
<li><code>[UITextField addTarget:self action:@selector(textChange) forControlEvents:UIControlEventEditingChanged];</code></li>
</ul>
<h3 id="什么是Segue">什么是Segue</h3><ul>
<li>Storyboard上每一根用来界面跳转的线,都是一个UIStoryboardSegue对象(简称Segue)</li>
</ul>
<a id="more"></a>
<h3 id="Segue的属性">Segue的属性</h3><ul>
<li>每一个Segue对象都有3个属性<ul>
<li>唯一标识 <code>@property (nonatomic, readonly) NSString *identifier;</code></li>
<li>来源控制器 <code>@property (nonatomic, readonly) id sourceViewController;</code></li>
<li>目的控制器 <code>@property (nonatomic, readonly) id destinationViewController;</code></li>
</ul>
</li>
</ul>
<h3 id="Segue的类型">Segue的类型</h3><ul>
<li>根据Segue的执行(跳转)时刻,Segue可以分为2大类型<ul>
<li>自动型:点击某个控件后(比如按钮),自动执行Segue,自动完成界面跳转</li>
<li>手动型:需要通过写代码手动执行Segue,才能完成界面跳转</li>
</ul>
</li>
</ul>
<h3 id="自动型">自动型</h3><ul>
<li>按住Control键,直接从控件拖线到目标控制器</li>
<li>如果点击某个控件后,不需要做任何判断,一定要跳转到下一个界面,建议使用”自动型Segue”</li>
</ul>
<h3 id="手动型Segue">手动型Segue</h3><ul>
<li>按住Control键,从来源控制器拖线到目标控制器</li>
<li>手动型的Segue需要设置一个标识</li>
<li>在恰当的时刻,使用perform方法执行对应的Segue<br><code>[self performSegueWithIdentifier:@&quot;login2contacts&quot; sender:nil];</code><br><code>Segue必须由来源控制器来执行,也就是说,这个perform方法必须由来源控制器来调用</code></li>
<li>如果点击某个控件后,需要做一些判断,也就是说,满足一定条件后才能跳转到下一个界面,建议使用”手动型Segue”</li>
</ul>
<h3 id="performSegueWithIdentifier:sender:"><code>performSegueWithIdentifier:sender:</code></h3><ul>
<li>利用<code>performSegueWithIdentifier:sender:</code>方法可以执行某个Segue,完成界面跳转</li>
<li><p>接下来研究<code>performSegueWithIdentifier:sender:</code>方法的完整执行过程</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个self是来源控制器</span></span><br><span class="line">[<span class="keyword">self</span> performSegueWithIdentifier:<span class="string">@"login2contacts"</span> sender:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>根据identifier去storyboard中找到对应的线,新建UIStoryboardSegue对象<br>设置Segue对象的sourceViewController(来源控制器)<br>新建并且设置Segue对象的destinationViewController(目标控制器)</li>
<li>调用sourceViewController的下面方法,做一些跳转前的准备工作并且传人创建好的Segue对象<br><code>- (void)prepareForSegue:(UIStoryboard *)segue sender:(id)sender;</code><br>这个sender是当初<code>performSegueWithIdentifier:sender:</code>中传人的sender</li>
<li><p>调用Segue对象的<code>- (void)perform</code>方法开始执行界面跳转操作</p>
<ul>
<li><p>如果segue的style是push</p>
<ul>
<li>取得sourceViewController所在的UINavigationController</li>
<li>调用UINavigationController的push方法将destinationViewController压人栈中,完成跳转.</li>
</ul>
</li>
<li><p>如果segue的style是modal</p>
<pre><code><span class="bullet">- </span>调用sourceViewController的presentViewController方法将destinationViewController展示出来
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Modal">Modal</h3><ul>
<li>除了push之外,还有另外一种控制器的切换方式,那就是Modal</li>
<li>任何控制器都能通过Modal的形式展示出来</li>
<li>Modal的默认效果: 新控制器从屏幕的最底部网上钻,直到盖住之前的控制器为止</li>
<li>以Modal的形式展示控制器<br><code>- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^)(void))completion</code></li>
<li>取消modal出的控制器<br><code>- (void)dismissViewControllerAnimated:(BOOL) completion:(void (^)(void))completion</code></li>
</ul>
<h5 id="modal的过程和原理:">modal的过程和原理:</h5><ul>
<li>在iOS8之后modal出来的控制器view加到的是UITransitionView上,之前是加在UIWindow上</li>
<li>UIWindow的rootViewController 强引用了 ViewController 而 ViewController的视图被自身的view属性强引用了</li>
<li>被modal出来的View controller会被来源控制器中的 presentedViewController属性强引用保存起来</li>
<li>当modal出View controller时,来源控制器的view会从UIWindow中移出</li>
<li>View controller中的 presentedViewController 与 presentingViewController属性</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="监听文本框内容改变">监听文本框内容改变</h3><ul>
<li><code>[UITextField addTarget:self action:@selector(textChange) forControlEvents:UIControlEventEditingChanged];</code></li>
</ul>
<h3 id="什么是Segue">什么是Segue</h3><ul>
<li>Storyboard上每一根用来界面跳转的线,都是一个UIStoryboardSegue对象(简称Segue)</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS多控制器]]></title>
    <link href="http://yoursite.com/2016/03/13/multi_viewcontroller/"/>
    <id>http://yoursite.com/2016/03/13/multi_viewcontroller/</id>
    <published>2016-03-13T14:05:07.000Z</published>
    <updated>2016-03-22T14:33:46.000Z</updated>
    <content type="html"><![CDATA[<h3 id="多控制器">多控制器</h3><ul>
<li>UINavigationController</li>
<li>UITabBarController</li>
</ul>
<h3 id="UINavigationController的简单使用">UINavigationController的简单使用</h3><ul>
<li>UINavigationController的使用步骤<ul>
<li>初始化UINavigationController</li>
<li>设置UIWindow的rootViewController为UINavigationController</li>
<li>根据具体情况,通过push方法添加对应个数的子控制器</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="UINavigationController的子控制器">UINavigationController的子控制器</h3><ul>
<li>UINavigationController以栈的形式保存子控制器<br><code>@property(nonatomic,copy) NSArray *viewControllers;</code><br><code>@property(nonatomic,readonly) NSArray *childViewControllers;</code></li>
<li>使用push方法能将某个控制器压入栈<br><code>- (void)pushViewController:(UIViewController *)viewController
animated:(BOOL)animated;</code></li>
<li>使用pop方法可以移除控制器<ul>
<li>将栈顶的控制器移除(不是马上将控制器销毁,而是等到动画结束后才销毁)<br><code>- (UIViewController *)popViewControllerAnimated:(BOOL)animated;</code></li>
<li>回到指定的子控制器<br><code>- (NSArray *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated;</code></li>
<li>回到根控制器(栈底控制器)<br><code>- (NSArray *)popToRootViewControllerAnimated:(BOOL)animated;</code></li>
</ul>
</li>
</ul>
<h3 id="如何修改导航栏的内容">如何修改导航栏的内容</h3><ul>
<li>导航栏的内容由栈顶控制器的navigationItem属性决定<br><code>self.navigationItem.title</code><br><code>self.title</code></li>
<li>UINavigationItem: 控制导航条的内容</li>
<li>UIBarButtonItem: 控制导航条上面按钮的内容</li>
<li>UINavigationItem有以下属性影响着导航栏的内容<ul>
<li>左上角的返回按钮<br><code>@property(nonatomic,retain) UIBarButtonItem *backBarButtonItem;</code></li>
<li>中间的标题视图<br><code>@property(nonatomic,retain) UIView *titleView;</code></li>
<li>中间的标题文字<br><code>@property(nonatomic,copy) NSString *title;</code></li>
<li>左上角的视图<br><code>@property(nonatomic,retain) UIBarButtonItem *leftBarButtonItem;</code></li>
<li>UIBarButtonItem <em>rightBarButtonItem 右上角的视图<br>`@property(nonatomic,retain) UIBarButtonItem </em>rightBarButtonItem;`</li>
<li>自定义<br><code>[[UIBarButtonItem alloc] initWithCustomView:(UIView *)]</code></li>
</ul>
</li>
</ul>
<h3 id="控制器View的生命周期顺序">控制器View的生命周期顺序</h3><ul>
<li><code>- (void)viewDidLoad</code></li>
<li><code>- (void)viewWillAppear:(BOOL)animated</code></li>
<li><code>- (void)viewWillLayoutSubviews</code></li>
<li><code>- (void)viewDidLayoutSubviews</code></li>
<li><code>- (void)viewDidAppear:(BOOL)animated</code></li>
<li><code>- (void)viewWillDisappear:(BOOL)animated</code></li>
<li><code>- (void)viewDidDisappear:(BOOL)animated</code></li>
<li>当控制器的view旋转的时候调用 <code>- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator</code></li>
<li>在非ARC中<ul>
<li>view即将销毁 <code>- (void)viewWillUnload</code></li>
<li>view完全销毁 <code>- (void)viewDidUnload</code> 在这个方法中管理内存,清空界面的数据.</li>
</ul>
</li>
</ul>
<h3 id="UITabBarController的view结构">UITabBarController的view结构</h3><ul>
<li>UITabBar 高度为49</li>
<li>存放子控制器的view</li>
<li>UITabBarController控制器的view不是懒加载,在创建控制器的时候就会加载</li>
</ul>
<h4 id="UITabBarController的简单使用">UITabBarController的简单使用</h4><ul>
<li>初始化UITabBarController</li>
<li>设置UIWindow的rootViewController为UITabBarController</li>
<li><p>根据具体情况,通过addChildViewController方法添加对应个数的子控制器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line"><span class="built_in">UITabBarController</span> *tabBarVC = [[<span class="built_in">UITabBarController</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置窗口的根控制器</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = tabBarVC;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIViewController</span> *vc = [[<span class="built_in">UIViewController</span> alloc] init];</span><br><span class="line">vc<span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置按钮上面的内容</span></span><br><span class="line">vc<span class="variable">.tabBarItem</span><span class="variable">.title</span> = <span class="string">@"消息"</span>;</span><br><span class="line">vc<span class="variable">.tabBarItem</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>];</span><br><span class="line">vc<span class="variable">.tabBarItem</span><span class="variable">.selectedImage</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>];</span><br><span class="line">vc<span class="variable">.tabBarItem</span><span class="variable">.badgeValue</span> = <span class="string">@"10"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加子控制器</span></span><br><span class="line">[tabBarVC addChildViewController:vc];</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示窗口</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br></pre></td></tr></table></figure>
</li>
<li><p>UITabBar</p>
<ul>
<li>如果UITabBarController有N个子控制器,那么UITabBar内部就会有N个UITabBarButton作为子控件</li>
<li>UITabBarButton里面显示什么内容,由对应子控制器的tabBarItem属性决定</li>
<li>UITabBarItem有以下属性影响着UITabBarButton的内容<ul>
<li>标题文字<br><code>@property(nonatomic,copy)NSString *title;</code></li>
<li>图标<br><code>@property(nonatomic,retain)UIImage *image;</code></li>
<li>选中时的图标<br><code>@property(nonatomic,retain)UIImage *selectedImage;</code></li>
<li>提醒数字<br><code>@property(nonatomic,copy)NSString *badgeValue;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="多控制器">多控制器</h3><ul>
<li>UINavigationController</li>
<li>UITabBarController</li>
</ul>
<h3 id="UINavigationController的简单使用">UINavigationController的简单使用</h3><ul>
<li>UINavigationController的使用步骤<ul>
<li>初始化UINavigationController</li>
<li>设置UIWindow的rootViewController为UINavigationController</li>
<li>根据具体情况,通过push方法添加对应个数的子控制器</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS创建控制器]]></title>
    <link href="http://yoursite.com/2016/03/13/create_viewcontroller/"/>
    <id>http://yoursite.com/2016/03/13/create_viewcontroller/</id>
    <published>2016-03-13T02:00:07.000Z</published>
    <updated>2016-03-13T14:11:22.000Z</updated>
    <content type="html"><![CDATA[<h3 id="如何创建一个控制器">如何创建一个控制器</h3><ul>
<li><p>控制器常见的创建方式有以下几种</p>
<ul>
<li><p>通过storyboard创建</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建窗口</span></span><br><span class="line">   <span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载storyboard</span></span><br><span class="line"><span class="built_in">UIStoryboard</span> *storyboard = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过storyboard实例化控制器</span></span><br><span class="line"><span class="comment">// instantiateInitialViewController: 加载箭头指向的控制器</span></span><br><span class="line"><span class="comment">// instantiateViewControllerWithIdentifier:(NSString *)identifier:通过Storyboard ID标识符来创建控制器</span></span><br><span class="line"><span class="built_in">UIViewController</span> *vc = [storyboard instantiateInitialViewController];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将控制器设置为窗口的根控制器</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = vc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示主窗口</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接创建<br><code>UIViewController *vc = [[UIViewController alloc] init];</code></p>
</li>
<li>指定xib文件创建<figure class="highlight"><table><tr><td class="code"><pre><span class="line">创建xib并添加一个view</span><br><span class="line">为文件的拥有者绑定Class(即设置File's Owner的Class类型 MCViewController)</span><br><span class="line">设置文件的拥有者Outlets view</span><br><span class="line">MCViewController *vc = [[MCViewController alloc] initWithNibName:@"MCViewController" bundle:nil];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="了解控制器的View是如何创建的">了解控制器的View是如何创建的</h3><h4 id="UIViewController中的-_(void)loadView方法">UIViewController中的<code>- (void)loadView</code>方法</h4><ul>
<li>loadView的作用: 自定义控制器的view</li>
<li>loadView什么时候调用: 第一次使用控制器的view的时候调用</li>
<li>注意: 在这个方法中如果没有自定义view,就不能获取控制器的view</li>
<li>一旦重写了这个方法,就不要调用[super loadView]</li>
<li>如果重写了这个方法,就不会去加载storyboard描述的控制器的View<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loadView&#123;</span><br><span class="line">	<span class="comment">// 系统默认的做法,加载storyboard或者xib描述的控制器的view</span></span><br><span class="line">	<span class="comment">//[super loadView];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不能通过这种方式设置背景颜色,会导致死循环</span></span><br><span class="line">	<span class="comment">// self.view.backgroundColor = [UIColor redColor];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建控制器view</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span> = [[<span class="built_in">UIView</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> purpleColor];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//系统内部可能是这样实现的</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_view == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> loadView];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> viewDidLoad];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="控制器view的创建(xib)">控制器view的创建(xib)</h4><ul>
<li>加载跟类名相同的xib</li>
<li>如果描述控制器View的xib跟控制器的类名相同,就会去加载</li>
<li>只有控制器的init方法底层会调用initWithNibName:bundle:</li>
<li>只要通过initWithNibName:bundle:初始化控制器,并且nibName为nil,就会执行以下几步.(例如:MCViewController类型)<ul>
<li>1.寻找有没有跟控制器类名同名但是不带Controller的xib,如果有就会去加载（MCView.xib）</li>
<li>2.寻找有没有跟控制器类名同名的xib,如果有就会去加载(MCViewController.xib)</li>
<li>3.如果都没有找到,创建空的view</li>
</ul>
</li>
<li>默认控制器view的颜色为几乎透明色</li>
</ul>
<h4 id="控制器view的懒加载">控制器view的懒加载</h4><ul>
<li>创建UIViewController控制器,控制器的view并没有创建</li>
<li><p>控制器的view懒加载:第一次使用的时候才会去加载,并不是创建UIViewController控制器的时候去加载</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line"><span class="built_in">UIViewController</span> *vc = [[ViewController alloc] init];</span><br><span class="line"><span class="comment">//第一次使用的时候会去加载view</span></span><br><span class="line">vc<span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = vc;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果控制器是窗口的根控制器就可以不用设置尺寸</p>
</li>
<li>在viewDidLoad中打印控制器的尺寸不准确,通常在viewDidAppear</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="如何创建一个控制器">如何创建一个控制器</h3><ul>
<li><p>控制器常见的创建方式有以下几种</p>
<ul>
<li><p>通过storyboard创建</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建窗口</span></span><br><span class="line">   <span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载storyboard</span></span><br><span class="line"><span class="built_in">UIStoryboard</span> *storyboard = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过storyboard实例化控制器</span></span><br><span class="line"><span class="comment">// instantiateInitialViewController: 加载箭头指向的控制器</span></span><br><span class="line"><span class="comment">// instantiateViewControllerWithIdentifier:(NSString *)identifier:通过Storyboard ID标识符来创建控制器</span></span><br><span class="line"><span class="built_in">UIViewController</span> *vc = [storyboard instantiateInitialViewController];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将控制器设置为窗口的根控制器</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = vc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示主窗口</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接创建<br><code>UIViewController *vc = [[UIViewController alloc] init];</code></p>
</li>
<li>指定xib文件创建<figure class="highlight"><table><tr><td class="code"><pre><span class="line">创建xib并添加一个view</span><br><span class="line">为文件的拥有者绑定Class(即设置File's Owner的Class类型 MCViewController)</span><br><span class="line">设置文件的拥有者Outlets view</span><br><span class="line">MCViewController *vc = [[MCViewController alloc] initWithNibName:@"MCViewController" bundle:nil];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS之UIWindow]]></title>
    <link href="http://yoursite.com/2016/03/12/uiwindow/"/>
    <id>http://yoursite.com/2016/03/12/uiwindow/</id>
    <published>2016-03-12T02:00:00.000Z</published>
    <updated>2016-03-13T14:12:23.000Z</updated>
    <content type="html"><![CDATA[<h3 id="UIWindow">UIWindow</h3><ul>
<li>UIWindow是一种特殊的UIView,通常在一个app中一般都会有一个UIWindow</li>
<li>iOS程序启动完毕后,创建的第一个视图控件就是UIWindow,接着创建控制器的view,最后将控制器的view添加到UIWindow上,于是控制器的view就显示在屏幕上了</li>
<li>一个iOS程序之所以能显示到屏幕上,完全是因为它有UIWindow</li>
<li>也就说,没有UIWindow,就看不见任何UI界面</li>
<li>键盘和状态栏都是窗口而UIAlertView不是窗口</li>
<li>窗口是有层级关系的.(UIWindowLevel:UIWindowLevelNormal &lt; UIWindowLevelStatusBar &lt; UIWindowLevelAlert)</li>
</ul>
<a id="more"></a>
<h3 id="iOS_App启动加载过程">iOS App启动加载过程</h3><p>main函数是程序的主入口,调用UIApplicationMain函数做的事情:</p>
<ul>
<li>创建UIApplication</li>
<li>创建UIApplicationDelegate,并且成为UIApplication代理</li>
<li>开启主运行循环,保持程序一直在运行</li>
<li>加载info.plist,判断有没有指定main.stroyboard,指定了就加载 </li>
<li>加载main.stroyboard做的事情:<ul>
<li>创建窗口</li>
<li>加载main.storyboard,并且加载main.storyboard指定的控制器</li>
<li>把新创建的控制器作为窗口的跟控制器,让窗口显示出来</li>
</ul>
</li>
<li>如果info.plist没有指定’Main storyboard file base name’,则不会创建窗口<br>需要在app启动完成方法中创建窗口然后创建窗口的根控制器最后再显示窗口</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1.创建窗口,注意窗口必须要有尺寸,尺寸跟屏幕一样大的尺寸,窗口不要被释放</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建窗口的根控制器</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"></span><br><span class="line"><span class="comment">// application.windows:只要一给delegate的window属性赋值,就会添加到windows数组</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,application<span class="variable">.windows</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIViewController</span> *vc = [[<span class="built_in">UIViewController</span> alloc] init];</span><br><span class="line"></span><br><span class="line">vc<span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果设置窗口的根控制器,默认就会把控制器的view添加到窗口上</span></span><br><span class="line"><span class="comment">//设置窗口的根控制器,默认就有旋转功能</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = vc;<span class="comment">//底层相当于[self.window addSubview:vc.view];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.显示窗口</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible]; <span class="comment">//makeKeyAndVisible 相当于 成为App的主窗口([UIApplication sharedApplication].keyWindow)并显示 设置self.window.hidden = NO;</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="UIWindow">UIWindow</h3><ul>
<li>UIWindow是一种特殊的UIView,通常在一个app中一般都会有一个UIWindow</li>
<li>iOS程序启动完毕后,创建的第一个视图控件就是UIWindow,接着创建控制器的view,最后将控制器的view添加到UIWindow上,于是控制器的view就显示在屏幕上了</li>
<li>一个iOS程序之所以能显示到屏幕上,完全是因为它有UIWindow</li>
<li>也就说,没有UIWindow,就看不见任何UI界面</li>
<li>键盘和状态栏都是窗口而UIAlertView不是窗口</li>
<li>窗口是有层级关系的.(UIWindowLevel:UIWindowLevelNormal &lt; UIWindowLevelStatusBar &lt; UIWindowLevelAlert)</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js 使用OAuth2.0教程]]></title>
    <link href="http://yoursite.com/2015/10/28/node_oauth/"/>
    <id>http://yoursite.com/2015/10/28/node_oauth/</id>
    <published>2015-10-28T01:29:34.000Z</published>
    <updated>2015-10-28T11:00:29.000Z</updated>
    <content type="html"><![CDATA[<h3 id="使用第三方中间件实现OAuth2-0认证授权">使用第三方中间件实现OAuth2.0认证授权</h3><p><a href="https://github.com/thomseddon/node-oauth2-server" target="_blank" rel="external">node-oauth2-server</a></p>
<ul>
<li>使用Express构建项目<br><code>express -e OAuth2 &amp;&amp; cd OAuth2 &amp;&amp; npm install</code></li>
<li>安装node-oauth2-server<br><code>npm install oauth2-server --save</code></li>
<li>安装mongoose<br><code>npm install mongoose --save</code></li>
<li>安装crypto<br><code>npm install crypto --save</code></li>
</ul>
<h3 id="复制model到项目models文件夹下">复制model到项目models文件夹下</h3><ul>
<li>在项目目录下新建models文件夹</li>
<li>复制<code>node-oauth2-server-master/examples/mongodb/model.js到OAuth2/models/</code> 下</li>
<li>修改<code>model.js</code>文件,添加如下内容:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">model.OAuthUsersEntity = OAuthUsersModel;</span><br><span class="line">model.OAuthClientsEntity = OAuthClientsModel;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="插入测试数据">插入测试数据</h3><ul>
<li>先将用户数据插入到OAuthUsers</li>
<li>然后将client_id、client_secret、redirectUri(需要后端人员算法自行生成)插入到OAuthClients. 例如:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户数据</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> OAuthUsers(&#123;</span><br><span class="line">    username: req.body.name,</span><br><span class="line">    password: req.body.password,</span><br><span class="line">    firstname: req.body.firstname,</span><br><span class="line">    lastname: req.body.lastname,</span><br><span class="line">    email: req.body.email</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端数据</span></span><br><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime().toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> md5 = crypto.createHash(<span class="string">'md5'</span>),</span><br><span class="line">    client_secret = md5.update(time).digest(<span class="string">'hex'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> OAuthClients(&#123;</span><br><span class="line">    clientId: client_id,</span><br><span class="line">    clientSecret: client_secret,</span><br><span class="line">    redirectUri: redirectUri</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存数据到mongodb</span></span><br><span class="line">user.save(callback);</span><br><span class="line">client.save(callback);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="处理授权请求">处理授权请求</h3><ul>
<li><p>打开app.js添加如下内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oauthserver = <span class="built_in">require</span>(<span class="string">'oauth2-server'</span>);</span><br><span class="line">app.oauth = oauthserver(&#123;</span><br><span class="line">  model: <span class="built_in">require</span>(<span class="string">'./models/model'</span>),</span><br><span class="line">  grants: [<span class="string">'auth_code'</span>,<span class="string">'password'</span>,<span class="string">'refresh_token'</span>],</span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line">  accessTokenLifetime: <span class="number">360</span>,</span><br><span class="line">  refreshTokenLifetime: <span class="number">3600</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'/oauth/token'</span>, app.oauth.grant());</span><br></pre></td></tr></table></figure>
</li>
<li><p>以提交表单的方式post数据到后台</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">请求头:</span><br><span class="line">Authorization: ("Basic " + client_id:client_secret base64'd) </span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">表单内容:</span><br><span class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span><br><span class="line"></span><br><span class="line">提交后:</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">  "token_type":"bearer",</span><br><span class="line">  "expires_in":3600,</span><br><span class="line">  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="验证AccessToken">验证AccessToken</h3><ul>
<li>在需要验证的路由上添加<code>app.oauth.authorise()</code>,例如评论接口:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">'/post_comments'</span>,app.oauth.authorise(),<span class="function"><span class="keyword">function</span>(<span class="params">error, req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error)&#123;</span><br><span class="line">        <span class="comment">//处理错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="错误处理">错误处理</h3><ul>
<li>可以使用<code>node-oauth2-server</code>提供的错误处理方法<br><code>app.use(app.oauth.errorHandler());</code></li>
<li>或者自己在callback中处理</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="使用第三方中间件实现OAuth2-0认证授权">使用第三方中间件实现OAuth2.0认证授权</h3><p><a href="https://github.com/thomseddon/node-oauth2-server" target="_blank" rel]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mongoose使用指南]]></title>
    <link href="http://yoursite.com/2015/10/22/mongoose/"/>
    <id>http://yoursite.com/2015/10/22/mongoose/</id>
    <published>2015-10-22T14:08:56.000Z</published>
    <updated>2015-10-23T09:21:45.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Mongoose连接Mongodb">Mongoose连接Mongodb</h3><ul>
<li>第一种方式: <code>mongoose.connect(uri, options);</code></li>
<li>第二种方式: <code>mongoose.createConnection(&#39;url&#39;, options);</code></li>
<li><a href="http://mongoosejs.com/docs/connections.html" target="_blank" rel="external">参考地址</a></li>
</ul>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>);</span><br><span class="line">第一种方式:</span><br><span class="line"><span class="keyword">var</span> Connection = mongoose.createConnection(<span class="string">'mongodb://localhost/blog'</span>);</span><br><span class="line">第二种方式:</span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/test'</span>);</span><br><span class="line"><span class="keyword">var</span> Connection  = mongoose.connection;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接错误监听</span></span><br><span class="line">Connection.on(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line">Connection.once(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//连接mongodb成功!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="通过Schema接口来定义模型">通过Schema接口来定义模型</h3><blockquote>
<p>Schema定义了文档结构和存储的数据类型</p>
</blockquote>
<ul>
<li><p><code>new Schema(config,options);</code><br>可供配置项有: safe、strict、capped、versionKey、autoIndex</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ExampleSchema = <span class="keyword">new</span> Schema(config,options);</span><br><span class="line">或者使用</span><br><span class="line"><span class="keyword">var</span> ExampleSchema = <span class="keyword">new</span> Schema(config);</span><br><span class="line">    ExampleSchema.set(option,value);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Schema定义了8中类型分别有:</p>
<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Date</code></li>
<li><code>Boolean</code></li>
<li><p><code>Mixed</code><br>Schema.Types.Mixed是Mongoose定义个混合类型,该混合类型如果未定义具体形式.因此,如果定义具体内容,就直接使用{}来定义,以下两句等价:<br><code>var PostSchema = new Schema({content:{}});</code><br><code>var PostSchema = new Schema({content:Schema.Types.Mixed});</code><br>混合类型因为没有特定约束,因此可以任意修改,一旦修改了原型,则必须调用<code>markModified()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.anything = &#123;x:[<span class="number">3</span>,<span class="number">4</span>,&#123;y:<span class="string">'change'</span>&#125;]&#125;</span><br><span class="line">person.markModified(<span class="string">'anything'</span>);<span class="comment">//传入anything，表示该属性类型发生变化</span></span><br><span class="line">person.save();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Objectid</code><br>主键,一种特殊而且非常重要的类型,每个Schema都会默认配置这个属性,属性名为_id,除非自己定义,方可覆盖 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">var</span> ObjectId = mongoose.Schema.Types.ObjectId;</span><br><span class="line"><span class="keyword">var</span> StudentSchema = <span class="keyword">new</span> Schema(&#123;&#125;); <span class="comment">//默认会有_id:ObjectId</span></span><br><span class="line"><span class="keyword">var</span> TeacherSchema = <span class="keyword">new</span> Schema(&#123;id:ObjectId&#125;);<span class="comment">//只有id:ObjectId</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array</code><br><code>Array</code>在JavaScript编程语言中并不是数组,而是集合,因此里面可以存入不同的值,以下代码等价:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ExampleSchema1 = <span class="keyword">new</span> Schema(&#123;array:[]&#125;);</span><br><span class="line"><span class="keyword">var</span> ExampleSchema2 = <span class="keyword">new</span> Schema(&#123;array:<span class="built_in">Array</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> ExampleSchema3 = <span class="keyword">new</span> Schema(&#123;array:[Schema.Types.Mixed]&#125;);</span><br><span class="line"><span class="keyword">var</span> ExampleSchema4 = <span class="keyword">new</span> Schema(&#123;array:[&#123;&#125;]&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>Buffer</code><br> <code>Buffer</code>和<code>ArrayBuffer</code>是Nodejs两种隐藏的对象</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>);</span><br><span class="line"></span><br><span class="line">使用第一种方式连接数据库的时候</span><br><span class="line"><span class="keyword">var</span> Schema = <span class="keyword">new</span> mongoose.Schema(&#123;...&#125;);</span><br><span class="line">使用第二种方式连接数据库的时候</span><br><span class="line"><span class="keyword">var</span> Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ObjectId = Schema.ObjectId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  name:    <span class="built_in">String</span>,</span><br><span class="line">  binary:  Buffer,</span><br><span class="line">  living:  <span class="built_in">Boolean</span>,</span><br><span class="line">  updated: &#123; type: <span class="built_in">Date</span>, <span class="keyword">default</span>: <span class="built_in">Date</span>.now &#125;,</span><br><span class="line">  age:     &#123; type: <span class="built_in">Number</span>, min: <span class="number">18</span>, max: <span class="number">65</span> &#125;,</span><br><span class="line">  mixed:   Schema.Types.Mixed,</span><br><span class="line">  _someId: Schema.Types.ObjectId,</span><br><span class="line">  array:      [],</span><br><span class="line">  ofString:   [<span class="built_in">String</span>],</span><br><span class="line">  ofNumber:   [<span class="built_in">Number</span>],</span><br><span class="line">  ofDates:    [<span class="built_in">Date</span>],</span><br><span class="line">  ofBuffer:   [Buffer],</span><br><span class="line">  ofBoolean:  [<span class="built_in">Boolean</span>],</span><br><span class="line">  ofMixed:    [Schema.Types.Mixed],</span><br><span class="line">  ofObjectId: [Schema.Types.ObjectId],</span><br><span class="line">  nested: &#123;</span><br><span class="line">    stuff: &#123; type: <span class="built_in">String</span>, lowercase: <span class="literal">true</span>, trim: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Thing = mongoose.model(<span class="string">'Thing'</span>, schema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> Thing;</span><br><span class="line">m.name = <span class="string">'Statue of Liberty'</span>;</span><br><span class="line">m.age = <span class="number">125</span>;</span><br><span class="line">m.updated = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">m.binary = <span class="keyword">new</span> Buffer(<span class="number">0</span>);</span><br><span class="line">m.living = <span class="literal">false</span>;</span><br><span class="line">m.mixed = &#123; any: &#123; thing: <span class="string">'i want'</span> &#125; &#125;;</span><br><span class="line">m.markModified(<span class="string">'mixed'</span>);</span><br><span class="line">m._someId = <span class="keyword">new</span> mongoose.Types.ObjectId;</span><br><span class="line">m.array.push(<span class="number">1</span>);</span><br><span class="line">m.ofString.push(<span class="string">"strings!"</span>);</span><br><span class="line">m.ofNumber.unshift(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">m.ofDates.addToSet(<span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">m.ofBuffer.pop();</span><br><span class="line">m.ofMixed = [<span class="number">1</span>, [], <span class="string">'three'</span>, &#123; four: <span class="number">5</span> &#125;];</span><br><span class="line">m.nested.stuff = <span class="string">'good'</span>;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> Thing(&#123;</span><br><span class="line">	name: <span class="string">'Statue of Liberty'</span>,</span><br><span class="line">	age: <span class="number">125</span>,</span><br><span class="line">	...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">m.save(<span class="function"><span class="keyword">function</span>(<span class="params">error,thing</span>)</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line">Thing.create(</span><br><span class="line">&#123;</span><br><span class="line">  name: <span class="string">'Statue of Liberty'</span>,</span><br><span class="line">  age: <span class="number">125</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">error, thing</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>Validation</code><br>数据的存储是需要验证的,不是什么数据都能往数据库里丢或者显示到客户端的,数据的验证需要记住以下规则:</p>
<ul>
<li>验证始终定义在SchemaType中</li>
<li>验证是一个内部中间件</li>
<li>验证是在一个Document被保存时默认启用的,除非你关闭验证</li>
<li>验证是异步递归的,如果你的SubDoc验证失败,Document也将无法保存</li>
<li><p>验证并不关心错误类型,而通过ValidationError这个对象可以访问</p>
<p>验证器</p>
</li>
<li><code>required</code> 非空验证</li>
<li><code>min/max</code> 范围验证（边值验证）</li>
<li><code>enum/match</code> 枚举验证/匹配验证</li>
<li><code>validate</code> 自定义验证规则</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> PersonSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">      name:&#123;</span><br><span class="line">        type:<span class="string">'String'</span>,</span><br><span class="line">        required:<span class="literal">true</span> <span class="comment">//姓名非空</span></span><br><span class="line">      &#125;,</span><br><span class="line">      age:&#123;</span><br><span class="line">        type:<span class="string">'Nunmer'</span>,</span><br><span class="line">        min:<span class="number">18</span>,       <span class="comment">//年龄最小18</span></span><br><span class="line">        max:<span class="number">120</span>     <span class="comment">//年龄最大120</span></span><br><span class="line">      &#125;,</span><br><span class="line">      city:&#123;</span><br><span class="line">        type:<span class="string">'String'</span>,</span><br><span class="line">        enum:[<span class="string">'北京'</span>,<span class="string">'上海'</span>]  <span class="comment">//只能是北京、上海人</span></span><br><span class="line">      &#125;,</span><br><span class="line">      other:&#123;</span><br><span class="line">        type:<span class="string">'String'</span>,</span><br><span class="line">        validate:[validator,err]  <span class="comment">//validator是一个验证函数，err是验证失败的错误信息</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Mongoose_查询数据">Mongoose 查询数据</h3><blockquote>
<p>通过Model的<code>find</code>, <code>findById</code>, <code>findOne</code>, 或者 <code>where</code> 静态方法来查询数据.</p>
</blockquote>
<ul>
<li><code>Model.find(conditions, [projection], [options], [callback])</code><br>conditions: 查询条件 相当于where部分<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">第一种方式:</span><br><span class="line"><span class="keyword">var</span> query = Model.find(&#123; name: <span class="string">'john'</span>, age: &#123; $gte: <span class="number">25</span> &#125;);</span><br><span class="line">第二种方式:</span><br><span class="line"><span class="keyword">var</span> query = Model.where(<span class="string">'name'</span>).equals(<span class="string">'john'</span>) <span class="comment">//或者 .where('name', john);</span></span><br><span class="line">                 .where(<span class="string">'age'</span>).gte(<span class="number">25</span>)</span><br><span class="line">                 .where(<span class="string">'tags'</span>).in([<span class="string">'movie'</span>, <span class="string">'music'</span>, <span class="string">'art'</span>]);</span><br><span class="line">第三种方式:</span><br><span class="line"><span class="keyword">var</span> query = Model.$where(js函数或者表达式);</span><br><span class="line"><span class="keyword">var</span> query = Model.$where(<span class="string">'this.comments.length === 10 || this.name.length === 5'</span>)</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">var</span> query = Model.$where(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.comments.length === <span class="number">10</span> || <span class="keyword">this</span>.name.length === <span class="number">5</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>projection: 需要返回的列字段<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">第一种方式:</span><br><span class="line"><span class="keyword">var</span> query = Model.select(&#123;name: <span class="number">1</span>,time: <span class="number">0</span>,title: <span class="number">1</span>,post: <span class="number">1</span>&#125;);</span><br><span class="line">第二种方式:</span><br><span class="line"><span class="keyword">var</span> query = Model.find(&#123;...&#125;,&#123;name: <span class="number">1</span>,time: <span class="number">0</span>,title: <span class="number">1</span>,post: <span class="number">1</span>&#125;);</span><br><span class="line">第三种方式:</span><br><span class="line"><span class="keyword">var</span> query = Model.select(<span class="string">'name title post'</span>); 只返回 name、title、post列字段</span><br><span class="line"><span class="keyword">var</span> query = Model.select(<span class="string">'-time'</span>); 不返回time,其它列字段都需要返回</span><br></pre></td></tr></table></figure></p>
<p>options: 其它可选参数 例如:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>query.skip():</span><br><span class="line">从第几条记录开始查找</span><br><span class="line">query.skip((page-<span class="number">1</span>)*<span class="number">10</span>);</span><br><span class="line">等价于 </span><br><span class="line">&#123;skip: (page-<span class="number">1</span>)*<span class="number">10</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>query.limit():</span><br><span class="line">一次查询出多少条记录</span><br><span class="line">query.limit(<span class="number">10</span>);</span><br><span class="line">等价于</span><br><span class="line">&#123;limit: <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>query.and(array): </span><br><span class="line">query.and([&#123; color: <span class="string">'green'</span> &#125;, &#123; status: <span class="string">'ok'</span> &#125;])</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>query.count([criteria], [callback]):</span><br><span class="line">查询符合条件的文档总数</span><br><span class="line"><span class="keyword">var</span> countQuery = Model.where(&#123; <span class="string">'color'</span>: <span class="string">'black'</span> &#125;).count(); <span class="comment">//返回统计数量</span></span><br><span class="line"></span><br><span class="line">query.count(&#123; color: <span class="string">'black'</span> &#125;).count(<span class="function"><span class="keyword">function</span>(<span class="params">error,count</span>)</span>&#123;...&#125;);</span><br><span class="line"></span><br><span class="line">query.count(&#123; color: <span class="string">'black'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error,count</span>)</span>&#123;...&#125;);</span><br><span class="line"></span><br><span class="line">query.where(<span class="string">'color'</span>, <span class="string">'black'</span>).count(<span class="function"><span class="keyword">function</span> (<span class="params">err, count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'there are %d kittens'</span>, count);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>query.distinct([field], [criteria], [callback]):</span><br><span class="line">查询符合条件的文档并返回根据键分组的结果</span><br><span class="line">Post.distinct(<span class="string">'tags'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,tags</span>)</span>&#123;...&#125;);</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> query.equals(val):</span><br><span class="line">User.where(<span class="string">'age'</span>).equals(<span class="number">49</span>);</span><br><span class="line">等价于</span><br><span class="line">User.where(<span class="string">'age'</span>, <span class="number">49</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> query.exec([operation], [callback]):</span><br><span class="line">执行查询</span><br><span class="line"><span class="keyword">var</span> promise = query.exec();</span><br><span class="line"><span class="keyword">var</span> promise = query.exec(<span class="string">'update'</span>);</span><br><span class="line"></span><br><span class="line">query.exec(callback);</span><br><span class="line">query.exec(<span class="string">'find'</span>, callback);</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>query.find([criteria], [callback]):</span><br><span class="line">根据查询条件来查询文档</span><br><span class="line">query.find(&#123; name: <span class="string">'Los Pollos Hermanos'</span> &#125;).find(callback);</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span>query.exists([path], val):</span><br><span class="line">根据指定的exists条件查询数据</span><br><span class="line"><span class="comment">// &#123; name: &#123; $exists: true &#125;&#125;  查询每条数据中存在name列字段的数据集</span></span><br><span class="line">Thing.where(<span class="string">'name'</span>).exists()</span><br><span class="line">Thing.where(<span class="string">'name'</span>).exists(<span class="literal">true</span>)</span><br><span class="line">Thing.find().exists(<span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; name: &#123; $exists: false &#125;&#125;</span></span><br><span class="line">Thing.where(<span class="string">'name'</span>).exists(<span class="literal">false</span>);</span><br><span class="line">Thing.find().exists(<span class="string">'name'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span>query.elemMatch(path, criteria):</span><br><span class="line">匹配字段为array类型并且满足指定查询条件的记录</span><br><span class="line">&#123; <span class="xml"><span class="tag">&lt;<span class="title">field</span>&gt;</span>: &#123; $elemMatch: &#123; <span class="tag">&lt;<span class="title">query1</span>&gt;</span>, <span class="tag">&lt;<span class="title">query2</span>&gt;</span>, ... &#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line">query.elemMatch('comment', &#123; author: 'autobot', votes: &#123;$gte: 5&#125;&#125;)</span><br><span class="line"></span><br><span class="line">query.where('comment').elemMatch(&#123; author: 'autobot', votes: &#123;$gte: 5&#125;&#125;)</span><br><span class="line"></span><br><span class="line">query.elemMatch('comment', function (elem) &#123;</span><br><span class="line">  elem.where('author').equals('autobot');</span><br><span class="line">  elem.where('votes').gte(5);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">query.where('comment').elemMatch(function (elem) &#123;</span><br><span class="line">  elem.where(&#123; author: 'autobot' &#125;);</span><br><span class="line">  elem.where('votes').gte(5);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">11.query.all([path], val):</span><br><span class="line">等价于and操作</span><br><span class="line">monogodb中</span><br><span class="line">&#123; tags: &#123; $all: [ "ssl" , "security" ] &#125; &#125;</span><br><span class="line">等价于</span><br><span class="line">&#123; $and: [ &#123; tags: "ssl" &#125;, &#123; tags: "security" &#125; ] &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>callback: 返回查询结果 <code>function(error,result)</code></p>
<p>如果find中有callback则会立即执行查询,否则需要最后调用<code>.exec(callback)</code>才会执行查询.<br>find方法中不传入callback我们可以使用链式调用来进行数据查询.例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Post.find(&#123; name: <span class="string">'john'</span>, age: &#123; $gte: <span class="number">18</span> &#125;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, docs</span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">Post.find(&#123;&#125;)</span><br><span class="line">            .select(&#123;name: <span class="number">1</span>,time: <span class="number">0</span>,title: <span class="number">1</span>,post: <span class="number">1</span>&#125;)</span><br><span class="line">            .skip((page-<span class="number">1</span>)*<span class="number">10</span>)</span><br><span class="line">            .limit(<span class="number">10</span>)</span><br><span class="line">            .sort(&#123;time: -<span class="number">1</span>&#125;)</span><br><span class="line">            .exec(<span class="function"><span class="keyword">function</span>(<span class="params">error, post</span>)</span>&#123;</span><br><span class="line">              ...</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> query = Post.find(&#123;&#125;)</span><br><span class="line">            .skip((page-<span class="number">1</span>)*<span class="number">10</span>)</span><br><span class="line">            .limit(<span class="number">10</span>)</span><br><span class="line">            .sort(&#123;time: -<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> promise = query.exec();</span><br><span class="line">promise.addBack(<span class="function"><span class="keyword">function</span> (<span class="params">err, docs</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>Model.findById(id, [projection], [options], [callback])</code> 相当于 <code>findOne({ _id: id })</code><br>id: key为<code>_id</code> value 为<code>Object, String, Number</code><br>projection: 同上<br>options: 同上<br>callback: 同上</p>
</li>
<li><p><code>Model.findOne([conditions], [projection], [options], [callback])</code></p>
</li>
</ul>
<h3 id="Mongoose_删除数据">Mongoose 删除数据</h3><blockquote>
<p>和新增一样,删除也有2种方式,但Entity和Model都使用remove方法</p>
</blockquote>
<ul>
<li><code>Model.findByIdAndRemove(id, [options], [callback])</code></li>
<li><code>Model.findOneAndRemove(conditions, [options], [callback])</code></li>
<li><code>Model.remove([criteria], [callback])</code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Model.remove(&#123; artist: <span class="string">'Anne Murray'</span> &#125;, callback);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Mongoose_更新数据">Mongoose 更新数据</h3><ul>
<li><code>Model.findByIdAndUpdate(id, [update], [options], [callback])</code></li>
<li><code>Model.findOneAndUpdate([conditions], [update], [options], [callback])</code></li>
<li><code>Model.update([criteria], [doc], [options], [callback])</code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Model.findByIdAndUpdate(id, &#123; $set: &#123; name: <span class="string">'jason borne'</span> &#125;&#125;, options, callback);</span><br><span class="line"></span><br><span class="line">Model.findOneAndUpdate(&#123; name: <span class="string">'borne'</span> &#125;, &#123; $set: &#123; name: <span class="string">'jason borne'</span> &#125;&#125;, options, callback)</span><br><span class="line"></span><br><span class="line">Post.update(&#123;<span class="string">'name'</span>:user.name,<span class="string">'title'</span>:title,<span class="string">'time.day'</span>:day&#125;,&#123; $set: &#123; post: req.body.post &#125;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error,docs</span>)</span>&#123;...&#125;);</span><br><span class="line"></span><br><span class="line">Model.where(&#123; email: <span class="string">'address@example.com'</span> &#125;)</span><br><span class="line">     .update(&#123; $inc: &#123; counter: <span class="number">1</span> &#125;&#125;, callback)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Mongoose_保存数据">Mongoose 保存数据</h3><ul>
<li><code>Model#save([options], [options.safe], [options.validateBeforeSave], [fn])</code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Entity来增加一条数据</span></span><br><span class="line"><span class="keyword">var</span> krouky = <span class="keyword">new</span> PersonModel(&#123;name:<span class="string">'krouky'</span>&#125;);</span><br><span class="line">krouky.save(callback);</span><br><span class="line"><span class="comment">//使用Model来增加一条数据</span></span><br><span class="line"><span class="keyword">var</span> MDragon = &#123;name:<span class="string">'MDragon'</span>&#125;;</span><br><span class="line">PersonModel.create(MDragon,callback);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>两种新增方法区别在于,如果使用Model新增时,传入的对象只能是纯净的JSON对象,不能是由Model创建的实体,原因是:由Model创建的实体krouky虽然打印是只有{name:’krouky’},但是krouky属于Entity,包含有Schema属性和Model数据库行为模型.如果是使用Model创建的对象,传入时一定会将隐藏属性也存入数据库,虽然3.x追加了默认严格属性,但也不必要增加操作的报错.</p>
<p><a href="http://www.nonb.cn/blog/nodejs-mongoose-query-chinaese.html" target="_blank" rel="external">Node+Mongoose常用查询中文文档</a></p>
<p><a href="http://ourjs.com/detail/53ad24edb984bb4659000013" target="_blank" rel="external">Mongoose学习参考文档</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Mongoose连接Mongodb">Mongoose连接Mongodb</h3><ul>
<li>第一种方式: <code>mongoose.connect(uri, options);</code></li>
<li>第二种方式: <code>mongoose.createConnection(&#39;url&#39;, options);</code></li>
<li><a href="http://mongoosejs.com/docs/connections.html">参考地址</a></li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac下安装Node.js]]></title>
    <link href="http://yoursite.com/2015/10/08/install_node_js/"/>
    <id>http://yoursite.com/2015/10/08/install_node_js/</id>
    <published>2015-10-08T05:28:31.000Z</published>
    <updated>2015-10-08T11:04:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="安装XCode">安装XCode</h3><ul>
<li>检测是否安装了XCode:<code>xcode-select -p</code></li>
<li>安装XCode:<code>xcode-select --install</code></li>
</ul>
<h3 id="安装Homebrew">安装Homebrew</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ruby <span class="operator">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="安装node">安装node</h3><h4 id="通过brew安装node">通过brew安装node</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>
<h4 id="通过nvm安装node">通过nvm安装node</h4><blockquote>
<p>Node版本管理器,是一个简单的bash脚本,用来管理同一台电脑上的多个node.js版本,并可实现方便的版本间切换.</p>
</blockquote>
<ul>
<li>首先安装nvm:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install nvm</span><br></pre></td></tr></table></figure>
<ul>
<li>然后配置nvm:</li>
</ul>
<p>选择官方的安装方法,就不用自己手动写<code>.bashrc</code>文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.<span class="number">26.1</span>/install.sh | bash</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.<span class="number">26.1</span>/install.sh | bash</span><br></pre></td></tr></table></figure>
<p>这样配置之后,在Terminal输入nvm命令还是提示<code>command not found</code>,需要再次输入:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. ~/.nvm/nvm.sh</span><br></pre></td></tr></table></figure>
<p>或者手动配置:<br>1.打开<code>.bash_profile</code>文件(习惯把设置放在.bashrc的人可以把以下的.bash_profile改成.bashrc):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim <span class="variable">$HOME</span>/.bash_profile</span><br></pre></td></tr></table></figure>
<p>2.添加如下配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span> [ <span class="operator">-s</span> <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; . <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> <span class="comment"># This loads nvm</span></span><br><span class="line"><span class="comment">#重新source你的 .bash_profile 来让设置生效</span></span><br><span class="line">. ~/.bash_profile</span><br></pre></td></tr></table></figure>
<ul>
<li>通过nvm安装任意版本的node</li>
</ul>
<p>查看可安装的node版本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm ls-remote</span><br></pre></td></tr></table></figure>
<p>安装node:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install node &amp;&amp; nvm <span class="built_in">alias</span> default node</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm ls-remote</span><br><span class="line">nvm install <span class="number">4.1</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>不过可能由于网络或者服务不稳定,实际上使用这个命令安装可能会失败,就算成功也会花费较长的时间,因此建议到Node.js官网去直接下载pkg包</p>
<ul>
<li>切换node版本</li>
</ul>
<p><code>nvm ls</code>:确认nvm目前可以管理的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvm ls</span><br><span class="line"></span><br><span class="line">  v0.<span class="number">10.24</span></span><br><span class="line">  v0.<span class="number">11.10</span></span><br><span class="line">current:    v0.<span class="number">11.10</span></span><br></pre></td></tr></table></figure>
<p>由于透过nvm安裝node,会自动将最后安裝的版本设为目前使用中的版本,因此上述命令会看到current: v0.11.10,表示我們目前正在使用v0.11.10</p>
<p>我们可以用<code>nvm use &lt;version&gt;</code>切换版本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvm use v0.<span class="number">10.24</span></span><br><span class="line">Now using node v0.<span class="number">10.24</span></span><br></pre></td></tr></table></figure>
<p>也可以偷懶一点,不用打完整的版号:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvm use <span class="number">0.10</span></span><br><span class="line">Now using node v0.<span class="number">10.24</span></span><br></pre></td></tr></table></figure>
<p>不过问题来了,如果你另外开一个shell窗口,并输入nvm,会发现current version是空的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvm ls</span><br><span class="line"></span><br><span class="line">  v0.<span class="number">10.24</span></span><br><span class="line">  v0.<span class="number">11.10</span></span><br><span class="line">current:</span><br></pre></td></tr></table></figure>
<p>这是因为利用<code>nvm use</code>命令只会在当前的shell生效,当你开了新的shell就会发现<code>$PATH</code>的值已经不包含刚才设定的node目录了。要解决这个问题就是利用<code>nvm alias default &lt;version&gt;</code><br>来设定一个预设的node版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nvm <span class="built_in">alias</span> default <span class="number">0.10</span></span><br><span class="line">default -&gt; <span class="number">0.10</span> (-&gt; v0.<span class="number">10.24</span>)</span><br></pre></td></tr></table></figure>
<h3 id="npm">npm</h3><blockquote>
<p>NPM的全称是Node.js Package Manager, 是一个NodeJS包管理和分发工具,已经成为了非官方的发布Node模块(包)的标准<br>NPM可以自动管理包的依赖. 只需要安装你想要的包, 不必考虑这个包的依赖包.</p>
</blockquote>
<ul>
<li><code>npm install</code>全局安装和本地安装的区别<br>npm的包安装分为本地安装(local)、全局安装(global)两种,从敲的命令行来看,差别只是有没有<code>-g</code>而已,比如安装n模块(用来安装管理切换不同到node版本):</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install n <span class="comment">#本地安装,将模块下载到当前命令行所在目录</span></span><br><span class="line">npm install -g n <span class="comment">#全局安装</span></span><br><span class="line">n <span class="number">4.1</span>.<span class="number">2</span> <span class="comment">#安装node v4.1.2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>全局目录通过 <code>npm config set prefix &quot;目录路径&quot;</code> 来设置</li>
<li>通过 <code>npm config get prefix</code> 来获取当前设置的目录</li>
<li>使用 cnpm 加速 npm<br>npm 默认是从国外的源获取和下载包信息, 不慢才奇怪. 可以通过简单的 <code>--registry</code> 参数, 使用国内的镜像 <a href="http://registry.npm.taobao.org" target="_blank" rel="external">http://registry.npm.taobao.org</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install koa --registry=http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>但是毕竟镜像跟官方的 npm 源还是会有一个同步时间差异, 目前 cnpm 的默认同步时间间隔是 10 分钟. 如果你是模块发布者, 或者你想马上同步一个模块, 那么推荐你安装cnpm cli:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install cnpm -g --registry=http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>通过 cnpm 命令行, 你可以快速同步任意模块:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cnpm sync koa connect mocha</span><br></pre></td></tr></table></figure>
<p><a href="http://fengmk2.com/blog/2014/03/node-env-and-faster-npm.html" target="_blank" rel="external">快速搭建 Node.js / io.js 开发环境以及加速 npm</a><br><a href="http://icarus4.logdown.com/posts/175092-nodejs-installation-guide" target="_blank" rel="external">Node.js 安裝與版本切換教學 (for MAC)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="安装XCode">安装XCode</h3><ul>
<li>检测是否安装了XCode:<code>xcode-select -p</code></li>
<li>安装XCode:<code>xcode-select --install</code></li>
</ul>
<h3 id="安装Homebrew">安装Homebrew</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ruby <span class="operator">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript权威指南--正则表达式模式匹配]]></title>
    <link href="http://yoursite.com/2015/09/24/javascript_note_06/"/>
    <id>http://yoursite.com/2015/09/24/javascript_note_06/</id>
    <published>2015-09-24T07:43:18.000Z</published>
    <updated>2015-09-28T15:34:24.000Z</updated>
    <content type="html"><![CDATA[<h3 id="正则表达式的定义">正则表达式的定义</h3><ul>
<li>使用<code>RegExp()</code>构造函数来创建RegExp对象</li>
<li>通过直接量定义为包含在一对斜杠(/)之间的字符<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配所有以s结尾的字符串</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/s$/</span>; </span><br><span class="line"><span class="keyword">var</span> pattern = <span class="built_in">RegExp</span>(<span class="string">"s$"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h4 id="直接量字符">直接量字符</h4><ul>
<li>正则表达式中的直接量字符</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th style="text-align:left">匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>字母和数字字符</td>
<td style="text-align:left">自身</td>
</tr>
<tr>
<td>\o</td>
<td style="text-align:left">NULL字符(\u0000)</td>
</tr>
<tr>
<td>\t</td>
<td style="text-align:left">制表符(\u0009)</td>
</tr>
<tr>
<td>\n</td>
<td style="text-align:left">换行符(\u000A)</td>
</tr>
<tr>
<td>\v</td>
<td style="text-align:left">垂直制表符(\u000B)</td>
</tr>
<tr>
<td>\f</td>
<td style="text-align:left">换页符(\u000C)</td>
</tr>
<tr>
<td>\r</td>
<td style="text-align:left">回车符(\u000D)</td>
</tr>
<tr>
<td>\xnn</td>
<td style="text-align:left">由十六进制数nn制定的拉丁字符,例如,\x0A等价于\n</td>
</tr>
<tr>
<td>\uxxxx</td>
<td style="text-align:left">由十六进制数xxxx制定的Unicode字符,例如\u0009等价于\t</td>
</tr>
<tr>
<td>\cX</td>
<td style="text-align:left">控制字符^X,例如,\cJ等价于换行符\n</td>
</tr>
</tbody>
</table>
<ul>
<li>具有特殊意义的标点符号<br><code>^ $ . * + ? = ! : | \ / () [] {}</code><br>当需要使用上面字符的直接量进行匹配时需要使用<code>\</code>进行转义</li>
</ul>
<h4 id="字符类">字符类</h4><ul>
<li>将直接量字符单独放进<code>[]</code>内就组成来字符类.一个字符类可以匹配它所包含的任意字符.</li>
<li>正则表达式的字符类</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th style="text-align:left">匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>[…]</td>
<td style="text-align:left">方括号内的任意字符</td>
</tr>
<tr>
<td>[^…]</td>
<td style="text-align:left">不在方括号内的任意字符</td>
</tr>
<tr>
<td>.</td>
<td style="text-align:left">除换行符和其他Unicode行终止符之外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td style="text-align:left">任何ASCII字符组成的单词,等价于[a-zA-Z0-9]</td>
</tr>
<tr>
<td>\W</td>
<td style="text-align:left">任何不是ASCII字符组成的单词,等价于[^a-zA-Z0-9]</td>
</tr>
<tr>
<td>\s</td>
<td style="text-align:left">任何Unicode空白符</td>
</tr>
<tr>
<td>\S</td>
<td style="text-align:left">任何非Unicode空白符的字符</td>
</tr>
<tr>
<td>\d</td>
<td style="text-align:left">任何ASCII数字</td>
</tr>
<tr>
<td>\D</td>
<td style="text-align:left">除了ASCII数字之外的任何字符,等价于[^0-9]</td>
</tr>
<tr>
<td>\b</td>
<td style="text-align:left">退格直接量</td>
</tr>
</tbody>
</table>
<h4 id="重复">重复</h4><ul>
<li>正则表达式的重复字符语法</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>{n,m}</td>
<td style="text-align:left">匹配前一项至少n次,但不能超过m次</td>
</tr>
<tr>
<td>{n,}</td>
<td style="text-align:left">匹配前一项n次或者更多次</td>
</tr>
<tr>
<td>{n}</td>
<td style="text-align:left">匹配前一项n次</td>
</tr>
<tr>
<td>?</td>
<td style="text-align:left">匹配前一项0次或者1次,也就是说前一项是可选的,等价于{0,1}</td>
</tr>
<tr>
<td>+</td>
<td style="text-align:left">匹配前一项1次或多次,等价于{1,}</td>
</tr>
<tr>
<td>*</td>
<td style="text-align:left">匹配前一项0次或多次,等价于{0,}</td>
</tr>
</tbody>
</table>
<p>例如:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">/\d&#123;2,4&#125;/ //匹配2~4个数字</span><br><span class="line">/\w&#123;3&#125;\d?/ //精确匹配3个单词和一个可选的数字</span><br><span class="line">/\s+java\s+/ //匹配前后带有一个或多个空格的字符串"java"</span><br><span class="line">/[^(]*/ //匹配一个或多个非左括号的字符</span><br></pre></td></tr></table></figure></p>
<h4 id="非贪婪的重复">非贪婪的重复</h4><ul>
<li>尽可能的少匹配,只须在待匹配的字符后跟随一个问号:<code>??</code>、<code>+?</code>、<code>*?</code>或<code>{1,5}?</code></li>
</ul>
<h4 id="选择、分组和引用">选择、分组和引用</h4><ul>
<li>选择:字符<code>|</code>用于分隔供选择的字符,选择项的尝试匹配次序是从左到右,直到发现了匹配项.如果左边<br>的选择项匹配,就忽略右边的匹配项,即使它产生更好的匹配.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/ab|cd|ef/   <span class="comment">//可以匹配字符串"ab"或者"cd"或者"ef"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>()</code>圆括号作用<ul>
<li>第一个作用是单独的项组合成子表达式,以便可以像处理一个独立的单元那样用”|”、”*”、”+”或者”?”等来对单元内的项进行处理.</li>
<li>第二个作用是在完整地模式中定义子模式.当一个正则表达式成功地和目标字符串相匹配时,可以从目标串中抽出和圆括号中的子模式相匹配的部分.</li>
<li>第三个作用是允许在同一正则表达式的后部引用前面的子表达式.这通常在字符”\”后加一位或多位数字来实现的.这个数字指定了带圆括号的子表达式在正则表达式中的位置.例如,<code>\1</code>引用的是第一个带圆括号的子表达式,<code>\3</code>引用的是第三个带圆括号的子表达式.注意,因为子表达式可以嵌套另一个子表达式,所以它的位置是参与计数的左括号的位置.嵌套的子表达式对正则表达式中前一个子表达式的引用,并不是指对子表达式模式的引用,而指的是与那个模式相匹配的文本的引用.</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="regexp">/java(script)?/</span>   <span class="comment">//可以匹配"java",其后可以有"script"也可以没有.</span></span><br><span class="line">/(ab|cd)+|ef/ <span class="comment">//可以匹配字符串"ef",也可以匹配字符串"ab"或"cd"的一次或多次重复.</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">(<span class="regexp">/[a-z]+(\d+)/</span>) <span class="comment">//从检索到得匹配中抽取数字</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:</span><br><span class="line"><span class="comment">//左侧的引号必须和右侧的引号相匹配.</span></span><br><span class="line">/([<span class="string">'"])[^'</span><span class="string">"]*\1/ //匹配左侧和右侧的引号 \1 匹配的是第一个带圆括号的子表达式所匹配的模式</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>(?:</code>和<code>)</code>分组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/</span><br></pre></td></tr></table></figure>
<ul>
<li>正则表达式的选择、分组和引用字符<table><tr><th>字符</th><th>含义</th></tr><tr><td>|</td><td>选择,匹配的是该符号左边的子表达式或右边的子表达式</td></tr><br>  <tr><td>(…)</td><td>组合,将几个项组合为一个单元,这个单元可通过”*”、”+”、”?”和”|”等符号加以修饰,<br>而且可以记住和这个组合相匹配的字符串以供此后的引用使用</td></tr><tr><td>(?:…)</td><td>只组合,把项组合到一个单元,但不记忆与该组相匹配的字符</td></tr><tr><td>\n</td><td>和第n个分组第一次匹配的字符相匹配,组是圆括号中的子表达式(也有可能是嵌套的),组索引是从左到右的左括号数,”(?:”形式的分组不编码</td></tr></table></li>
</ul>
<ul>
<li>指定匹配位置<br><code>\b</code>:匹配一个单词的边界,即位于<code>\w</code>和<code>\W</code>之间的边界,或位于字符<code>\w</code>和字符串的开头或结尾之间的边界(<code>[\b]</code>匹配的是退格符)<br><code>^</code>:匹配字符串的开头,在多行检索中,匹配一行的开头<br><code>$</code>:匹配字符串的结尾,在多行检索中,匹配一行的结尾<br><code>\B</code>:将匹配非单词边界的位置<br><code>(?=p)</code>:要求接下来的字符都与p匹配,但不能包括匹配p的那些字符<br><code>(?!p)</code>:要求接下来的字符都不与p匹配</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/Java(?! Script)([A-Z]\w*)/  <span class="comment">//匹配"Java"后跟随一个大写字母和任意多个单词,但Java后面不能跟随"Script"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修饰符<br>修饰符是放在”/“之外的,也就是说,它们不是出现在两条斜线之间,而是第二条斜线之后.</li>
</ul>
<p>正则表达式修饰符</p>
<table>
<thead>
<tr>
<th>字符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td style="text-align:left">执行不区分大小写的匹配</td>
</tr>
<tr>
<td>g</td>
<td style="text-align:left">执行一个全局匹配,简言之,即找到所有的匹配,而不是在找到第一个之后就停止</td>
</tr>
<tr>
<td>m</td>
<td style="text-align:left">多行匹配模式,^匹配一行的开头和字符串的开头,$匹配行的结束和字符串的结束</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/\bjava\b/i</span><br><span class="line">/\bjava\b/gi</span><br></pre></td></tr></table></figure>
<h3 id="用于模式匹配的String方法">用于模式匹配的String方法</h3><p><code>String</code>支持4种使用正则表达式的方法:</p>
<ul>
<li><p><code>search()</code>:参数为正则表达式,如果不是正则表达式,则首先会通过RegExp构造函数将它转成正则表达式.此方法不支持全局搜索(<code>//g</code>).返回第一个与之匹配的子串的起始位置,如果找不到匹配的子串,它将返回-1.</p>
</li>
<li><p><code>replace()</code>:用以执行检索与替换操作.<br>第二个参数是要进行替换的字符串<br>第二个参数可以是函数,该函数能够动态地计算替换字符串<br>第一个参数是正则表达式时:如果正则表达式中设置了修饰符<code>g</code>,那么源字符串中所有与模式匹配的子串都将替换成第二个参数指定的字符串;如果不带修饰符<code>g</code>,则只替换所匹配的第一个子串.<br>第一个参数是字符串时: 则将直接搜索这个字符串<br>如果在替换字符串中出现了<code>$数字</code>,那么<code>replace()</code>将用与指定的子表达式相匹配的文本来替换这两个字符.</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"JavaScript"</span>.search(<span class="regexp">/script/i</span>);  <span class="comment">// =&gt;4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有不区分大小写的javascript都替换成大小写正确的JavaScript</span></span><br><span class="line">text.replace(<span class="regexp">/javascript/gi</span>,<span class="string">"JavaScript"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//一段引用文本起始于引号,结束于引号</span></span><br><span class="line"><span class="comment">//中间的内容区域不能包含引号</span></span><br><span class="line"><span class="keyword">var</span> quote = <span class="regexp">/"([^"]*)"/g</span>;</span><br><span class="line"><span class="comment">//用中文半角引号替换英文引号,同时要保持引号之间的内容(存储在$1中)没有被修改</span></span><br><span class="line">text.replace(quote,<span class="string">' “$1” '</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>match()</code>:它的唯一参数就是一个正则表达式或通过<code>RegExp()</code>构造函数将其转换为正则表达式,返回的是一个由匹配结果组成的数组.如果正则表达式设置了修饰符<code>g</code>会进行全局检索,否则只会检索第一个匹配.但即使<code>match()</code>执行的不是全局检索,它也返回一个数组.在这种情况下,数组de第一个元素就是匹配的字符串,余下的元素则是正则表达式中用圆括号括起来的子表达式.因此,如果<code>match()</code>返回一个数组a,那么a[0]存放的是完整的匹配,a[1]存放的则是于第一个圆括号括起来的表达式相匹配的子串,以此类推.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="regexp">/(\w+):\/\/([\w.]+)\/(\S*)/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"Visit my blog at http://www.example.com/~david"</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.match(url);</span><br><span class="line"><span class="keyword">if</span>(result != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> fullurl = result[<span class="number">0</span>]; <span class="comment">// =&gt;"http://www.example.com/~david"</span></span><br><span class="line">    <span class="keyword">var</span> protocol = result[<span class="number">1</span>]; <span class="comment">// =&gt;"http"</span></span><br><span class="line">    <span class="keyword">var</span> host = result[<span class="number">2</span>]; <span class="comment">// =&gt;"www.example.com"</span></span><br><span class="line">    <span class="keyword">var</span> path = result[<span class="number">3</span>]; <span class="comment">// =&gt;"~david"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>split()</code>: 这个方法用以将调用它的字符串拆分为一个子串组成的数组,使用的分隔符是<code>split()</code>的参数.参数也可以是一个正则表达式.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"123,456,789"</span>.split(<span class="string">","</span>); <span class="comment">// =&gt;["123","456","789"]</span></span><br><span class="line"><span class="string">"1, 2, 3, 4, 5"</span>.split(<span class="regexp">/\s*,\s*/</span>); <span class="comment">// =&gt;["1","2","3","4","5"]</span></span><br></pre></td></tr></table></figure>
<h3 id="RegExp对象">RegExp对象</h3><ul>
<li><code>exec()</code>:参数为一个字符串.如果它没有找到任何匹配,返回null,否则返回一个数组.结果与上面<code>math()</code>相似.</li>
<li><code>test()</code>:参数为一个字符串.如果包含正则表达式的一个匹配结果,则返回true,否则返回false.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/Java/i</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"JavaScript is more fun than Java!"</span>;</span><br><span class="line"><span class="keyword">while</span>((result = pattern.exec(text))!=<span class="literal">null</span>)&#123;</span><br><span class="line">    alert(<span class="string">"Matched '"</span>+ result[<span class="number">0</span>] +<span class="string">"'"</span>+</span><br><span class="line">    <span class="string">" at postion "</span>+ result.index +</span><br><span class="line">    <span class="string">"; next search begins at "</span> + pattern.lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="正则表达式的定义">正则表达式的定义</h3><ul>
<li>使用<code>RegExp()</code>构造函数来创建RegExp对象</li>
<li>通过直接量定义为包含在一对斜杠(/)之间的字符<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配所有以s结尾的字符串</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/s$/</span>; </span><br><span class="line"><span class="keyword">var</span> pattern = <span class="built_in">RegExp</span>(<span class="string">"s$"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript权威指南--函数]]></title>
    <link href="http://yoursite.com/2015/09/22/javascript_note_5/"/>
    <id>http://yoursite.com/2015/09/22/javascript_note_5/</id>
    <published>2015-09-22T05:26:55.000Z</published>
    <updated>2015-09-24T00:19:04.000Z</updated>
    <content type="html"><![CDATA[<h3 id="函数调用方式">函数调用方式</h3><ul>
<li>作为函数</li>
<li>作为方法(该函数是一个对象的属性或数组中的一个元素)</li>
<li>作为构造函数</li>
<li>通过它们的<code>call()</code>和<code>apply()</code>方法间接调用</li>
</ul>
<h4 id="函数和方法调用">函数和方法调用</h4><p>以函数形式调用的函数通常不使用this关键字.作为方法调用时可以使用关键字this引用对象,<br>对象可以使用<code>.</code>符号或者<code>[]</code>的属性访问表达式来进行属性(方法)访问操作.<br><a id="more"></a><br>和变量不同,关键字this没有作用域的限制,嵌套的函数不会从调用它的函数中继承this.如果<br>嵌套函数作为方法调用,其this的值指向调用它的对象.如果嵌套函数作为函数调用,其this值不是全局对象就是<code>undefined</code>.如果想访问这个外部函数的this值,需要将this保存在一个变量里,这个变量和内部函数都同在一个工作域内.通常使用变量<code>self</code>来保存this.例如:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="comment">//对象o</span></span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//对象中的方法m()</span></span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">//将this的值保存至一个变量中</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>===o); <span class="comment">//输出true,this就是这个对象o</span></span><br><span class="line">        f();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; <span class="comment">//定义一个嵌套函数f()</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>===o); <span class="comment">//"false":this的值时全局对象或undefined</span></span><br><span class="line">            <span class="built_in">console</span>.log(self===o); <span class="comment">//"true":self指外部函数的this值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">0.</span>m();  <span class="comment">//调用对象o的方法m()</span></span><br></pre></td></tr></table></figure></p>
<h4 id="构造函数调用">构造函数调用</h4><ul>
<li>如果构造函数没有形参,可以省略后面的<code>()</code></li>
</ul>
<h4 id="函数的实参和行参">函数的实参和行参</h4><ul>
<li>可选行参<br>当调用函数的时候传入的实参比函数声明时指定的行参个数要少,剩下的行参都将设置为undefined值.<br>需要将可选实参放在实参列表的最后.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将对象o中可枚举的属性名追加至数组a中,并返回这个数组a</span></span><br><span class="line"><span class="comment">//如果省略a,则创建一个新数组并返回这个新数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPropertyNames</span>(<span class="params">o,a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a===<span class="literal">undefined</span>) a = []; <span class="comment">//如果未定义,则使用新数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> property <span class="keyword">in</span> o) a.push(property);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可变长的实参列表:实参对象<br>当调用函数的时候传入的实参个数超过函数定义时的行参个数时,没有办法直接获得未命名的引用.<br>参数对象解决了这个问题.在函数体内,标识符arguments是指向实参对象的引用,实参对象是一个类数组对象,这样可以通过数字下标就能访问传入函数的实参值,而不用非要通过名字来得到实参.<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params"><span class="comment">/*...*/</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="built_in">Number</span>.NEGATIVE_INFINITY;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>[i]&gt;max) max = <span class="built_in">arguments</span>[i];</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> largest = max(<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>类似这种函数可以接收任意个数的实参,这种函数也称为”不定实参函数”,不定实参函数的实参个数不能为零.<br>实参对象<code>arguments</code>的<code>callee</code>和<code>caller</code>属性<br><code>callee</code>:指当前正在执行的函数<br><code>caller</code>:指调用当前正在执行的函数的函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x*<span class="built_in">arguments</span>.callee(x-<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>将对象属性用做实参</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraycopy</span>(<span class="params">from,from_start,to,to_start,length</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">easycopy</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">    arraycopy(args.from,args.from_start || <span class="number">0</span>,args.to,args.to_start || <span class="number">0</span>,args.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],b = [];</span><br><span class="line">easycopy(&#123;from:a,to:b,length:<span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为值的函数<br>可以将函数赋值给变量,存储在对象的属性或数组的元素中,作为参数传入另外一个函数等.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = square;</span><br><span class="line">square(<span class="number">4</span>); <span class="comment">// =&gt;16</span></span><br><span class="line">s(<span class="number">4</span>); <span class="comment">// =&gt;16</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;square:<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x;&#125;&#125;; <span class="comment">//对象直接量</span></span><br><span class="line"><span class="keyword">var</span> y = o.square(<span class="number">16</span>); <span class="comment">// y 等于256</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x;&#125;,<span class="number">20</span>]; <span class="comment">//数组直接量</span></span><br><span class="line">a[<span class="number">0</span>](a[<span class="number">1</span>]); <span class="comment">// =&gt;400</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义函数属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化函数计数器属性</span></span><br><span class="line"><span class="comment">//由于函数声明被提前了,因此这里是可以在函数声明之前给它的成员赋值</span></span><br><span class="line">uniqueInteger.counter = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//每次调用这个函数都会返回一个不同的整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueInteger</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniqueInteger.counter++; <span class="comment">//先返回计数器的值,然后计数器自增1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算阶乘,并将结果缓存至函数的属性中(将自身当作数组来对待)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isFinite</span>(n) &amp;&amp; n&gt;<span class="number">0</span> &amp;&amp; n==<span class="built_in">Math</span>.round(n))&#123; <span class="comment">//有限的正整数</span></span><br><span class="line">        <span class="keyword">if</span>(!(n <span class="keyword">in</span> factorial)) <span class="comment">//如果没有缓存结果</span></span><br><span class="line">            factorial[n] = n*factorial(n-<span class="number">1</span>); <span class="comment">//计算结果缓存之</span></span><br><span class="line">        <span class="keyword">return</span> factorial[n]; <span class="comment">//返回缓存结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">&#125;</span><br><span class="line">factorial[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//初始化缓存以保存这种基本情况</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>作为命名空间的函数 </p>
<blockquote>
<p>在函数中声明的变量在整个函数体内都是可见的(包括在嵌套的函数中),在函数的外部是不可见的.<br>不在任何函数内声明的变量是全局变量,在整个JavaScript程序中都是可见的.在JavaScript中是<br>无法声明只在一个代码块内可见的变量的,基于这个原因,我们常常简单地定义一个函数用做临时的命名空间<br>,在这个命名空间内定义的变量都不会污染到全局命名空间.</p>
</blockquote>
</li>
</ul>
<p>匿名函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//模块代码</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<h3 id="闭包">闭包</h3><blockquote>
<p>函数对象可以通过作用域链相互关联起来,函数体内部的变量都可以保存在函数作用域内,这种特性在计算机科学文献中称为”闭包”.<br>如果闭包在外部函数里是无法访问this和arguments的,除非外部函数将其转存为一个变量.<br><code>var self = this;</code> 和 <code>var outerArguments = arguments;</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfuncs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> funcs = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        funcs[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> i;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funcs = constfuncs();</span><br><span class="line">funcs[<span class="number">5</span>](); <span class="comment">// =&gt;返回10  共享变量都返回了10</span></span><br></pre></td></tr></table></figure>
<h3 id="函数属性、方法和构造函数">函数属性、方法和构造函数</h3><ul>
<li><p>length属性<br><code>arguments.length</code>:实参个数<br><code>arguments.callee.length</code>:行参个数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> actual = args.length; <span class="comment">//实参个数</span></span><br><span class="line">    <span class="keyword">var</span> expected = args.callee.length; <span class="comment">//行参个数</span></span><br><span class="line">    <span class="keyword">if</span>(actual != expected)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"Expected "</span>+expected+<span class="string">"args;got "</span>+actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y,z</span>)</span>&#123;</span><br><span class="line">    check(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> x+y+z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>prototype属性<br>每一个函数都包含一个prototype属性,这个属性是指向一个对象的引用,这个对象称做”原型对象”.<br>当将函数用做构造函数的时候,新创建的对象会从原型对象上继承属性.</p>
</li>
<li><p><code>call()</code>方法和<code>apply()</code>方法<br>第一个参数:要调用函数的母对象,它是调用上下文,在函数体内通过this来获得对它的引用.<br>想要以对象o的方法来调用函数f().<br>第二个参数:<code>call()</code> 第一个参数后面可以为任意多个参数,参数之间用<code>,</code>分隔.<code>apply()</code>的第二个参数为数组.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f.call(o);</span><br><span class="line">f.apply(o);</span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line">o.m = f; <span class="comment">//将f存储为o的临时方法</span></span><br><span class="line">o.m();</span><br><span class="line"><span class="keyword">delete</span> o.m;<span class="comment">//将临时方法删除</span></span><br><span class="line"></span><br><span class="line">f.call(o,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">f.apply(o,[<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> biggest = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>,array_of_numbers);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>bind()</code>方法<br>这个方法的主要作用就是将函数绑定至某个对象.当在函数f()上调用bind()方法并传人一个对象o作为参数<br>,这个方法将返回一个新函数.调用新的函数将会把原始的函数f()当做o的方法来调用.传人新函数的任何实参都将传人原始函数.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.x+y;&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;x:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(o);</span><br><span class="line">g(<span class="number">2</span>); <span class="comment">// =&gt;3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toString()</code>方法<br>返回函数完整的源代码</p>
</li>
<li><p>Function()构造函数<br>函数可以通过Function()构造函数来定义,比如:<br><code>var f = new Function(&quot;x&quot;,&quot;y&quot;,&quot;return x*y;&quot;);</code><br>等价于<br><code>var f = function(x,y){return x*y;}</code><br>使用<code>Function()</code>所创建的函数并不是使用词法作用域,相反,函数体代码的编译总是会在顶层函数执行<br>,例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"return scope"</span>); <span class="comment">//无法捕获局部作用域</span></span><br><span class="line">&#125;</span><br><span class="line">constructFunction()(); <span class="comment">// =&gt;"global"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="函数调用方式">函数调用方式</h3><ul>
<li>作为函数</li>
<li>作为方法(该函数是一个对象的属性或数组中的一个元素)</li>
<li>作为构造函数</li>
<li>通过它们的<code>call()</code>和<code>apply()</code>方法间接调用</li>
</ul>
<h4 id="函数和方法调用">函数和方法调用</h4><p>以函数形式调用的函数通常不使用this关键字.作为方法调用时可以使用关键字this引用对象,<br>对象可以使用<code>.</code>符号或者<code>[]</code>的属性访问表达式来进行属性(方法)访问操作.<br>]]>
    
    </summary>
    
  </entry>
  
</feed>