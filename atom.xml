<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Mobile Development]]></title>
  <subtitle><![CDATA[移动开发]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com//"/>
  <updated>2016-05-18T14:42:50.000Z</updated>
  <id>http://yoursite.com//</id>
  
  <author>
    <name><![CDATA[weifeng]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Swift]]></title>
    <link href="http://yoursite.com/2016/05/01/swift_note/"/>
    <id>http://yoursite.com/2016/05/01/swift_note/</id>
    <published>2016-05-01T14:28:11.000Z</published>
    <updated>2016-05-18T14:42:50.000Z</updated>
    <content type="html"><![CDATA[<h3 id="常量&amp;变量">常量&amp;变量</h3><ul>
<li>let 定义常量,设置之后不可以修改</li>
<li>var 定义变量,设置之后可以修改</li>
<li>语句末尾不用使用 ;</li>
<li>在Swift中使用print() 替代OC中的NSLog</li>
<li>print 的性能更好</li>
</ul>
<a id="more"></a>
<h3 id="类型转换">类型转换</h3><ul>
<li>Swift中不存在隐式类型转换,所有的类型转换都必须是显示的<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">9.9</span></span><br><span class="line"><span class="keyword">let</span> iSum = num1 + <span class="type">Int</span>(num2)</span><br><span class="line"><span class="keyword">let</span> dSum = <span class="type">Double</span>(num1) + num2</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num3: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> num4: <span class="type">Int</span> = <span class="type">Int</span>(<span class="number">10.1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="分支">分支</h3><h4 id="switch">switch</h4><ul>
<li>Swift中的if可以省略()</li>
<li>Swift中哪怕if后面只有一条语句,也不能省略{}</li>
<li>Swift中条件只能放bool值,取值只有两个ture/false</li>
<li>Swift中的switch<ul>
<li>后面的()可以省略</li>
<li>OC中的switch如果没有break会穿透,但是Swift不会穿透</li>
<li>OC中如果要在case中定义变量,必须加上{}确定作用域,而Swift中不用</li>
<li>OC中default的位置可以随便写,只有所有case都不满足才会执行default而Swift中的default只能放在最后</li>
<li>OC中的default可以省略,Swift中”大部分”情况下不能省略</li>
</ul>
</li>
</ul>
<h4 id="for和while循环">for和while循环</h4><ul>
<li>普通for循环和OC中基本一致</li>
<li><p>0..&lt;10 代表一个区间范围 从0开始到9,包含头不包含尾</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;<span class="number">10</span></span><br><span class="line">&#123;</span><br><span class="line">	print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>_</code>代表忽略,如果不关心某个参数,就可以使用<code>_</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0.</span>.&lt;<span class="number">10</span></span><br><span class="line">&#123;</span><br><span class="line">	print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>0…10代表一个区间范围 从0开始到10,包含头又包含尾</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>..<span class="number">10</span></span><br><span class="line">&#123;</span><br><span class="line">	print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Swift中的while循环和OC差不多,而且在开发中很少使用while</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var a = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">10</span></span><br><span class="line">&#123;</span><br><span class="line">	print(a)</span><br><span class="line">	a++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Swift升级到2.0之后,do while循环发生了很大的变化 do while 没有do了,因为do被用作捕获异常了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var b = <span class="number">0</span></span><br><span class="line">repeat&#123;</span><br><span class="line">	print(b)</span><br><span class="line">	b++</span><br><span class="line">&#125;<span class="keyword">while</span> b&lt;<span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="三目运算符和可选类型">三目运算符和可选类型</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let res = (num ==<span class="number">5</span>) ? <span class="number">5</span> : <span class="number">10</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<ul>
<li>可选类型:代表着可以有也可以没有 Optional ? 以后但凡看到一个方法或者数据类型后面有?,就代表返回的是一个可选类型</li>
<li>使用可选类型需要注意,如果直接打印可选类型,那么打印出来的值会被Optional包裹</li>
<li>!代表告诉编译器,可选类型中一定有值,强制解析。如果可选类型中没有值,而又进行了强制解析,那么程序就会崩溃<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let url = <span class="built_in">NSURL</span>(string: <span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">print(url)</span><br><span class="line">print(url!)</span><br><span class="line"></span><br><span class="line">let request = <span class="built_in">NSURLRequest</span>(URL: url!)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> url != <span class="literal">nil</span></span><br><span class="line">&#123;</span><br><span class="line">	let request = <span class="built_in">NSURLRequest</span>(URL: url!)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选绑定</span></span><br><span class="line"><span class="comment">// 会将url中的值取出来赋值给urlFinal变量,如果值不为nil,那么久可以进入&#123;&#125;</span></span><br><span class="line"><span class="keyword">if</span> let urlFinal = url&#123;</span><br><span class="line">	let request = <span class="built_in">NSURLRequest</span>(URL: urlFinal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组">数组</h3><ul>
<li>和OC数组的区别就是去掉前面的@符号<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = @[<span class="string">@""</span>,<span class="string">@""</span>];</span><br><span class="line">let arr = []</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="字典">字典</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字典</span></span><br><span class="line">var dict = [<span class="string">"name"</span>:<span class="string">"xxx"</span>,<span class="string">"age"</span>:<span class="number">30</span>]</span><br><span class="line"><span class="comment">// 获取value</span></span><br><span class="line">dict[<span class="string">"name"</span>]</span><br><span class="line"><span class="comment">// 遍历字典</span></span><br><span class="line"><span class="keyword">for</span> (k,v) <span class="keyword">in</span> dict</span><br><span class="line">&#123;</span><br><span class="line">	print(k)</span><br><span class="line">	print(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增key / value</span></span><br><span class="line">dict[<span class="string">"gender"</span>] = <span class="string">"man"</span></span><br><span class="line"><span class="comment">// 更新key / value</span></span><br><span class="line">dict[<span class="string">"name"</span>] = <span class="string">"yyy"</span></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">dict<span class="variable">.removeValueForKey</span>(<span class="string">"name"</span>)</span><br><span class="line"><span class="comment">// 合并字典</span></span><br><span class="line">var dict2 = [<span class="string">"score"</span>:<span class="number">99</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key,value) <span class="keyword">in</span> dict2</span><br><span class="line">&#123;</span><br><span class="line">	dict[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串">字符串</h3><ul>
<li>在OC中定义字符串用@””. Swift中用””</li>
<li>OC中的字符串是NSString,Swift中的字符串是String</li>
<li>OC中的字符串是一个对象,继承于NSObject。Swift中的字符串是一个结构体,性能比OC中的高<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var str: String = <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接</span></span><br><span class="line">var str2 = <span class="string">"yyy"</span></span><br><span class="line"></span><br><span class="line">str += str2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化</span></span><br><span class="line">let num = <span class="number">30</span></span><br><span class="line">let name = <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Swift中可以使用\()来拼接其它值</span></span><br><span class="line">var str3 = <span class="string">"name = \(name), age = \(num)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 09:08:13</span></span><br><span class="line"><span class="comment">// 注意: 所有的值都必须放到数组中,哪怕只有一个值也需要放到数组中</span></span><br><span class="line">var str4 = String(format: <span class="string">"%02d: %02d: %02d"</span>, arguments: [<span class="number">9</span>, <span class="number">8</span>, <span class="number">13</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取</span></span><br><span class="line"><span class="comment">// 注意:在Swift中,如果需要截取字符串,建议使用OC的字符串来截取.</span></span><br><span class="line"><span class="comment">// 将Swift中的字符串转换为OC的字符串</span></span><br><span class="line">var str5: <span class="built_in">NSString</span> = <span class="string">"xxxxxxx"</span></span><br><span class="line">var str6 = <span class="string">"xxxxxxx"</span> as <span class="built_in">NSString</span></span><br><span class="line"></span><br><span class="line">var subStr = str5<span class="variable">.substringWithRange</span>(<span class="built_in">NSMakeRange</span>(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift中的字符串是支持直接遍历的</span></span><br><span class="line">var str7 = <span class="string">"xxxxxx"</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> st7<span class="variable">.characters</span></span><br><span class="line">&#123;</span><br><span class="line">	print(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="函数">函数</h3><ul>
<li>Swift定义函数的格式:<br>语义: 将前面计算的结果返回给 -&gt; 返回值<br>func 函数名称(参数列表) -&gt; 返回值<br>{<br>  执行代码<br>}<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有返回值没有参数</span></span><br><span class="line"><span class="comment">// 如果函数没有返回值,就写Void</span></span><br><span class="line"><span class="comment">// 如果函数没有返回值还可以简写</span></span><br><span class="line"><span class="comment">// 1. ()替代Void</span></span><br><span class="line"><span class="comment">// 2. 可以省略 -&gt; ()  -&gt;Void</span></span><br><span class="line">func say() -&gt; Void</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line">say()</span><br><span class="line">func say2() -&gt; ()</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line">say2()</span><br><span class="line">func say3()</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line">say3()</span><br><span class="line"><span class="comment">// 有返回值没有参数</span></span><br><span class="line">func getNumber() -&gt; Int</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">998</span></span><br><span class="line">&#125;</span><br><span class="line">print(getNumber())</span><br><span class="line"><span class="comment">// 有参数没有返回值</span></span><br><span class="line"><span class="comment">// Swift2.0中,会自动将形参列表中的第二个参数开始的参数名称作为便签,以便于提高阅读性</span></span><br><span class="line">func sum(a: Int, b: Int)</span><br><span class="line">&#123;</span><br><span class="line">	print(a + b)</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">10</span>, b: <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加标签,添加外部参数</span></span><br><span class="line"><span class="comment">// x/y称之为外部参数, a/b称之为内部参数</span></span><br><span class="line">func sum2(x a: Int, y b: Int)</span><br><span class="line">&#123;</span><br><span class="line">	print(a + b)</span><br><span class="line">&#125;</span><br><span class="line">sum2(x: <span class="number">10</span> y: <span class="number">20</span>)</span><br><span class="line"><span class="comment">// 有参数有返回值</span></span><br><span class="line">func sum3(a: Int, b: Int) -&gt;Int</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(sum3(<span class="number">10</span>, b:<span class="number">20</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="闭包">闭包</h3><ul>
<li>闭包和OC中的Block非常相似</li>
<li>OC中的Block类似于匿名函数</li>
<li>闭包是用来定义函数的</li>
<li>作用: Blcok是用于保存一段代码,在需要的时候执行.闭包也是用于保存一段代码,在需要的时候执行</li>
<li>Block 格式: 返回值类型(^block名称)(参数列表)</li>
<li>闭包的基本格式:<br>in 的格式是用于区分形参返回值和执行代码<br>{<br>  (形参列表) -&gt; (返回值)<br>  in<br>  需要执行的代码<br>}</li>
<li><p>闭包的几种格式</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.将闭包通过实参传递给函数</span></span><br><span class="line"><span class="comment">// 2.如果闭包是函数的最后一个参数,那么闭包可以写在函数()的后面</span></span><br><span class="line"><span class="comment">// 3.如果函数只接收一个参数,并且这个参数是闭包,那么()可以省略</span></span><br><span class="line">say(&#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">	print(<span class="string">"xxx"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义闭包</span></span><br><span class="line">func loadData(num: Int, finished: ()-&gt;())</span><br><span class="line">&#123;</span><br><span class="line">	finished()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下3个为调用loadData函数</span></span><br><span class="line">loadData(<span class="number">10</span>, finished:&#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">	print(<span class="string">"xxx"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loadData(<span class="number">10</span>)&#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">	print(<span class="string">"xxx"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包的简写:如果闭包没有参数也没有返回值,那么in之前的东西都可以删除,包括in</span></span><br><span class="line">loadData(<span class="number">10</span>)&#123;</span><br><span class="line">	print(<span class="string">"xxx"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数接收一个参数,这个参数是一个闭包,闭包没有参数和返回值</span></span><br><span class="line">func say(finished: ()-&gt;())</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">"执行耗时操作"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包的返回值和参数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">override func viewDidLoad()&#123;</span><br><span class="line">	let sc = createScrollview (&#123; () -&gt; Int <span class="keyword">in</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">	&#125;) &#123; (index) -&gt; <span class="built_in">UIView</span> <span class="keyword">in</span></span><br><span class="line">		let width = <span class="number">80</span></span><br><span class="line">		let btn = <span class="built_in">UIButton</span>()</span><br><span class="line">		<span class="comment">// 3.设置UIButton的属性</span></span><br><span class="line">		btn<span class="variable">.backgroundColor</span> = <span class="built_in">UIColor</span><span class="variable">.greenColor</span>()</span><br><span class="line">		btn<span class="variable">.setTitle</span>(<span class="string">"标题\(index)"</span>, forState: <span class="built_in">UIControlState</span><span class="variable">.Normal</span>)</span><br><span class="line">		btn<span class="variable">.frame</span> = <span class="built_in">CGRect</span>(x: index * width, y: <span class="number">0</span>, width: width, height: <span class="number">44</span>)</span><br><span class="line">		<span class="comment">// 4.返回创建好的控件</span></span><br><span class="line">		<span class="keyword">return</span> btn</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 5. 将UIScrollview添加到控制器view上</span></span><br><span class="line">	view<span class="variable">.addSubview</span>(sc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要求:定义一个方法来创建UIScrollView</span></span><br><span class="line"><span class="comment">// 1.并且UIScrollView上有多少个按钮必须通过闭包告诉该方法</span></span><br><span class="line"><span class="comment">// 2.并且如何创建按钮也需要通过闭包来创建</span></span><br><span class="line">func createScrollview(btnCount: ()-&gt; Int, btnWithIndex: (index:Int)-&gt;<span class="built_in">UIView</span>) -&gt; <span class="built_in">UIScrollView</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Swift推荐:能不写self就不写self</span></span><br><span class="line">	<span class="comment">// 1.创建UIScrollView</span></span><br><span class="line">	let sc = <span class="built_in">UIScrollView</span>(frame: <span class="built_in">CGRect</span>(x:<span class="number">0</span>, y:<span class="number">100</span>, width:<span class="number">375</span>, height:<span class="number">44</span>))</span><br><span class="line">	sc<span class="variable">.backgroundColor</span> = <span class="built_in">UIColor</span><span class="variable">.redColor</span>()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//let width = 80</span></span><br><span class="line">	let count = btnCount()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.创建N多个UIButton</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;count</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		let btn = UIButton()</span><br><span class="line">		// 3.设置UIButton的属性</span><br><span class="line">		btn.backgroundColor = UIColor.greenColor()</span><br><span class="line">		btn.setTitle("标题\(i)", forState: UIControlState.Normal)</span><br><span class="line">		btn.frame = CGRect(x: i * width, y: 0, width: width, height: 44)</span><br><span class="line">		// 4.将UIButton添加到UIScrollView上</span><br><span class="line">		sc.addSubview(btn)</span><br><span class="line">		*/</span></span><br><span class="line">		let subView = btnWithIndex(index:i)</span><br><span class="line">		sc<span class="variable">.addSubview</span>(subView)</span><br><span class="line">	&#125;</span><br><span class="line">	sc<span class="variable">.contentSize</span> = <span class="built_in">CGSize</span>(width: <span class="built_in">CGFloat</span>(count) * subView<span class="variable">.bounds</span><span class="variable">.width</span>, height: <span class="number">44</span>)</span><br><span class="line">	<span class="keyword">return</span> sc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包的循环引用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Swift中,如果在某个类中定义一个属性,那么这个属性必须要初始化,否则就会出错</span></span><br><span class="line"><span class="comment">// 如果此时不想初始化,那么可以在后面写一个?号</span></span><br><span class="line"><span class="comment">// 注意: 这个是错误的写法,当前写法代表闭包的返回值可以是nil</span></span><br><span class="line"><span class="comment">// var finished: ()-&gt;()?</span></span><br><span class="line">var finished: (()-&gt;())?</span><br><span class="line"></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">	<span class="keyword">super</span><span class="variable">.viewDidLoad</span>()</span><br><span class="line">	<span class="comment">// OC中的解决方案</span></span><br><span class="line">	<span class="comment">// __weak typeof(self) weakSelf = self</span></span><br><span class="line">	<span class="keyword">weak</span> var weakSelf = <span class="keyword">self</span></span><br><span class="line">	loadData &#123; () -&gt; () <span class="keyword">in</span></span><br><span class="line">		print(<span class="string">"回到主线程更新UI"</span>)</span><br><span class="line">		<span class="comment">// 在Swift开发中,能不写self就不写self,但是在闭包中必须写上self</span></span><br><span class="line">		<span class="comment">// 所以以后看到self基本上都和闭包有关系</span></span><br><span class="line">		weakSelf!<span class="variable">.view</span><span class="variable">.backgroundColor</span> = <span class="built_in">UIColor</span><span class="variable">.redColor</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func loadData(finished: ()-&gt;())</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">"执行耗时操作"</span>)</span><br><span class="line">	<span class="keyword">self</span><span class="variable">.finished</span> = finished</span><br><span class="line">	finished()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数,相当于OC中的dealloc</span></span><br><span class="line">deinit</span><br><span class="line">&#123;</span><br><span class="line">	print(<span class="string">"xxx"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="懒加载">懒加载</h3><ul>
<li>格式:定义变量时前面使用lazy来修饰变量,后面通过等到赋值一个闭包. 注意点: 1.必须使用var 2.闭包后面必须跟上()<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">lazy var dataList:[String] = &#123;</span><br><span class="line">	()-&gt;[String]</span><br><span class="line">	<span class="keyword">in</span></span><br><span class="line">	<span class="keyword">return</span> [<span class="string">"xxx"</span>, <span class="string">"x"</span>]</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果闭包是用于懒加载,那么in之前的代码都可以删除包括in在内</span></span><br><span class="line">lazy var dataList2:[String] = &#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="string">"xxx"</span>, <span class="string">"x"</span>]</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">let demoFunc = &#123;</span><br><span class="line">	()-&gt;[String]</span><br><span class="line">	<span class="keyword">in</span></span><br><span class="line">	<span class="keyword">return</span> [<span class="string">"xxx"</span>, <span class="string">"x"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy var dataList3:[String] = <span class="keyword">self</span><span class="variable">.demoFunc</span>()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="getter&amp;setter">getter&amp;setter</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">class Person: <span class="built_in">NSObject</span>&#123;</span><br><span class="line">	</span><br><span class="line">	var _name:String?</span><br><span class="line">	var name:String?&#123;</span><br><span class="line">		get&#123;</span><br><span class="line">			<span class="keyword">return</span> _name</span><br><span class="line">		&#125;</span><br><span class="line">		set&#123;</span><br><span class="line">			<span class="comment">// 只要外界通过对象.name给name赋值,那么值就会保存在newValue</span></span><br><span class="line">			_name = newValue</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var gender:String?&#123;</span><br><span class="line">		<span class="comment">//设置完值之后调用</span></span><br><span class="line">		<span class="comment">//Swift中使用didSet来替代OC中重写setter方法</span></span><br><span class="line">		didSet&#123;</span><br><span class="line">			print(gender)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果只重写了get方法,那么这个属性我们称之为 计算型 属性</span></span><br><span class="line">	<span class="comment">// 也就是对应OC中的只读属性</span></span><br><span class="line">	<span class="comment">// 注意点: 计算型属性是不占用内存空间的</span></span><br><span class="line">	var age:Int&#123;</span><br><span class="line">		get&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">30</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Swift中,如果想使用某一个类,是不用import头文件的</span></span><br><span class="line"><span class="comment">//因为Swift中新增了一个OC中以前没有的概念"命名空间"</span></span><br><span class="line"><span class="comment">//只要是在同一个命名空间中的资源都是共享的</span></span><br><span class="line"><span class="comment">//默认情况下,项目名称就是命名空间</span></span><br></pre></td></tr></table></figure>
<h3 id="构造方法">构造方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">class Person: <span class="built_in">NSObject</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果定义属性的时候没有初始化,那么必须在后面写上一个?</span></span><br><span class="line">	<span class="comment">// Swift要求,属性是必须有初始值的</span></span><br><span class="line">	<span class="comment">// 只要在构造方法中对属性进行了初始化,那么就不用写?</span></span><br><span class="line">	var name:String?</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 如果是定义一个 "对象属性" 那么后面可以写上?</span><br><span class="line">	 * 如果是定义一个 "基本数据类型属性", 那么建议直接赋值为0</span><br><span class="line">	 * 因为super.init()方法在分配存储空间的时候,如果发现属性是一个对象,并且是一个可选类型,那么会给这个属性分配存储空间</span><br><span class="line">	 * 但是如果属性是一个基本数据类型,并且是可选类型,那么super.init()不会给该属性分配存储空间</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="comment">//var age:Int?</span></span><br><span class="line">	var age:Int = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意:如果自定义构造方法,并且没有重写父类默认的构造方法那么默认的构造方法就会失效</span></span><br><span class="line">	override init()&#123;</span><br><span class="line">		<span class="keyword">self</span><span class="variable">.name</span> = <span class="string">"xxx"</span></span><br><span class="line">		<span class="keyword">self</span><span class="variable">.age</span> = <span class="number">30</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自定义构造方法</span></span><br><span class="line">	<span class="comment">//Swift中有方法重载的概念</span></span><br><span class="line">	<span class="comment">//允许有同名的方法,只要形参或返回值不一样即可</span></span><br><span class="line">	init(name:String age:Int)&#123;</span><br><span class="line">		<span class="keyword">self</span><span class="variable">.name</span> = name</span><br><span class="line">		<span class="keyword">self</span><span class="variable">.age</span> = age</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	init(dict:[String: Object])&#123;</span><br><span class="line">		<span class="comment">//注意点:Swift中如果想在构造方法中使用KVC给属性赋值,那么在使用KVC之前必须使用super.init()</span></span><br><span class="line">		<span class="comment">//调用super.init()的目的就是为了能在使用KVC赋值之前给属性分配存储空间</span></span><br><span class="line">		setValuesForKeysWithDictionary(dict)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UITableView基本使用">UITableView基本使用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift中遵守协议直接在后面通过逗号分隔即可</span></span><br><span class="line">class ViewController: <span class="built_in">UIViewController</span>&#123;</span><br><span class="line">	</span><br><span class="line">	override func loadView()&#123;</span><br><span class="line">		let tv = <span class="built_in">UITableView</span>()</span><br><span class="line">		tv<span class="variable">.frame</span> = <span class="built_in">UIScreen</span><span class="variable">.mainScreen</span>()<span class="variable">.bounds</span></span><br><span class="line">		tv<span class="variable">.dataSource</span> = <span class="keyword">self</span></span><br><span class="line">		tv<span class="variable">.delegate</span> = <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">		view = tv</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MARK: -	懒加载数据</span></span><br><span class="line">	lazy var dataList:[String] = &#123;</span><br><span class="line">		<span class="keyword">return</span> [<span class="string">"xxx"</span>, <span class="string">"xx"</span>, <span class="string">"x"</span>]</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 苹果官方建议,可以将数据源代理方法单独写到一个扩展中,以便于提高代码的可读性</span></span><br><span class="line"><span class="comment">// extension 相当于OC中的category</span></span><br><span class="line">extension ViewController: <span class="built_in">UITableViewDataSource</span>, <span class="built_in">UITableViewDelegate</span>&#123;</span><br><span class="line">	<span class="comment">// MARK: -UITableViewDataSource</span></span><br><span class="line">	func tableView(tableView: <span class="built_in">UITableView</span>, numberOfRowsInSection section:Int) -&gt; Int&#123;</span><br><span class="line">		<span class="keyword">return</span> dataList<span class="variable">.count</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	func tableView(tableView: <span class="built_in">UITableView</span>, cellForRowAtIndexPath indexPath:<span class="built_in">NSIndexPath</span>) -&gt; <span class="built_in">UITableViewCell</span> &#123;</span><br><span class="line">		<span class="comment">// 1.取出cell</span></span><br><span class="line">		let cell = tableView<span class="variable">.dequeueResuableCellWithIdentifier</span>(<span class="string">"customCell"</span>)</span><br><span class="line">		<span class="keyword">if</span> cell == <span class="literal">nil</span>&#123;</span><br><span class="line">			cell = <span class="built_in">UITableViewCell</span>(style:<span class="built_in">UITableViewCellStyle</span><span class="variable">.Default</span>,reuseIdentifier:<span class="string">"customCell"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2.设置数据</span></span><br><span class="line">		cell?<span class="variable">.textLabel</span>?<span class="variable">.text</span> = dataList[indexPath<span class="variable">.row</span>]</span><br><span class="line">		<span class="comment">// 3.返回cell</span></span><br><span class="line">		<span class="keyword">return</span> cell!</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义Log">自定义Log</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数的默认值:如果调用者没有传递对应的参数,那么系统就会使用默认值,如果调用者传递了参数,那么救护使用传递的参数</span></span><br><span class="line"><span class="comment">// 由于编译器可以通过赋值的类型自定推导数据的真实类型,所有Swift开发中,能不写数据类型就不写数据类型</span></span><br><span class="line"><span class="comment">// 优点:可以减少冗余代码</span></span><br><span class="line"><span class="comment">// 如果想在函数中使用泛型,那么必须告诉系统是一个泛型函数</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * func 函数名称&lt;T&gt;(形参列表) -&gt; 返回值类型</span><br><span class="line"> * &#123;</span><br><span class="line"> *</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"> <span class="comment">// T具体是什么类型由调用者来确定,调用者传递的是什么类型,T就是什么类型</span></span><br><span class="line"> var flag: <span class="built_in">BOOL</span> = <span class="literal">false</span></span><br><span class="line">func MCLog&lt;T&gt;(message: T, fileName: String = __FILE__, methodName: String = __FUNCTION__, lineNumber: Int = __LINE__)&#123;</span><br><span class="line">	<span class="preprocessor">#if DEBUG</span></span><br><span class="line">	print(<span class="string">"\((fileName as NSString).pathComponents.last!).\(methodName)[\(lineNumber)]:\(message)"</span>)</span><br><span class="line">	<span class="preprocessor">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名空间">命名空间</h3><ul>
<li>作用:避免重复,不同项目中的命名空间是不一样的,默认情况下命名空间的名称就是当前项目的名称</li>
<li>Swift中如果想通过类名来创建一个类必须加上命名空间</li>
<li>由于字典/数组中只能存储对象,所以通过一个key从字典中获取值,取出来是一个AnyObject类型,并且如果key写错或者没有对应的值,那么就娶不到值,所以返回值可能有值也可能没值,所以最终的类型是AnyObject?</li>
<li>动态获取命名空间<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">  * guard 可以有效的解决可选绑定容易形成&#123;&#125;嵌套问题</span><br><span class="line">  *	guard 条件表达式 else&#123;</span><br><span class="line">  *		需要执行的语句</span><br><span class="line">  *		只有条件为假才会执行&#123;&#125;中的内容</span><br><span class="line">  *		并且 guard的&#123;&#125;结尾一定要返回 return</span><br><span class="line">  * &#125;</span><br><span class="line">*/</span></span><br><span class="line"><span class="comment">//可选绑定</span></span><br><span class="line"><span class="comment">//as?是因为前面可能有值也可能没值</span></span><br><span class="line"><span class="keyword">if</span> let name = <span class="built_in">NSBundle</span><span class="variable">.mainBundle</span>()<span class="variable">.infoDictionary</span>![<span class="string">"CFBundleExecutable"</span>] as? String</span><br><span class="line">&#123;</span><br><span class="line">	let cls: AnyClass? = <span class="built_in">NSClassFromString</span>(name + <span class="string">"."</span> +childControllerName) </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Swift中如果想通过一个Class来创建一个对象,必须告诉系统这个Class的确切类型</span></span><br><span class="line">	<span class="keyword">if</span> let typeCls = cls as? <span class="built_in">UITableViewController</span><span class="variable">.Type</span>&#123;</span><br><span class="line">		<span class="comment">// 通过Class创建对象</span></span><br><span class="line">		let childController = tyoeCls!<span class="variable">.init</span>()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="常量&amp;变量">常量&amp;变量</h3><ul>
<li>let 定义常量,设置之后不可以修改</li>
<li>var 定义变量,设置之后可以修改</li>
<li>语句末尾不用使用 ;</li>
<li>在Swift中使用print() 替代OC中的NSLog</li>
<li>print 的性能更好</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Quartz2D]]></title>
    <link href="http://yoursite.com/2016/04/14/quartz2d/"/>
    <id>http://yoursite.com/2016/04/14/quartz2d/</id>
    <published>2016-04-14T14:02:11.000Z</published>
    <updated>2016-04-17T13:35:49.000Z</updated>
    <content type="html"><![CDATA[<h3 id="什么是Quartz2D">什么是Quartz2D</h3><ul>
<li>Quartz 2D是一个二维绘图引擎,同时支持iOS和Mac系统</li>
<li>Quartz 2D 能完成的工作<ul>
<li>绘制图形:线条\三角形\矩形\弧等</li>
<li>绘制文字</li>
<li>绘制\生成图片(图像)</li>
<li>读取\生成PDF</li>
<li>截图\裁剪图片</li>
<li>自定义UI控件</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="图形上下文">图形上下文</h3><ul>
<li><p>可以理解为画板</p>
</li>
<li><p>图形上下文(Graphics Context): 是一个CGContextRef类型的数据</p>
</li>
<li><p>图形上下文的作用</p>
<ul>
<li>保存绘图信息、绘图状态</li>
<li>决定绘制的输出目标(绘制到什么地方去?) 输出目标可以是PDF文件、Bitmap或者显示器的窗口上<br>绘制好的图形—保存—&gt;图形上下文—显示—&gt;输出目标</li>
</ul>
</li>
<li><p>相同的一套绘图序列,指定不同的Graphics Context,就可将相同的图像绘制到不同的目标</p>
</li>
<li><p>Quartz 2D提供了以下几种类型的Graphics Context:</p>
<ul>
<li>Bitmap Graphics Context</li>
<li>PDF Graphics Context</li>
<li>Window Graphics Context</li>
<li>Layer Graphics Context</li>
<li>Printer Graphics Context</li>
</ul>
</li>
</ul>
<h3 id="自定义view">自定义view</h3><ul>
<li><p>如何利用Quartz 2D自定义view?(自定义UI控件)</p>
</li>
<li><p>如何利用Quartz 2D绘制东西到view上?</p>
<ul>
<li>首先,得有图像上下文,因为它能保存绘图信息,并且决定着绘制到什么地方去</li>
<li>其次,那个图形上下文必须跟view相关联,才能将内容绘制到view上面</li>
</ul>
</li>
<li><p>自定义view的步骤</p>
<ul>
<li>新建一个类,继承自UIView</li>
<li>实现- (void)drawRect:(CGRect)rect方法,然后在这个方法中<ul>
<li>取得跟当前view相关联的图形上下文</li>
<li>绘制相应的图形内容</li>
<li>利用图形上下文将绘制的所有内容渲染显示到view上面</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么要在- (void)drawRect:(CGRect)rect方法里面绘图?</p>
<ul>
<li>因为只有在这个方法里面才能获取到跟View的layer相关联的图形上下文</li>
</ul>
</li>
<li><p>什么时候调用- (void)drawRect:(CGRect)rect方法?</p>
<ul>
<li>当这个View即将要显示的时候才会调用drawRect绘制图形</li>
</ul>
</li>
<li><p>注意rect是当前控件的Bounds</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"LineView.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LineView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 擦除图片</span></span><br><span class="line">- (<span class="keyword">void</span>)clearImage:(<span class="built_in">UIPanGestureRecognizer</span> *)pan&#123;</span><br><span class="line">	<span class="comment">// 获取当前点</span></span><br><span class="line">    <span class="built_in">CGPoint</span> curP = [pan locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取擦除的矩形范围</span></span><br><span class="line">    <span class="built_in">CGFloat</span> wh = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> x = curP<span class="variable">.x</span> - wh * <span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> y = curP<span class="variable">.y</span> - wh * <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(x, y, wh, wh);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span><span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 控件的layer渲染上去</span></span><br><span class="line">    [_imageView<span class="variable">.layer</span> renderInContext:ctx];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 擦除图片</span></span><br><span class="line">    <span class="built_in">CGContextClearRect</span>(ctx, rect);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一张图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    _imageView<span class="variable">.image</span> = image;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 截屏</span></span><br><span class="line">- (<span class="keyword">void</span>)screenShoot&#123;</span><br><span class="line">	<span class="comment">// 1.开启上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span><span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 2.获取上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将控件上的图层渲染到上下文,layer只能渲染</span></span><br><span class="line">	[<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> renderInContext:ctx];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成一张图片</span></span><br><span class="line">	<span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭上下文</span></span><br><span class="line">	<span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// image转data</span></span><br><span class="line">	<span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将图片写入到文件</span></span><br><span class="line">	[data writeToFile:<span class="string">@"xxxx.png"</span> atomically:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带边框的圆角图片</span></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)imageWithClipImage:(<span class="built_in">UIImage</span> *)image borderWidth:(<span class="built_in">CGFloat</span>)borderWidth borderColor:(<span class="built_in">UIColor</span> *)color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 图片的宽度和高度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> imageWH = image<span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置圆环的宽度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> border = borderWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 圆形的宽度和高度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> ovalWH = imageWH + <span class="number">2</span> * border;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.开启上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="built_in">CGSizeMake</span>(ovalWH, ovalWH), <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.画大圆</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, ovalWH, ovalWH)];</span><br><span class="line">    </span><br><span class="line">    [color set];</span><br><span class="line">    </span><br><span class="line">    [path fill];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.设置裁剪区域</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *clipPath = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(border, border, imageWH, imageWH)];</span><br><span class="line">    [clipPath addClip];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.绘制图片</span></span><br><span class="line">    [image drawAtPoint:<span class="built_in">CGPointMake</span>(border, border)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.获取图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *clipImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6.关闭上下文</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> clipImage;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片裁剪</span></span><br><span class="line">- (<span class="keyword">void</span>)clipImage&#123;</span><br><span class="line">	<span class="comment">// 0.加载图片</span></span><br><span class="line">	<span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx"</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1.开启位图上下文,跟图片尺寸一样大</span></span><br><span class="line">	<span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(image<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.设置圆形裁剪区域,正切于图片</span></span><br><span class="line">	<span class="comment">// 2.1创建圆形的路径</span></span><br><span class="line">	<span class="built_in">UIBerzierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,image<span class="variable">.size</span><span class="variable">.width</span>,image<span class="variable">.size</span><span class="variable">.height</span>)];</span><br><span class="line">	<span class="comment">// 2.2将路径设置为裁剪区域</span></span><br><span class="line">	[path addClip];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.绘制图片</span></span><br><span class="line">	[image drawAtPoint:<span class="built_in">CGPointZero</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.从上下文中获取图片</span></span><br><span class="line">	<span class="built_in">UIImage</span> *imageWater = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5.关闭上下文</span></span><br><span class="line">	<span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片水印</span></span><br><span class="line">- (<span class="keyword">void</span>)waterImage&#123;</span><br><span class="line">	<span class="comment">// 位图上下文需要手动创建和关闭</span></span><br><span class="line">	<span class="comment">// 开启一个位图上下文,注意位图上下文跟view无关联,所以不需要在drawRect中使用</span></span><br><span class="line">	<span class="comment">// size:位图上下文的尺寸(新图片的尺寸)</span></span><br><span class="line">	<span class="comment">// opaque: 不透明度 YES:不透明 NO:透明,通常我们一般都设置为透明的上下文</span></span><br><span class="line">	<span class="comment">// scale: 通常不需要缩放上下文,取值为0,表示不缩放</span></span><br><span class="line">	<span class="comment">// 1.开启图形上下文,绘制原生的图片</span></span><br><span class="line">	<span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx"</span>];</span><br><span class="line">	<span class="comment">//等同于UIGraphicsBeginImageContextWithOptions(image.size, NO, [UIScreen mainScreen].scale);</span></span><br><span class="line">	<span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(image<span class="variable">.size</span>, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1).获取上下文--位图上下文不是layer上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">	<span class="comment">// 2).描述路径</span></span><br><span class="line">	<span class="built_in">CGContextMoveToPoint</span>(ctx, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">	<span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">	<span class="comment">// 3).渲染上下文</span></span><br><span class="line">	<span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.给原生的图片添加文字</span></span><br><span class="line">	<span class="built_in">NSString</span> *text = <span class="string">@"abcd"</span>;</span><br><span class="line">	[text drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>,<span class="number">528</span>) withAttributes:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.生成一张图片,从当前上下文中获取图片</span></span><br><span class="line">	<span class="built_in">UIImage</span> *imageWater = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.关闭上下文</span></span><br><span class="line">	<span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形上下文矩阵操作(平移、缩放、旋转)</span></span><br><span class="line">- (<span class="keyword">void</span>)drawView&#123;</span><br><span class="line">	<span class="comment">// 1.获取上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.描述路径</span></span><br><span class="line">	<span class="comment">// 绘制椭圆</span></span><br><span class="line">	<span class="built_in">UIBerzierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(-<span class="number">100</span>,-<span class="number">50</span>,<span class="number">200</span>,<span class="number">100</span>)];</span><br><span class="line"></span><br><span class="line">	[[<span class="built_in">UIColor</span> redColor] set];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 上下文矩阵操作</span></span><br><span class="line">	<span class="comment">// 平移 </span></span><br><span class="line">	<span class="comment">// 注意:矩阵操作必须要在添加路径之前</span></span><br><span class="line">	<span class="built_in">CGContextTranslateCTM</span>(ctx,<span class="number">100</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缩放</span></span><br><span class="line">	<span class="built_in">CGContextScaleCTM</span>(ctx,<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 旋转</span></span><br><span class="line">	<span class="built_in">CGContextRotateCTM</span>(ctx,M_PI_4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.将路径添加到上下文</span></span><br><span class="line">	<span class="built_in">CGContextAddPath</span>(ctx,path<span class="variable">.CGPath</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.渲染上下文</span></span><br><span class="line">	<span class="built_in">CGContextFillPath</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形上下文状态栈</span></span><br><span class="line"><span class="comment">// 如果用贝瑟尔绘制图形[path stroke],上下文的状态由贝瑟尔路径状态决定</span></span><br><span class="line">- (<span class="keyword">void</span>)drawTwoLines&#123;</span><br><span class="line">	<span class="comment">// 1.获取上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.描述路径 第一根线</span></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line"></span><br><span class="line">	[path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">10</span>,<span class="number">125</span>)];</span><br><span class="line"></span><br><span class="line">	[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">240</span>,<span class="number">125</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.将路径添加到上下文</span></span><br><span class="line">	<span class="built_in">CGContextAddPath</span>(ctx,path<span class="variable">.CGPath</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先保存一份上下文的状态</span></span><br><span class="line">	<span class="built_in">CGContextSaveGState</span>(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.设置上下文状态</span></span><br><span class="line">	<span class="built_in">CGContextSetLineWidth</span>(ctx,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	[[<span class="built_in">UIColor</span> redColr] set];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5.渲染上下文</span></span><br><span class="line">	<span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二根线</span></span><br><span class="line">	path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line"></span><br><span class="line">	[path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">125</span>,<span class="number">10</span>)];</span><br><span class="line"></span><br><span class="line">	[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">125</span>,<span class="number">240</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGContextAddPath</span>(ctx,path<span class="variable">.CGPath</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 恢复上下文状态</span></span><br><span class="line">	<span class="built_in">CGContextRestoreGState</span>(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//CGContextSetLineWidth(ctx,5);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//[[UIColor blackColr] set];</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制雪花</span></span><br><span class="line">- (<span class="keyword">void</span>)drawSnow&#123;</span><br><span class="line">	<span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx"</span>];</span><br><span class="line">	[image drawAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>,_snowY)];</span><br><span class="line">	_snowY += <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">if</span>(_snowY &gt; rect<span class="variable">.size</span><span class="variable">.height</span>)&#123;</span><br><span class="line">		_snowY = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib&#123;</span><br><span class="line">	<span class="comment">// 创建定时器 </span></span><br><span class="line">	<span class="comment">// CADisplayLink:每次屏幕刷新的时候会调用,屏幕一般一秒刷新60次</span></span><br><span class="line">	<span class="built_in">CADisplayLink</span> *display = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timeChange)];</span><br><span class="line">	<span class="comment">// 添加到主运行循环</span></span><br><span class="line">	[display addToRunLoop:[<span class="built_in">NSRunLoop</span> mainRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timeChange&#123;</span><br><span class="line">	<span class="comment">// 注意:这个方法并不会马上调用drawRect,这个方法只是给当前控件添加一个刷新标记,等下一次屏幕刷新的时候才会调用drawRect</span></span><br><span class="line">	[<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制图片</span></span><br><span class="line">- (<span class="keyword">void</span>)drawPic&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 超出裁剪区域的内容全部裁剪掉</span></span><br><span class="line">	<span class="comment">// 注意:裁剪必须放在绘制之前</span></span><br><span class="line">	<span class="built_in">UIRectClip</span>(<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx"</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认绘制的内容尺寸跟图片尺寸一样大</span></span><br><span class="line">	[image drawAtPoint:<span class="built_in">CGPointZero</span>];</span><br><span class="line">	<span class="comment">// 将图片控制在一定范围内</span></span><br><span class="line">	[image drawInRect:rect];</span><br><span class="line">	<span class="comment">// 将图片平铺</span></span><br><span class="line">	[image drawAsPatternInRect:rect];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制文字和图片</span></span><br><span class="line">- (<span class="keyword">void</span>)drawText&#123;</span><br><span class="line">	<span class="built_in">NSString</span> *words = <span class="string">@"abcdef"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">	<span class="comment">// 设置文字颜色</span></span><br><span class="line">	dict[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置文字字体</span></span><br><span class="line">	dict[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置文字的空心颜色和宽度</span></span><br><span class="line">	dict[<span class="built_in">NSStrokeWidthAttributeName</span>] = @<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	dict[<span class="built_in">NSStrokeColorAttributeName</span>] = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建阴影</span></span><br><span class="line">	<span class="built_in">NSShadow</span> *shadow = [[<span class="built_in">NSShadow</span> alloc] init];</span><br><span class="line">	shadow<span class="variable">.shadowColor</span> = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">	shadow<span class="variable">.shadowOffset</span> = <span class="built_in">CGSizeMake</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">	shadow<span class="variable">.shadowBlurRadius</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	dict[<span class="built_in">NSShadowAttributeName</span>] = shadow;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 文字的起点 不会换行</span></span><br><span class="line">	[words drawAtPoint:<span class="built_in">CGPointZero</span> withAttributes:dict];</span><br><span class="line">	<span class="comment">// 会换行</span></span><br><span class="line">	[words drawAtRect:rect withAttributes:dict];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制柱状图</span></span><br><span class="line">- (<span class="keyword">void</span>)drawZ&#123;</span><br><span class="line">	<span class="built_in">NSArray</span> *arr = @[@<span class="number">25</span>,@<span class="number">25</span>,@<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGFloat</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> y = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> w = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> h = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr<span class="variable">.count</span>;i++)&#123;</span><br><span class="line">		w = rect<span class="variable">.size</span><span class="variable">.width</span> / (<span class="number">2</span>*arr<span class="variable">.count</span> -<span class="number">1</span>);</span><br><span class="line">		x = <span class="number">2</span> * w * i;</span><br><span class="line">		h = [arr[i] floatValue] / <span class="number">100.0</span> * rect<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">		y = rect<span class="variable">.size</span><span class="variable">.height</span> - h;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:<span class="built_in">CGRectMake</span>(x, y, w, h)];</span><br><span class="line"></span><br><span class="line">		[[<span class="keyword">self</span> randomColor] set];</span><br><span class="line"></span><br><span class="line">		[path fill];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制饼图</span></span><br><span class="line">- (<span class="keyword">void</span>)drawBin&#123;</span><br><span class="line">	<span class="built_in">NSArray</span> *arr = @[@<span class="number">25</span>,@<span class="number">25</span>,@<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGFloat</span> radius = rect<span class="variable">.size</span><span class="variable">.width</span>*<span class="number">0.5</span>;</span><br><span class="line">	<span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(radius,radius);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGFloat</span> startA = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> angle = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> endA = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr<span class="variable">.count</span>;i++)&#123;</span><br><span class="line">		startA = endA;</span><br><span class="line">		angle = [arr[i] doubleValue] / <span class="number">100.0</span> *M_PI *<span class="number">2</span>;</span><br><span class="line">		endA = startA + angle;</span><br><span class="line">		<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 添加一根线到圆心</span></span><br><span class="line">		[path addLineToPoint:center];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 描边和填充通用</span></span><br><span class="line">		[[<span class="keyword">self</span> randomColor] set];</span><br><span class="line"></span><br><span class="line">		[path fill];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIColor</span> *)randomColor&#123;</span><br><span class="line">	<span class="built_in">CGFloat</span> r = arc4random_uniform(<span class="number">256</span>) / <span class="number">255.0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> g = arc4random_uniform(<span class="number">256</span>) / <span class="number">255.0</span>;</span><br><span class="line">	<span class="built_in">CGFloat</span> b = arc4random_uniform(<span class="number">256</span>) / <span class="number">255.0</span>;</span><br><span class="line">	<span class="keyword">return</span> [<span class="built_in">UIColor</span> colorWithRed:r green:g blue:b alpha:<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制下载进度 需要重绘的时候调用[self setNeedDisplay]</span></span><br><span class="line">- (<span class="keyword">void</span>)drawProgress&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGFloat</span> radius = rect<span class="variable">.size</span><span class="variable">.width</span>*<span class="number">0.5</span>;</span><br><span class="line">	<span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(radius,radius);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGFloat</span> endAngle = -M_PI_2 + _progress * M_PI *<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:radius startAngle:-M_PI_2 endAngle:endAngle clockwise:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">	[path stroke];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制扇形</span></span><br><span class="line">- (<span class="keyword">void</span>)drawArc2&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(<span class="number">125</span>,<span class="number">125</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:<span class="number">100</span> startAngle:<span class="number">0</span> endAngle:M_PI_2 clockwise:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加一根线到圆心</span></span><br><span class="line">	[path addLineToPoint:center];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 封闭路径,关闭路径:从路径的终点到起点</span></span><br><span class="line">	[path closePath];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充:必须是一个完整的封闭路径,默认就会自动关闭路径</span></span><br><span class="line">	[path fill];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制圆弧</span></span><br><span class="line">- (<span class="keyword">void</span>)drawArc&#123;</span><br><span class="line">	<span class="comment">// Center: 圆心</span></span><br><span class="line">	<span class="comment">// startAngle: 弧度</span></span><br><span class="line">	<span class="comment">// clockwise: YES是顺时针 NO是逆时针</span></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:<span class="built_in">CGPointMake</span>(<span class="number">125</span>,<span class="number">125</span>) radius:<span class="number">100</span> startAngle:<span class="number">0</span> endAngle:-M_PI_2 clockwise:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line">	[path stroke];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制圆角矩形</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRoundRect&#123;</span><br><span class="line">	<span class="comment">// 圆角矩形  如果圆角半径为矩形宽度的一般 则是圆</span></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(<span class="number">20</span>,<span class="number">20</span>,<span class="number">200</span>,<span class="number">200</span>) cornerRadius:<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//[path stroke];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充</span></span><br><span class="line">	[path fill];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制曲线</span></span><br><span class="line">- (<span class="keyword">void</span>)drawQuadCurve&#123;</span><br><span class="line">	<span class="comment">// 获取上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 描述路径</span></span><br><span class="line">	<span class="built_in">CGContextMoveToPoint</span>(ctx, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// cpx:控制点的x cpy:控制点的y</span></span><br><span class="line">	<span class="built_in">CGContextAddQuadCurveToPoint</span>(ctx,<span class="number">150</span>,<span class="number">20</span>,<span class="number">250</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 渲染上下文</span></span><br><span class="line">	<span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用UIBezierPath绘制有状态信息的线条</span></span><br><span class="line">- (<span class="keyword">void</span>)drawBezierStatus&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置起点</span></span><br><span class="line">	[path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">50</span>,<span class="number">50</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加一根线到某个点</span></span><br><span class="line">	[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>,<span class="number">200</span>)];</span><br><span class="line"></span><br><span class="line">	path<span class="variable">.lineWidth</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	[[<span class="built_in">UIColor</span> redColor] set];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制路径</span></span><br><span class="line">	[path stroke];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path1 = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置起点</span></span><br><span class="line">	[path1 moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>,<span class="number">0</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加一根线到某个点</span></span><br><span class="line">	[path1 addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">30</span>,<span class="number">60</span>)];</span><br><span class="line"></span><br><span class="line">	path1<span class="variable">.lineWidth</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	[[<span class="built_in">UIColor</span> blueColor] set];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制路径</span></span><br><span class="line">	[path1 stroke];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制有状态信息的线条</span></span><br><span class="line">- (<span class="keyword">void</span>)drawCtxStatus&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1.获取图形上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 描述路径</span></span><br><span class="line">	<span class="built_in">CGContextMoveToPoint</span>(ctx, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新设置起点</span></span><br><span class="line">	<span class="built_in">CGContextMoveToPoint</span>(ctx, <span class="number">80</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认下一根线的起点就是上一根线的终点</span></span><br><span class="line">	<span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置绘图状态,一定要在渲染之前</span></span><br><span class="line">	<span class="comment">// 设置描边颜色</span></span><br><span class="line">	[[<span class="built_in">UIColor</span> redColor] setStroke];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置线宽</span></span><br><span class="line">	<span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置连接样式kCGLineJoinBevel、kCGLineJoinMiter、kCGLineJoinRound</span></span><br><span class="line">	<span class="built_in">CGContextSetLineJoin</span>(ctx, k<span class="built_in">CGLineJoinRound</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置顶角样式kCGLineCapButt、kCGLineCapRound、kCGLineCapSquare</span></span><br><span class="line">	<span class="built_in">CGContextSetLineCap</span>(ctx, k<span class="built_in">CGLineCapRound</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 渲染上下文</span></span><br><span class="line">	<span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用UIBezierPath绘制线条</span></span><br><span class="line">- (<span class="keyword">void</span>)drawLine1&#123;</span><br><span class="line">	<span class="comment">// 贝瑟尔路径</span></span><br><span class="line">	<span class="comment">// 创建路径</span></span><br><span class="line">	<span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置起点</span></span><br><span class="line">	[path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">50</span>,<span class="number">50</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加一根线到某个点</span></span><br><span class="line">	[path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>,<span class="number">200</span>)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制路径</span></span><br><span class="line">	[path stroke];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制线条</span></span><br><span class="line">- (<span class="keyword">void</span>)drawLine&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1.获取图形上下文</span></span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面4步相当于</span></span><br><span class="line">	<span class="comment">//CGContextMoveToPoint(ctx, 50, 50);</span></span><br><span class="line">	<span class="comment">//CGContextAddLineToPoint(ctx, 200, 200);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.描述路径</span></span><br><span class="line">	<span class="comment">// 创建路径</span></span><br><span class="line">	<span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置起点</span></span><br><span class="line">	<span class="comment">// path: 给哪个路径设置起点</span></span><br><span class="line">	<span class="built_in">CGPathMoveToPoint</span>(path, <span class="literal">NULL</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加一根线到某个点</span></span><br><span class="line">	<span class="built_in">CGPathAddLineToPoint</span>(path, <span class="literal">NULL</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.将路径添加到上下文</span></span><br><span class="line">	<span class="built_in">CGContextAddPath</span>(ctx, path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.渲染上下文</span></span><br><span class="line">	<span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="什么是Quartz2D">什么是Quartz2D</h3><ul>
<li>Quartz 2D是一个二维绘图引擎,同时支持iOS和Mac系统</li>
<li>Quartz 2D 能完成的工作<ul>
<li>绘制图形:线条\三角形\矩形\弧等</li>
<li>绘制文字</li>
<li>绘制\生成图片(图像)</li>
<li>读取\生成PDF</li>
<li>截图\裁剪图片</li>
<li>自定义UI控件</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSInvocation的使用]]></title>
    <link href="http://yoursite.com/2016/04/04/nsinvocation/"/>
    <id>http://yoursite.com/2016/04/04/nsinvocation/</id>
    <published>2016-04-04T12:43:37.000Z</published>
    <updated>2016-04-05T12:42:50.000Z</updated>
    <content type="html"><![CDATA[<h3 id="NSInvocation的简单使用">NSInvocation的简单使用</h3><h5 id="创建方法签名">创建方法签名</h5><ul>
<li>使用NSObject的对象方法或者类方法来创建NSMethodSignature<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSObject的对象方法,任何继承自NSObject的对象都可以调用</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSObject的类方法,任何继承自NSObject的类都可以调用</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)instanceMethodSignatureForSelector:(SEL)aSelector</span><br><span class="line"></span><br><span class="line">SEL selector = <span class="built_in">NSSelectorFromString</span>(methodNameStr);</span><br><span class="line"><span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">self</span> methodSignatureForSelector:selector];</span><br><span class="line"><span class="comment">//或使用下面这种方式</span></span><br><span class="line"><span class="built_in">NSMethodSignature</span> *signature = [[<span class="keyword">self</span> class] instanceMethodSignatureForSelector:selector];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li>NSMethodSignature常用的只读属性<ul>
<li>numberOfArguments:方法参数的个数</li>
<li>methodReturnLength:方法返回值类型的长度,大于0表示有返回值</li>
</ul>
</li>
</ul>
<h4 id="使用方法的签名来创建一个NSInvocation对象">使用方法的签名来创建一个NSInvocation对象</h4><p><code>NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</code></p>
<h4 id="给invocation对象的两个属性赋值">给invocation对象的两个属性赋值</h4><ul>
<li>要执行谁的(target)的哪个方法(selector)<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">invocation<span class="variable">.target</span> = <span class="keyword">self</span>;</span><br><span class="line">invocation<span class="variable">.selector</span> = <span class="keyword">@selector</span>(test:withArg2:andArg3:);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="给要执行的方法设置参数">给要执行的方法设置参数</h4><ul>
<li>使用setArgument:atIndex:方法给要执行的方法设置参数,注意下标从2开始,因为0、1已经被target与selector占用.设置参数,必须传递参数的地址,不能直接传值<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *arg1 = <span class="string">@"a"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *arg2 = <span class="string">@"b"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *arg3 = <span class="string">@"c"</span>;</span><br><span class="line">[invocation setArgument:&amp;arg1 atIndex:<span class="number">2</span>];</span><br><span class="line">[invocation setArgument:&amp;arg2 atIndex:<span class="number">3</span>];</span><br><span class="line">[invocation setArgument:&amp;arg3 atIndex:<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="执行方法">执行方法</h4><p><code>[invocation invoke];</code></p>
<h4 id="获取执行方法的返回值">获取执行方法的返回值</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以在invoke方法前添加,也可以在invoke方法后添加</span></span><br><span class="line"><span class="comment">// 通过方法签名的methodReturnLength判断是否有返回值</span></span><br><span class="line"><span class="keyword">if</span> (signature<span class="variable">.methodReturnLength</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">id</span> *result = <span class="literal">nil</span>;</span><br><span class="line">    [invocation getReturnValue:&amp;result];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为NSObject添加分类封装多个参数的方法调用">为NSObject添加分类封装多个参数的方法调用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Extension</span>)</span></span><br><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)selector withObjects:(<span class="built_in">NSArray</span> *)objects</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法签名(方法的描述)-哪个对象的哪个方法</span></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [[<span class="keyword">self</span> class] instanceMethodSignatureForSelector:selector];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(signature == <span class="literal">nil</span>)&#123;</span><br><span class="line">        <span class="comment">//@throw [NSException exceptionWithName:@"调用错误" reason:@"方法找不到" userInfo:nil];</span></span><br><span class="line">        [<span class="built_in">NSException</span> raise:<span class="string">@"调用错误"</span> format:<span class="string">@"%@方法找不到"</span>,<span class="built_in">NSStringFromSelector</span>(selector)];</span><br><span class="line">        <span class="comment">//return nil;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// NSInvocation: 利用一个NSInvocation对象包装一次方法调用(方法调用者、方法名、方法参数、方法返回值)</span></span><br><span class="line">    <span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    <span class="comment">// 除self、_cmd(方法本身)之外的参数个数</span></span><br><span class="line">    <span class="built_in">NSInteger</span> paramsCount = signature<span class="variable">.numberOfArguments</span>-<span class="number">2</span>;</span><br><span class="line">    paramsCount = MIN(paramsCount, objects<span class="variable">.count</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i=<span class="number">0</span>; i&lt;paramsCount; i++) &#123;</span><br><span class="line">        <span class="keyword">id</span> object = objects[i];</span><br><span class="line">        <span class="keyword">if</span>([object isKindOfClass:[<span class="built_in">NSNull</span> class]]) <span class="keyword">continue</span>;</span><br><span class="line">        [invocation setArgument:&amp;object atIndex:i+<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 谁来调用</span></span><br><span class="line">    invocation<span class="variable">.target</span> = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用哪个方法</span></span><br><span class="line">    invocation<span class="variable">.selector</span> = selector;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    [invocation invoke];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取返回值</span></span><br><span class="line">    <span class="keyword">id</span> returnValue = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有返回值类型,才去获取返回值</span></span><br><span class="line">    <span class="keyword">if</span>(signature<span class="variable">.methodReturnLength</span>)&#123;</span><br><span class="line">        [invocation getReturnValue:&amp;returnValue];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="NSInvocation的简单使用">NSInvocation的简单使用</h3><h5 id="创建方法签名">创建方法签名</h5><ul>
<li>使用NSObject的对象方法或者类方法来创建NSMethodSignature<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSObject的对象方法,任何继承自NSObject的对象都可以调用</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSObject的类方法,任何继承自NSObject的类都可以调用</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)instanceMethodSignatureForSelector:(SEL)aSelector</span><br><span class="line"></span><br><span class="line">SEL selector = <span class="built_in">NSSelectorFromString</span>(methodNameStr);</span><br><span class="line"><span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">self</span> methodSignatureForSelector:selector];</span><br><span class="line"><span class="comment">//或使用下面这种方式</span></span><br><span class="line"><span class="built_in">NSMethodSignature</span> *signature = [[<span class="keyword">self</span> class] instanceMethodSignatureForSelector:selector];</span><br></pre></td></tr></table></figure>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS使用Reachability实时检测网络连接状况]]></title>
    <link href="http://yoursite.com/2016/04/03/reachability/"/>
    <id>http://yoursite.com/2016/04/03/reachability/</id>
    <published>2016-04-03T10:22:04.000Z</published>
    <updated>2016-04-03T14:11:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Reachability能做什么">Reachability能做什么</h3><ul>
<li><p>监测网络是否可用</p>
</li>
<li><p>判断当前处于什么网络环境(2G/3G,WIFI)</p>
</li>
<li><p>监测连接方式的变更</p>
</li>
</ul>
<a id="more"></a>
<h3 id="下载">下载</h3><ul>
<li><p>苹果官方:<a href="https://developer.apple.com/library/ios/samplecode/Reachability/Introduction/Intro.html" target="_blank" rel="external">点击下载</a></p>
</li>
<li><p>Git:<a href="https://github.com/tonymillion/Reachability" target="_blank" rel="external">点击下载</a></p>
</li>
</ul>
<h3 id="安装">安装</h3><ul>
<li>下载Reachability.h和Reachability.m文件,拽入你的工程中,然后添加SystemConfiguration.framework库即可</li>
</ul>
<h3 id="使用">使用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) Reachability  *reachability;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在程序的启动处,开启通知</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)applicationdidFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 开启网络状况的监听</span></span><br><span class="line">	[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(reachabilityChanged:) name:kReachabilityChangedNotification object: <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//self.reachability = [Reachability reachabilityWithHostName:@"www.apple.com"];</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">self</span><span class="variable">.reachability</span> = [Reachability reachabilityForInternetConnection];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始监听,会启动一个RunLoop</span></span><br><span class="line">	[<span class="keyword">self</span><span class="variable">.reachability</span> startNotifier]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Called by Reachability whenever status changes.</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) reachabilityChanged:(<span class="built_in">NSNotification</span> *)note</span><br><span class="line">&#123;</span><br><span class="line">     Reachability* curReach = [note object];</span><br><span class="line"></span><br><span class="line">     <span class="built_in">NSParameterAssert</span>([curReach isKindOfClass:[Reachability class]]);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 更新用户界面,或者在当前状态实现你想要的处理</span></span><br><span class="line">     [<span class="keyword">self</span> updateInterfaceWithReachability:curReach];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理连接改变后的情况</span></span><br><span class="line">- (<span class="keyword">void</span>)updateInterfaceWithReachability: (Reachability*)curReach</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 对连接改变做出响应的处理动作</span></span><br><span class="line">	NetworkStatus status=[curReach currentReachabilityStatus];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(status)&#123;</span><br><span class="line">		<span class="keyword">case</span> NotReachable: <span class="comment">// 没有连接到网络</span></span><br><span class="line">			<span class="built_in">UIAlertView</span> *alert= [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"xxxx"</span> message:<span class="string">@"NotReachable"</span></span><br><span class="line">                         delegate:<span class="literal">nil</span> cancelButtonTitle:<span class="string">@"YES"</span> otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">        	alert show];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ReachableViaWWAN: <span class="comment">// 使用3G网络</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ReachableViaWiFi:  <span class="comment">// 使用WiFi网络 </span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否wifi</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>) IsEnableWIFI</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ([[Reachability reachabilityForLocalWiFi] currentReachabilityStatus] != NotReachable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否3G</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>) IsEnable3G</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> ([[Reachability reachabilityForInternetConnection] currentReachabilityStatus] != NotReachable);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">	[[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">	[<span class="keyword">self</span><span class="variable">.reachability</span> stopNotifier];</span><br><span class="line">	<span class="keyword">self</span><span class="variable">.reachability</span> = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Reachability能做什么">Reachability能做什么</h3><ul>
<li><p>监测网络是否可用</p>
</li>
<li><p>判断当前处于什么网络环境(2G/3G,WIFI)</p>
</li>
<li><p>监测连接方式的变更</p>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS实现图片轮播]]></title>
    <link href="http://yoursite.com/2016/04/03/image_switch/"/>
    <id>http://yoursite.com/2016/04/03/image_switch/</id>
    <published>2016-04-03T03:04:43.000Z</published>
    <updated>2016-04-03T09:40:19.000Z</updated>
    <content type="html"><![CDATA[<h3 id="使用2个UIImageView实现图片轮播">使用2个UIImageView实现图片轮播</h3><h4 id="轮播原理">轮播原理</h4><ul>
<li>假设轮播控件的宽度为x高度为y,我们设置UIScrollView的contentSize.width为3x,并让UIScrollView的水平偏移量为x,既显示最中间内容<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">scrollView<span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="number">3</span>x, y);</span><br><span class="line">scrollView<span class="variable">.contentOffset</span> = <span class="built_in">CGPointMake</span>(x, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>将UIImageView添加到UIScrollView内容视图的中间位置</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_currImageView<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(x, <span class="number">0</span>, x, y);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用KVO来监听direction属性值的改变</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"direction"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过KVO方式监听UIScrollView滚动方向的变化</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span>(change[<span class="built_in">NSKeyValueChangeNewKey</span>] == change[<span class="built_in">NSKeyValueChangeOldKey</span>]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNewKey</span>] intValue] == DirecRight) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.otherImageView</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.height</span>);</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.nextIndex</span> = <span class="keyword">self</span><span class="variable">.currIndex</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.nextIndex</span> &lt; <span class="number">0</span>) <span class="keyword">self</span><span class="variable">.nextIndex</span> = _images<span class="variable">.count</span> - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNewKey</span>] intValue] == DirecLeft)&#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.otherImageView</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="built_in">CGRectGetMaxX</span>(_currImageView<span class="variable">.frame</span>), <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.height</span>);</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.nextIndex</span> = (<span class="keyword">self</span><span class="variable">.currIndex</span> + <span class="number">1</span>) % _images<span class="variable">.count</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.otherImageView</span><span class="variable">.image</span> = <span class="keyword">self</span><span class="variable">.images</span>[<span class="keyword">self</span><span class="variable">.nextIndex</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来使用UIScrollView代理方法来监听scrollview的滚动,定义一个枚举变量来记录滚动的方向</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</span><br><span class="line">  DirecNone,</span><br><span class="line">  DirecLeft,</span><br><span class="line">  DirecRight</span><br><span class="line">&#125; Direction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) Direction direction;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动UIScrollView持续会调用这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">  <span class="keyword">self</span><span class="variable">.direction</span> = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span> &gt;x? DirecLeft : DirecRight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手指即将开始拽动UIScrollView</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    [<span class="keyword">self</span> stopTimer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束拖拽</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate&#123;</span><br><span class="line">    [<span class="keyword">self</span> startTimer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手指停止并结束滚动UIScrollView</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    [<span class="keyword">self</span> pauseScroll];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [self.scrollView setContentOffset:CGPointMake(self.width * 2, 0) animated:YES];</span></span><br><span class="line"><span class="comment">// 通过设置动画滚动UIScrollView结束的时候会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    [<span class="keyword">self</span> pauseScroll];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理停止滚动UIScrollView</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// self.scrollView.contentOffset = CGPointMake(self.width, 0);不会调用下面这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)pauseScroll &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.direction</span> = DirecNone;<span class="comment">// 重置方向</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.contentOffset</span><span class="variable">.x</span> / <span class="keyword">self</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">1</span>) <span class="keyword">return</span>;<span class="comment">// 滚动位置未变,则不处理</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.currIndex</span> = <span class="keyword">self</span><span class="variable">.nextIndex</span>;<span class="comment">// 记录当前滚动位置</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.pageControl</span><span class="variable">.currentPage</span> = <span class="keyword">self</span><span class="variable">.currIndex</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.currImageView</span><span class="variable">.image</span> = <span class="keyword">self</span><span class="variable">.otherImageView</span><span class="variable">.image</span>; <span class="comment">// 设置中间UIImageView的UIImage为otherImageView的UIImage</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.contentOffset</span> = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span><span class="variable">.width</span>, <span class="number">0</span>);<span class="comment">// 滚动UIScrollView到中间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="总结">总结</h4><ul>
<li><p>一直保持滑动到中间位置</p>
</li>
<li><p>往左滑动的时候将第二个视图放到最右边并设置其UIImage为下一张图片,滑动结束时还原操作使得UIScrollView滚动到中间位置并更新中间视图和上一个视图</p>
</li>
<li><p>往右滑动的时候将第二个视图放到最左边并设置其UIImage为上一张图片,滑动结束时还原操作使得UIScrollView滚动到中间位置并更新中间视图和上一个视图</p>
</li>
</ul>
<h4 id="使用三个UIImageView实现图片轮播">使用三个UIImageView实现图片轮播</h4><ul>
<li>地址:<a href="http://www.tuicool.com/articles/m6FJr2" target="_blank" rel="external">http://www.tuicool.com/articles/m6FJr2</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="使用2个UIImageView实现图片轮播">使用2个UIImageView实现图片轮播</h3><h4 id="轮播原理">轮播原理</h4><ul>
<li>假设轮播控件的宽度为x高度为y,我们设置UIScrollView的contentSize.width为3x,并让UIScrollView的水平偏移量为x,既显示最中间内容<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">scrollView<span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="number">3</span>x, y);</span><br><span class="line">scrollView<span class="variable">.contentOffset</span> = <span class="built_in">CGPointMake</span>(x, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS网络]]></title>
    <link href="http://yoursite.com/2016/03/28/ios_network/"/>
    <id>http://yoursite.com/2016/03/28/ios_network/</id>
    <published>2016-03-28T03:08:14.000Z</published>
    <updated>2016-03-29T12:16:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="NSURLConnection">NSURLConnection</h3><h4 id="常用类">常用类</h4><ul>
<li><p>NSURL:请求地址</p>
</li>
<li><p>NSURLRequest:一个NSURLRequest对象就代表一个请求,它包含的信息有</p>
<ul>
<li>一个NSURL对象</li>
<li>请求方法、请求头、请求体</li>
<li>请求超时</li>
<li>…</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>NSMutableURLRequest:NSURLRequest的子类</p>
</li>
<li><p>NSURLConnection</p>
<ul>
<li>负责发送请求,建立客户端和服务端的连接</li>
<li>发送数据给服务器,并收集来自服务器的响应数据</li>
</ul>
</li>
</ul>
<h4 id="NSURLConnection的使用步骤">NSURLConnection的使用步骤</h4><ul>
<li>使用发送请求的步骤很简单<ul>
<li>创建一个NSURL对象,设置请求路径</li>
<li>传人NSURL创建一个NSURLRequest对象,设置请求头和请求体</li>
<li>使用NSURLConnection发送请求</li>
</ul>
</li>
</ul>
<h4 id="NSURLConnection发送请求">NSURLConnection发送请求</h4><h4 id="同步请求">同步请求</h4><p><code>+ (nullable NSData *)sendSynchronousRequest:(NSURLRequest *)request returningResponse:(NSURLResponse * __nullable * __nullable)response error:(NSError **)error</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 发送同步请求</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)sync</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="comment">// sendSynchronousRequest阻塞式的方法,等待服务器返回数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSHTTPURLResponse</span> *response = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.解析服务器返回的数据(解析成字符串)</span></span><br><span class="line">    <span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, string, response<span class="variable">.allHeaderFields</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步请求:根据对服务器返回数据的处理方式的不同,又可以分为2种:block回调和代理">异步请求:根据对服务器返回数据的处理方式的不同,又可以分为2种:block回调和代理</h4><p><code>+ (void)sendAsynchronousRequest:(NSURLRequest*) request queue:(NSOperationQueue*) queue completionHandler:(void (^)(NSURLResponse* __nullable response, NSData* __nullable data, NSError* __nullable connectionError)) handler</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 发送异步请求</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)async</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 0.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[[<span class="built_in">NSOperationQueue</span> alloc] init] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="comment">// 请求完毕会来到这个block</span></span><br><span class="line">        <span class="comment">// 3.解析服务器返回的数据(解析成字符串)</span></span><br><span class="line">        <span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, string);</span><br><span class="line">        <span class="built_in">NSHTTPURLResponse</span> *r = (<span class="built_in">NSHTTPURLResponse</span> *)response;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd %@"</span>, r<span class="variable">.statusCode</span>, r<span class="variable">.allHeaderFields</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认会开启线程执行异步请求:">默认会开启线程执行异步请求:</h4><p><code>+ (nullable NSURLConnection*)connectionWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate</code><br><code>- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate</code><br><code>- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate startImmediately:(BOOL)startImmediately</code><br>在startImmediately = NO的情况下,需要调用start方法开始发送请求<br><code>- (void)start</code><br>成为NSURLConnection的代理,最好遵守NSURLConnectionDataDelegate协议<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)delegateAysnc</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 0.请求路径</span></span><br><span class="line">	<span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.创建请求对象</span></span><br><span class="line">	<span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.创建连接对象</span></span><br><span class="line">    <span class="comment">//[[NSURLConnection alloc] initWithRequest:request delegate:self];</span></span><br><span class="line">    <span class="comment">//不是马上发请求,startImmediately如果是YES就不需要strat</span></span><br><span class="line">    <span class="comment">//NSURLConnection *conn = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO];</span></span><br><span class="line">    <span class="comment">//[conn start];</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURLConnection</span> *conn = [<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消</span></span><br><span class="line">    <span class="comment">//[conn cancel];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 接收到服务器的响应</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建data对象</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.responseData</span> = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveResponse"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 接收到服务器的数据(如果数据量比较大,这个方法会被调用多次)</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不断拼接服务器返回的数据</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.responseData</span> appendData:data];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveData -- %zd"</span>, data<span class="variable">.length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 服务器的数据成功接收完毕(回调到主线程)</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"connectionDidFinishLoading"</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithData:<span class="keyword">self</span><span class="variable">.responseData</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, string);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.responseData</span> = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 请求失败(比如请求超时)</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didFailWithError -- %@"</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="NSMutableURLRequest">NSMutableURLRequest</h4><ul>
<li><p>NSMutableURLRequest是NSURLRequest的子类,常用方法有:</p>
<ul>
<li><p>设置请求超时等待时间(超过这个时间就算超时,请求失败)<br><code>- (void)setTimeoutInterval:(NSTimeInterval)seconds;</code></p>
</li>
<li><p>设置请求方法(比如GET和POST)<br><code>- (void)setHTTPMethod:(NSString *)method;</code></p>
</li>
<li><p>设置请求体<br><code>- (void)setHTTPBody:(NSData *)data;</code></p>
</li>
<li><p>设置请求头<br><code>- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;</code><br><code>- (void)addValue:(NSString *)value forHTTPHeaderField:(NSString *)field;</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// 1.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/login"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.创建请求</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改请求方法</span></span><br><span class="line">    request<span class="variable">.HTTPMethod</span> = <span class="string">@"POST"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求体</span></span><br><span class="line">    request<span class="variable">.HTTPBody</span> = [<span class="string">@"xxx"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时(5秒后超时)</span></span><br><span class="line">    request<span class="variable">.timeoutInterval</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    [request setValue:<span class="string">@"iOS 9.0"</span> forHTTPHeaderField:<span class="string">@"User-Agent"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connectionError) &#123; <span class="comment">// 比如请求超时</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"----请求失败"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"------%@"</span>, [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="JSON解析方案">JSON解析方案</h4><ul>
<li><p>在iOS中,JSON的常见解析方式有4种</p>
<ul>
<li>第三方框架:JSONKit、SBJson、TouchJSON(性能从左到右,越差)</li>
<li>苹果原生(自带):NSJSONSerialization(性能最好)</li>
</ul>
</li>
<li><p>NSJSONSerialization的常见方法</p>
<ul>
<li><p>JSON数据 -&gt; OC对象<br><code>+ (nullable id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error;</code></p>
</li>
<li><p>OC对象 -&gt; JSON数据<br><code>+ (nullable NSData *)dataWithJSONObject:(id)obj options:(NSJSONWritingOptions)opt error:(NSError **)error;</code></p>
</li>
<li><p>log输出的时候如果JSON中有中文会显示不出来,可以重写NSDictionary和NSArray的<code>- (NSString *)descriptionWithLocale:(id)locale</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">@implementation NSDictionary (Log)</span><br><span class="line">- (NSString *)descriptionWithLocale:(id)locale</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableString *string = [NSMutableString string];</span><br><span class="line">    </span><br><span class="line">    // 开头有个&#123;</span><br><span class="line">    [string appendString:@"&#123;\n"];</span><br><span class="line">    </span><br><span class="line">    // 遍历所有的键值对</span><br><span class="line">    [self enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        [string appendFormat:@"\t%@", key];</span><br><span class="line">        [string appendString:@" : "];</span><br><span class="line">        [string appendFormat:@"%@,\n", obj];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 结尾有个&#125;</span><br><span class="line">    [string appendString:@"&#125;"];</span><br><span class="line">    </span><br><span class="line">    // 查找最后一个逗号</span><br><span class="line">    NSRange range = [string rangeOfString:@"," options:NSBackwardsSearch];</span><br><span class="line">    if (range.location != NSNotFound)</span><br><span class="line">    [string deleteCharactersInRange:range];</span><br><span class="line">    </span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSArray (Log)</span><br><span class="line"></span><br><span class="line">- (NSString *)descriptionWithLocale:(id)locale</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableString *string = [NSMutableString string];</span><br><span class="line">    </span><br><span class="line">    // 开头有个[</span><br><span class="line">    [string appendString:@"[\n"];</span><br><span class="line">    </span><br><span class="line">    // 遍历所有的元素</span><br><span class="line">    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">        [string appendFormat:@"\t%@,\n", obj];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 结尾有个]</span><br><span class="line">    [string appendString:@"]"];</span><br><span class="line">    </span><br><span class="line">    // 查找最后一个逗号</span><br><span class="line">    NSRange range = [string rangeOfString:@"," options:NSBackwardsSearch];</span><br><span class="line">    if (range.location != NSNotFound)</span><br><span class="line">    [string deleteCharactersInRange:range];</span><br><span class="line">    </span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="iOS中的XML解析">iOS中的XML解析</h4><ul>
<li><p>苹果原生</p>
<ul>
<li>NSXMLParser:SAX方式解析</li>
</ul>
</li>
<li><p>第三方框架</p>
<ul>
<li>libxml2:纯C语言,默认包含在iOS SDK中,同时支持DOM和SAX方式解析</li>
<li>GDataXML:DOM方式解析,由Google开发,基于libxml2</li>
</ul>
</li>
<li><p>XML解析方式的选择建议</p>
<ul>
<li>大文件:NSXMLParser、libxml2</li>
<li>小文件:GDataXML、NSXMLParser、libxml2</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *GDataXML</span><br><span class="line"> */</span>	</span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="comment">// 加载整个文档</span></span><br><span class="line">        GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data options:<span class="number">0</span> error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得所有video元素</span></span><br><span class="line">        <span class="built_in">NSArray</span> *elements = [doc<span class="variable">.rootElement</span> elementsForName:<span class="string">@"video"</span>];</span><br><span class="line">        <span class="keyword">for</span> (GDataXMLElement *ele <span class="keyword">in</span> elements) &#123;</span><br><span class="line">            XMGVideo *video = [[XMGVideo alloc] init];</span><br><span class="line">            video<span class="variable">.name</span> = [ele attributeForName:<span class="string">@"name"</span>]<span class="variable">.stringValue</span>;</span><br><span class="line">            video<span class="variable">.url</span> = [ele attributeForName:<span class="string">@"url"</span>]<span class="variable">.stringValue</span>;</span><br><span class="line">            video<span class="variable">.image</span> = [ele attributeForName:<span class="string">@"image"</span>]<span class="variable">.stringValue</span>;</span><br><span class="line">            video<span class="variable">.length</span> = [ele attributeForName:<span class="string">@"length"</span>]<span class="variable">.stringValue</span><span class="variable">.integerValue</span>;</span><br><span class="line">            </span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.videos</span> addObject:video];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *NSXMLParser</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0.请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://120.25.226.186:32812/video?type=XML"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="comment">// 创建XML解析器</span></span><br><span class="line">        <span class="built_in">NSXMLParser</span> *parser = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:data];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置代理</span></span><br><span class="line">        parser<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始解析XML</span></span><br><span class="line">        [parser parse];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新表格</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.tableView</span> reloadData];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSXMLParserDelegate&gt;</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 解析到某个元素的结尾（比如解析&lt;/videos&gt;）</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser didEndElement:(<span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="built_in">NSString</span> *)qName</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    NSLog(@"didEndElement - %@", elementName);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 解析到某个元素的开头（比如解析&lt;videos&gt;）</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)parser:(<span class="built_in">NSXMLParser</span> *)parser didStartElement:(<span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="built_in">NSString</span> *)qName attributes:(<span class="built_in">NSDictionary</span> *)attributeDict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([elementName isEqualToString:<span class="string">@"videos"</span>]) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//    XMGVideo *video = [[XMGVideo alloc] init];</span></span><br><span class="line"><span class="comment">//    video.keyValues = attributeDict;</span></span><br><span class="line">    </span><br><span class="line">    MCVideo *video = [MCVideo objectWithKeyValues:attributeDict];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.videos</span> addObject:video];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 开始解析XML文档</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)parserDidStartDocument:(<span class="built_in">NSXMLParser</span> *)parser</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    NSLog(@"parserDidStartDocument");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 解析完毕</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)parserDidEndDocument:(<span class="built_in">NSXMLParser</span> *)parser</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    NSLog(@"parserDidEndDocument");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小文件下载">小文件下载</h4><ul>
<li><p>如果文件比较小,下载方式会比较多</p>
<ul>
<li>直接用NSData的<code>+ (id)dataWithContentsOfURL:(NSURL *)url;</code></li>
<li>利用NSURLConnection发送一个HTTP请求去下载</li>
<li>如果是下载图片,还可以利用SDWebImage框架</li>
</ul>
</li>
<li><p>如果是大文件下载,建议使用NSURLSession或者第三方框架</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#define MCFile [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@<span class="title">"minion_15.mp4"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSURLConnectionDataDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIProgressView</span> *progressView;</span><br><span class="line"><span class="comment">/** 文件的总长度 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> contentLength;</span><br><span class="line"><span class="comment">/** 当前下载的总长度 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> currentLength;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 文件句柄对象 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSFileHandle</span> *handle;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxxx/resources/videos/minion_15.mp4"</span>];</span><br><span class="line">    [<span class="built_in">NSURLConnection</span> connectionWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:url] delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLConnectionDataDelegate&gt;</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 接收到响应的时候：创建一个空的文件</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得文件的总长度</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.contentLength</span> = [response<span class="variable">.allHeaderFields</span>[<span class="string">@"Content-Length"</span>] integerValue];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个空的文件</span></span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] createFileAtPath:M<span class="built_in">CFile</span> contents:<span class="literal">nil</span> attributes:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建文件句柄</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.handle</span> = [<span class="built_in">NSFileHandle</span> fileHandleForWritingAtPath:XMGFile];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 接收到具体数据:马上把数据写入一开始创建好的文件</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 指定数据的写入位置 -- 文件内容的最后面</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.handle</span> seekToEndOfFile];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.handle</span> writeData:data];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拼接总长度</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.currentLength</span> += data<span class="variable">.length</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进度</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.progressView</span><span class="variable">.progress</span> = <span class="number">1.0</span> * <span class="keyword">self</span><span class="variable">.currentLength</span> / <span class="keyword">self</span><span class="variable">.contentLength</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 关闭handle</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.handle</span> closeFile];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.handle</span> = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空长度</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.currentLength</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="第三方解压缩框架—SSZipArchive">第三方解压缩框架—SSZipArchive</h4><ul>
<li>下载地址:<a href="https://github.com/ZipArchive/ZipArchive" target="_blank" rel="external">https://github.com/ZipArchive/ZipArchive</a></li>
</ul>
<h4 id="文件上传步骤">文件上传步骤</h4><ul>
<li><p>设置请求头<br><code>[request setValue:@&quot;multipart/form-data;boundary=分隔线&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</code></p>
</li>
<li><p>设置请求体</p>
<ul>
<li><p>非文件参数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">--分隔线\r\n(为了支持不同平台,有些平台只有\r而有些是\n,为了统一所以这样做)</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"参数名"</span>\r\n</span><br><span class="line">\r\n</span><br><span class="line">参数值</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件参数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">--分隔线\r\n(为了支持不同平台,有些平台只有\r而有些是\n,为了统一所以这样做)</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"参数名"</span>;filename=<span class="string">"文件名"</span>\r\n</span><br><span class="line">Content-Type:文件的MIMEType\r\n</span><br><span class="line">\r\n</span><br><span class="line">文件数据</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数结束的标记<br><code>--分隔线--\r\n</code></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#define MCBoundary @<span class="title">"mc"</span></span></span><br><span class="line"><span class="preprocessor">#define MCEncode(string) [string dataUsingEncoding:NSUTF8StringEncoding]</span></span><br><span class="line"><span class="preprocessor">#define MCNewLine [@<span class="title">"\r\n"</span> dataUsingEncoding:NSUTF8StringEncoding]</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建请求</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://120.25.226.186:32812/upload"</span>];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    request<span class="variable">.HTTPMethod</span> = <span class="string">@"POST"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求头(告诉告诉服务器,这是一个文件上传的请求)</span></span><br><span class="line">    [request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"multipart/form-data; boundary=%@"</span>, MCBoundary] forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求体</span></span><br><span class="line">    <span class="built_in">NSMutableData</span> *body = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件参数</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     --分割线\r\n</span><br><span class="line">     Content-Disposition: form-data; name="参数名"; filename="文件名"\r\n</span><br><span class="line">     Content-Type: 文件的MIMEType\r\n</span><br><span class="line">     \r\n</span><br><span class="line">     文件数据</span><br><span class="line">     \r\n</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">// 分割线</span></span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCEncode(MCBoundary)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件参数名</span></span><br><span class="line">    [body appendData:MCEncode([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Content-Disposition: form-data; name=\"file\"; filename=\"test.png\""</span>])];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件的类型</span></span><br><span class="line">    [body appendData:MCEncode([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Content-Type: image/png"</span>])];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件数据</span></span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    <span class="comment">//UIImageJPEGRepresentation(&lt;#UIImage *image#&gt;, &lt;#CGFloat compressionQuality#&gt;)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>];</span><br><span class="line">    [body appendData:<span class="built_in">UIImagePNGRepresentation</span>(image)];</span><br><span class="line">    <span class="comment">//[body appendData:[NSData dataWithContentsOfFile:@"/Users/weifeng/Desktop/test.png"]];</span></span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非文件参数</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     --分割线\r\n</span><br><span class="line">     Content-Disposition: form-data; name="参数名"\r\n</span><br><span class="line">     \r\n</span><br><span class="line">     参数值</span><br><span class="line">     \r\n</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">// 分割线</span></span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCEncode(MCBoundary)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数名</span></span><br><span class="line">    [body appendData:MCEncode([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Content-Disposition: form-data; name=\"username\""</span>])];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数值</span></span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"jack"</span>)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束标记</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     --分割线--\r\n</span><br><span class="line">     */</span></span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCEncode(MCBoundary)];</span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    request<span class="variable">.HTTPBody</span> = body;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="将NSData写入文件的几种方式">将NSData写入文件的几种方式</h4><ul>
<li>NSFileHandle</li>
<li>NSOutputStream</li>
<li>NSData的实例方法<code>- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSURLConnectionDataDelegate</span>&gt;</span></span><br><span class="line"><span class="comment">/** 输出流对象 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOutputStream</span> *stream;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSURLConnection</span> connectionWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxxx/resources/videos/minion_01.mp4"</span>]] delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLConnectionDataDelegate&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// response.suggestedFilename : 服务器那边的文件名</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *caches = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">    <span class="built_in">NSString</span> *file = [caches stringByAppendingPathComponent:response<span class="variable">.suggestedFilename</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, file);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用NSOutputStream往Path中写入数据（append为YES的话，每次写入都是追加到文件尾部）</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.stream</span> = [[<span class="built_in">NSOutputStream</span> alloc] initToFileAtPath:file append:<span class="literal">YES</span>];</span><br><span class="line">    <span class="comment">// 打开流(如果文件不存在，会自动创建)</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.stream</span> open];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.stream</span> write:[data bytes] maxLength:data<span class="variable">.length</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveData-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.stream</span> close];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"-------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="子线程中处理回调数据">子线程中处理回调数据</h4><ul>
<li><p>有时候我们想要让接收到的数据放在子线程中处理,比如写文件操作.这个时候可以通过NSURLConnection的<code>- (void)setDelegateQueue:(nullable NSOperationQueue*) queue</code></p>
</li>
<li><p>处理NSURLConnection的<code>+ (nullable NSURLConnection*)connectionWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate</code>放在子线程中并不会执行的问题.</p>
<blockquote>
<p>NSURLConnection跟RunLoop有关系,一旦请求发出去,一直等待服务器请求回来,一点一点接收数据,有一个运行循环等待数据,它是在RunLoop中接收返回数据的.NSURLConnection内部会关联当前线程对应的RunLoop,不断给当前线程的RunLoop发送消息,RunLoop一旦接收到Source,紧接着会去处理.<br>子线程为什么会不好使呢?<br>因为子线程的RunLoop默认是不启动的<br>解决办法就是在子线程中手动启动RunLoop,也需要手动去停止</p>
</blockquote>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSURLConnection</span> *conn = [<span class="built_in">NSURLConnection</span> connectionWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxxx/resources/images/minion_01.png"</span>]] delegate:<span class="keyword">self</span>];</span><br><span class="line">        <span class="comment">// 决定代理方法在哪个队列中执行</span></span><br><span class="line">        [conn setDelegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动子线程的runLoop</span></span><br><span class="line">        <span class="comment">//[[NSRunLoop currentRunLoop] run];</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span><span class="variable">.runLoop</span> = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动runLoop</span></span><br><span class="line">        <span class="built_in">CFRunLoopRun</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLConnectionDataDelegate&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveResponse----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didReceiveData----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"connectionDidFinishLoading----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 停止RunLoop</span></span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="keyword">self</span><span class="variable">.runLoop</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NSString和NSData的互相转换">NSString和NSData的互相转换</h4><ul>
<li><p>NSString -&gt; NSData<br><code>NSData *data = [@&quot;&quot; dataUsingEncoding:NSUTF8StringEncoding]</code></p>
</li>
<li><p>NSData -&gt; NSString<br><code>NSString *str = [[NSString alloc] initWithData:dataEncoding:NSUTF8StringEncoding];</code></p>
</li>
</ul>
<h4 id="NSURLSession">NSURLSession</h4><ul>
<li>使用步骤<ul>
<li>使用NSURLSession对象创建Task,然后执行Task</li>
<li>Task的类型:NSURLSessionTask、NSURLSessionDataTask、NSURLSessionDownloadTask、NSURLSessionUploadTask</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)download</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得下载任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDownloadTask</span> *task = [session downloadTaskWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/resources/videos/minion_01.mp4"</span>] completionHandler:^(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="comment">// 文件将来存放的真实路径</span></span><br><span class="line">        <span class="built_in">NSString</span> *file = [[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:response<span class="variable">.suggestedFilename</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 剪切location的临时文件到真实路径</span></span><br><span class="line">        <span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">        [mgr moveItemAtURL:location toURL:[<span class="built_in">NSURL</span> fileURLWithPath:file] error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)post</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建请求</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/login"</span>]];</span><br><span class="line">    request<span class="variable">.HTTPMethod</span> = <span class="string">@"POST"</span>; <span class="comment">// 请求方法</span></span><br><span class="line">    request<span class="variable">.HTTPBody</span> = [<span class="string">@"xxx"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]; <span class="comment">// 请求体</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)get</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/login?username=xxx&amp;pwd=xxx"</span>]] completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//NSURLSessionDataTask *task = [session dataTaskWithURL:[NSURL URLWithString:@"http://xxx/login?username=xxx&amp;pwd=xxx"] completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NSURLSession代理方法">NSURLSession代理方法</h4><ul>
<li>NSURLSession的NSURLSessionDataDelegate代理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSURLSessionDataDelegate</span>, <span class="title">NSURLConnectionDataDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/login?username=xxx&amp;pwd=xxx"</span>]]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLSessionDataDelegate&gt;</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 1.接收到服务器的响应</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span>))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许处理服务器的响应,才会继续接收服务器返回的数据</span></span><br><span class="line">    completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// void (^)(NSURLSessionResponseDisposition)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 2.接收到服务器的数据（可能会被调用多次）</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 3.请求成功或者失败（如果失败,error有值）</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="大文件下载">大文件下载</h4><ul>
<li>NSURLSessionDownloadDelegate代理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSURLSessionDownloadDelegate</span>&gt;</span></span><br><span class="line"><span class="comment">/** 下载任务 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDownloadTask</span> *task;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 开始下载</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)start:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="comment">// 获得NSURLSession对象</span></span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得下载任务</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.task</span> = [session downloadTaskWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/resources/videos/minion_01.mp4"</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.task</span> resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 暂停下载</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)pause:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.task</span> suspend];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 继续下载</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)goOn:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.task</span> resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;NSURLSessionDownloadDelegate&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didCompleteWithError"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didResumeAtOffset"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 每当写入数据到临时文件时,就会调用一次这个方法</span><br><span class="line"> * totalBytesExpectedToWrite:总大小</span><br><span class="line"> * totalBytesWritten: 已经写入的大小</span><br><span class="line"> * bytesWritten: 这次写入多少</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------%f"</span>, <span class="number">1.0</span> * totalBytesWritten / totalBytesExpectedToWrite);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * </span><br><span class="line"> * 下载完毕就会调用一次这个方法</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 文件将来存放的真实路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *file = [[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:downloadTask<span class="variable">.response</span><span class="variable">.suggestedFilename</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 剪切location的临时文件到真实路径</span></span><br><span class="line">    <span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    [mgr moveItemAtURL:location toURL:[<span class="built_in">NSURL</span> fileURLWithPath:file] error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="NSURLSessionTask">NSURLSessionTask</h4><ul>
<li>常见方法<ul>
<li><code>- (void)suspend;</code></li>
<li><code>- (void)resume;</code></li>
<li><code>- (void)cancel;</code></li>
<li><code>@property (nullable, readonly, copy) NSError *error;</code></li>
<li><code>@property (nullable, readonly, copy) NSURLResponse *response;</code></li>
</ul>
</li>
</ul>
<h4 id="文件上传">文件上传</h4><p><code>- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData completionHandler:(void (^)(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error))completionHandler;</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#define MCBoundary @<span class="title">"520it"</span></span></span><br><span class="line"><span class="preprocessor">#define MCEncode(string) [string dataUsingEncoding:NSUTF8StringEncoding]</span></span><br><span class="line"><span class="preprocessor">#define MCNewLine [@<span class="title">"\r\n"</span> dataUsingEncoding:NSUTF8StringEncoding]</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () </span></span><br><span class="line"><span class="comment">/** session */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> *session;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_session) &#123;</span><br><span class="line">        <span class="built_in">NSURLSessionConfiguration</span> *cfg = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">        cfg<span class="variable">.timeoutIntervalForRequest</span> = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 是否允许使用蜂窝网络（手机自带网络）</span></span><br><span class="line">        cfg<span class="variable">.allowsCellularAccess</span> = <span class="literal">YES</span>;</span><br><span class="line">        _session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:cfg];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://xxx/upload"</span>]];</span><br><span class="line">    request<span class="variable">.HTTPMethod</span> = <span class="string">@"POST"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求头(告诉服务器,这是一个文件上传的请求)</span></span><br><span class="line">    [request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"multipart/form-data; boundary=%@"</span>, MCBoundary] forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求体</span></span><br><span class="line">    <span class="built_in">NSMutableData</span> *body = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件参数</span></span><br><span class="line">    <span class="comment">// 分割线</span></span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCEncode(MCBoundary)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件参数名</span></span><br><span class="line">    [body appendData:MCEncode([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Content-Disposition: form-data; name=\"file\"; filename=\"test.png\""</span>])];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件的类型</span></span><br><span class="line">    [body appendData:MCEncode([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Content-Type: image/png"</span>])];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件数据</span></span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    [body appendData:[<span class="built_in">NSData</span> dataWithContentsOfFile:<span class="string">@"/Users/weifeng/Desktop/test.png"</span>]];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束标记</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     --分割线--\r\n</span><br><span class="line">     */</span></span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCEncode(MCBoundary)];</span><br><span class="line">    [body appendData:MCEncode(<span class="string">@"--"</span>)];</span><br><span class="line">    [body appendData:MCNewLine];</span><br><span class="line">    </span><br><span class="line">    [[<span class="keyword">self</span><span class="variable">.session</span> uploadTaskWithRequest:request fromData:body completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"-------%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">    &#125;] resume];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="NSURLConnection">NSURLConnection</h3><h4 id="常用类">常用类</h4><ul>
<li><p>NSURL:请求地址</p>
</li>
<li><p>NSURLRequest:一个NSURLRequest对象就代表一个请求,它包含的信息有</p>
<ul>
<li>一个NSURL对象</li>
<li>请求方法、请求头、请求体</li>
<li>请求超时</li>
<li>…</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[RunLoop的基本使用]]></title>
    <link href="http://yoursite.com/2016/03/25/nsrunloop/"/>
    <id>http://yoursite.com/2016/03/25/nsrunloop/</id>
    <published>2016-03-25T07:52:46.000Z</published>
    <updated>2016-04-03T10:13:28.000Z</updated>
    <content type="html"><![CDATA[<h3 id="什么是RunLoop">什么是RunLoop</h3><ul>
<li>从字面意思看<ul>
<li>运行循环</li>
<li>跑圈</li>
</ul>
</li>
<li>基本作用<ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件(比如触摸事件、定时器事件、Selector事件)</li>
<li>节省CPU资源,提高程序性能:该做事情时做事情,该休息时休息</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h4 id="main函数中的RunLoop">main函数中的RunLoop</h4><ul>
<li>UIApplicationMain函数内部就启动了一个RunLoop</li>
<li>所以UIApplicationMain函数一直没有返回,保持程序的持续运行</li>
<li>这个默认启动的RunLoop是跟主线程相关联的</li>
</ul>
<h4 id="RunLoop对象">RunLoop对象</h4><ul>
<li><p>iOS中有2套API来访问和使用RunLoop</p>
<ul>
<li>Foundation <ul>
<li>NSRunLoop</li>
</ul>
</li>
<li>Core Foundation <ul>
<li>CFRunLoopRef</li>
</ul>
</li>
</ul>
</li>
<li><p>NSRunLoop和CFRunLoopRef都代表着RunLoop对象</p>
</li>
<li><p>NSRunLoop是基于CFRunLoopRef的一层OC包装,所以要了解RunLoop内部结构,需要多研究CFRunLoopRef层面的API</p>
</li>
</ul>
<h4 id="RunLoop与线程">RunLoop与线程</h4><ul>
<li><p>每条线程都有唯一的一个与之对应的RunLoop对象</p>
</li>
<li><p>主线程的RunLoop已经创建好了,子线程的RunLoop需要主动创建</p>
</li>
<li><p>RunLoop在第一次获取的时候创建,在线程结束的时候销毁</p>
</li>
</ul>
<h4 id="获取RunLoop">获取RunLoop</h4><ul>
<li>获取当前线程的RunLoop:<code>+ (NSRunLoop *)currentRunLoop;</code></li>
<li>获取主线程的RunLoop:<code>+ (NSRunLoop *)mainRunLoop;</code></li>
<li>获取当前线程的RunLoop:<code>CFRunLoopGetCurrent();</code></li>
<li>获取主线程的RunLoop:<code>CFRunLoopGetMain();</code></li>
</ul>
<h4 id="RunLoop相关类">RunLoop相关类</h4><ul>
<li>Core Foundation中关于RunLoop的5个类<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
</li>
</ul>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/runloop.png" alt=""></p>
<h4 id="CFRunLoopModeRef">CFRunLoopModeRef</h4><ul>
<li><p>CFRunLoopModeRef代表RunLoop的运行模式</p>
</li>
<li><p>一个RunLoop包含若干个Mode,每个Mode又包含若干个Source/Timer/Observer</p>
</li>
<li><p>每次RunLoop启动时,只能指定其中一个Mode,这个Mode被称作CurrentMode<br><code>[[NSRunLoop currentRunLoop] currentMode];</code></p>
</li>
<li><p>如果需要切换Mode,只能退出Loop,再重新指定一个Mode进入</p>
</li>
<li><p>这样做主要是为了分隔开不同组Source/Timer/Observer,让其互不影响</p>
</li>
<li><p>系统默认注册了5个Mode:</p>
<ul>
<li>kCFRunLoopDefaultMode:App的默认Mode,通常主线程是这个Mode下运行</li>
<li>UITrackingRunLoop:界面跟踪Mode,用于ScrollView追踪触摸滑动,保证界面滑动时不受其他Mode影响</li>
<li>UIInitializationRunLoopMode:在刚启动App时进入的第一个Mode,启动完成后就不再使用</li>
<li>GSEventReceiverRunLoopMode:接收系统事件的内部Mode,通常用不到</li>
<li>kCFRunLoopCommonModes:这是一个占位用的Mode,不是一种真正的Mode(等价于kCFRunLoopDefaultMode + UITrackingRunLoop这2种模式)</li>
</ul>
</li>
<li><p>子线程中需要手动创建并启动NSRunLoop</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">NSRunLoop</span> mainRunLoop];</span><br><span class="line">    [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">    <span class="built_in">CFRunLoopGetMain</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line">	[thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">		<span class="comment">// add Source</span></span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[<span class="built_in">NSPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">		<span class="comment">//add Timer</span></span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这句相当于下面那句,如果RunLoop中没有Source、Timer、Observer那么这个RunLoop会自动结束并退出</span></span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">	    </span><br><span class="line">	    [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:&lt;<span class="preprocessor">#(NSString *)#&gt; beforeDate:<span class="title">&lt;#(NSDate *)#&gt;</span>];</span></span><br><span class="line">		[[<span class="built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CFRunLoopTimerRef">CFRunLoopTimerRef</h4><ul>
<li>CFRunLoopTimerRef是基于时间的触发器</li>
<li>CFRunLoopTimerRef基本上说的就是NSTimer,它受RunLoop的Mode影响</li>
<li>GCD的定时器不受RunLoop的Mode影响</li>
<li>基本上说的就是NSTimer</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用了scheduledTimer返回的定时器,已经自动被添加到当前RunLoop中,而且是NSDefaultRunLoopMode模式</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 修改模式</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];等价于下面2句</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">// 定时器只运行在NSDefaultRunLoopMode下,一旦RunLoop进入其他模式,这个定时器就不会工作</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器会跑在标记为common modes的模式下</span></span><br><span class="line"><span class="comment">// 标记为common modes的模式: UITrackingRunLoopMode和kCFRunLoopDefaultMode</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器只运行在UITrackingRunLoopMode下,一旦RunLoop进入其他模式,这个定时器就不会工作</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">UITrackingRunLoopMode</span>];</span><br></pre></td></tr></table></figure>
<h4 id="CFRunLoopSourceRef">CFRunLoopSourceRef</h4><ul>
<li><p>CFRunLoopSourceRef是事件源(输入源)</p>
</li>
<li><p>按照官方文档,Source的分类</p>
<ul>
<li>Port-Based Sources</li>
<li>Custom Input Sources</li>
<li>Cocoa Perform Selector Sources</li>
</ul>
</li>
<li><p>按照函数调用栈,Source的分类</p>
<ul>
<li>Source0:非基于Port</li>
<li>Source1:基于Port的,通过内核和其他线程通信,接收、分发系统事件</li>
</ul>
</li>
</ul>
<h4 id="CFRunLoopObserverRef">CFRunLoopObserverRef</h4><ul>
<li><p>CFRunLoopObserverRef是观察者,能够监听RunLoop的状态改变</p>
</li>
<li><p>可以监听的时间点有以下几个</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    k<span class="built_in">CFRunLoopEntry</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">//1 即将进入Loop </span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeTimers</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">//2 即将处理Timer </span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeSources</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">//4 即将处理Source </span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeWaiting</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">//32 即将进入休眠</span></span><br><span class="line">    k<span class="built_in">CFRunLoopAfterWaiting</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">//64 刚从休眠中唤醒</span></span><br><span class="line">    k<span class="built_in">CFRunLoopExit</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">//128 即将退出Loop</span></span><br><span class="line">    k<span class="built_in">CFRunLoopAllActivities</span> = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建observer</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), k<span class="built_in">CFRunLoopAllActivities</span>, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----监听到RunLoop状态发生改变---%zd"</span>, activity);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者:监听RunLoop的状态</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, k<span class="built_in">CFRunLoopDefaultMode</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    CF的内存管理（Core Foundation）</span><br><span class="line">    1.凡是带有Create、Copy、Retain等字眼的函数,创建出来的对象,都需要在最后做一次release</span><br><span class="line">    * 比如CFRunLoopObserverCreate</span><br><span class="line">    2.release函数:CFRelease(对象);</span><br><span class="line"> 	*/</span></span><br><span class="line">    <span class="comment">// 释放Observer</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/runloop_1.png" alt=""></p>
<h4 id="RunLoop应用">RunLoop应用</h4><ul>
<li>NSTimer</li>
<li>ImageView显示</li>
<li>PerformSelector</li>
<li>常驻线程</li>
<li>自动释放池</li>
</ul>
<h4 id="RunLoop面试题">RunLoop面试题</h4><ul>
<li>什么是RunLoop?<ul>
<li>从字面意思看:运行循环、跑圈</li>
<li>其实它内部就是do-while循环,在这个循环内部不断地处理各种任务(比如Source、Timer、Observer)</li>
<li>一个线程对应一个RunLoop,主线程的RunLoop默认已经启动,子线程的RunLoop得手动启动(调用Run方法)</li>
<li>RunLoop只能选择一个Mode启动,如果当前Mode中没有任何Source(Sources0、Sources1)、Timer,那么久直接退出RunLoop</li>
</ul>
</li>
</ul>
<ul>
<li>你在开发过程中怎么使用RunLoop?什么应用场景?<ul>
<li>开启一个常驻线程(让一个子线程不进入消亡状态,等待其他线程发来消息,处理其他事件)<ul>
<li>在子线程中开启一个定时器</li>
<li>在子线程中进行一些长期监控一些行为</li>
</ul>
</li>
<li>可以控制定时器在特定模式下执行</li>
<li>可以让某些事件(行为、任务)在特定模式下执行</li>
<li>可以添加Observer监听RunLoop的状态,比如监听点击事件的处理(在所有点击事件之前做一些事情)</li>
</ul>
</li>
</ul>
<ul>
<li>自动释放池什么时候释放?<ul>
<li>通过Observer监听RunLoop的状态,一旦监听到RunLoop即将进入睡眠等待状态,就释放自动释放池(kCFRunLoopBeforeWaiting)</li>
<li>监听了3个地方activity = 0x1(kCFRunLoopEntry) 、 0xa0(kCFRunLoopBeforeWaiting | kCFRunLoopExit ) -&gt;(kCFRunLoopEntry创建一个自动释放池、kCFRunLoopBeforeWaiting销毁自动释放池,创建一个新的自动释放池、kCFRunLoopExit 销毁自动释放池)</li>
</ul>
</li>
</ul>
<h4 id="GCD定时器">GCD定时器</h4><ul>
<li><p>创建GCD定时器 <code>dispatch_source_t dispatch_source_create(dispatch_source_type_t type,uintptr_t handle,unsigned long mask,dispatch_queue_t queue);</code></p>
</li>
<li><p>设置定时器的各种属性 <code>dispatch_source_set_timer(dispatch_source_t source,dispatch_time_t start,uint64_t interval,uint64_t leeway);</code></p>
</li>
<li><p>设置定时器处理任务 <code>dispatch_source_set_event_handler(dispatch_source_t source,dispatch_block_t handler);</code></p>
</li>
<li><p>启动定时器 <code>dispatch_resume(dispatch_object_t object);</code></p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="comment">/** 定时器(这里不用带*,因为dispatch_source_t就是个类,内部已经包含了*) */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    dispatch_time_t when = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">    </span><br><span class="line">    dispatch_after(when, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得队列</span></span><br><span class="line">	<span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//dispatch_queue_t queue = dispatch_get_main_queue();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个定时器(dispatch_source_t本质还是个OC对象)</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.timer</span> = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置定时器的各种属性(何时开始任务,每隔多长时间执行一次)</span></span><br><span class="line">    <span class="comment">// GCD的时间参数,一般是纳秒（1秒 == 10的9次方纳秒）</span></span><br><span class="line">    <span class="comment">// 何时开始执行第一个任务</span></span><br><span class="line">    <span class="comment">// dispatch_time(DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC) 比当前时间晚3秒</span></span><br><span class="line">    dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">    uint64_t interval = (uint64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    dispatch_source_set_timer(<span class="keyword">self</span><span class="variable">.timer</span>, start, interval, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置回调</span></span><br><span class="line">    dispatch_source_set_event_handler(<span class="keyword">self</span><span class="variable">.timer</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"------------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        count++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">// 取消定时器</span></span><br><span class="line">            dispatch_cancel(<span class="keyword">self</span><span class="variable">.timer</span>);</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.timer</span> = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动定时器</span></span><br><span class="line">    dispatch_resume(<span class="keyword">self</span><span class="variable">.timer</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="什么是RunLoop">什么是RunLoop</h3><ul>
<li>从字面意思看<ul>
<li>运行循环</li>
<li>跑圈</li>
</ul>
</li>
<li>基本作用<ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件(比如触摸事件、定时器事件、Selector事件)</li>
<li>节省CPU资源,提高程序性能:该做事情时做事情,该休息时休息</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS单例模式]]></title>
    <link href="http://yoursite.com/2016/03/25/single_instance/"/>
    <id>http://yoursite.com/2016/03/25/single_instance/</id>
    <published>2016-03-25T02:32:46.000Z</published>
    <updated>2016-04-21T12:57:07.000Z</updated>
    <content type="html"><![CDATA[<h3 id="单例模式">单例模式</h3><ul>
<li>单例模式的作用<ul>
<li>可以保证在程序运行过程,一个类只有一个实例,而且该实例易于供外界访问</li>
<li>从而方便地控制了实例个数,并节约系统资源</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li>ARC中,单例模式的实现步骤<ul>
<li>在.m中保留一个全局的static的实例<code>static id _instance;</code></li>
<li><code>+ (instancetype)alloc</code>内部会调用<code>+ (instancetype)allocWithZone:(struct _NSZone *)zone</code></li>
<li>为了防止分配多个内存,我们需要重写NSObject的<code>+ (instancetype)allocWithZone:(struct _NSZone *)zone</code>,但是我们防止不了init多次,在这里创建唯一的实例(注意需要是线程安全的)</li>
<li>使用GCD的<code>static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^{});</code>来创建唯一的实例.</li>
<li>对外提供一个<code>+ (instancetype)sharedInstance</code>类方法来构造一个对象,这个方法中同样使用dispatch_once</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCPerson</span>() &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> MCPerson *_person;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _person = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedPerson</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _person = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将单例的实现抽成宏<ul>
<li>创建一个MCSingleton.h文件,将头文件和实现文件中的方法定义成宏</li>
<li>在使用的地方导入MCSingleton.h文件,头文件中使用MCSingletonH(Person),实现文件中使用MCSingletonM(Person)</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h文件</span></span><br><span class="line"><span class="preprocessor">#define SingletonH(name) + (instancetype)shared##name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m文件</span></span><br><span class="line"><span class="preprocessor">#define SingletonM(name) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance; \</span><br><span class="line"> \</span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone \</span><br><span class="line">&#123; \</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">        _instance = [<span class="keyword">super</span> allocWithZone:zone]; \</span><br><span class="line">    &#125;); \</span><br><span class="line">    <span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line"> \</span><br><span class="line">+ (instancetype)shared<span class="preprocessor">##name \</span></span><br><span class="line">&#123; \</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">        _instance = [[<span class="keyword">self</span> alloc] init]; \</span><br><span class="line">    &#125;); \</span><br><span class="line">    <span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line"> \</span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone \</span><br><span class="line">&#123; \</span><br><span class="line">    <span class="keyword">return</span> _instance; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>传统方式实现单例<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCPerson</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCPerson</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">nil</span>) &#123;</span><br><span class="line">            _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">nil</span>) &#123;</span><br><span class="line">            _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="单例模式">单例模式</h3><ul>
<li>单例模式的作用<ul>
<li>可以保证在程序运行过程,一个类只有一个实例,而且该实例易于供外界访问</li>
<li>从而方便地控制了实例个数,并节约系统资源</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS中的线程]]></title>
    <link href="http://yoursite.com/2016/03/24/gcd/"/>
    <id>http://yoursite.com/2016/03/24/gcd/</id>
    <published>2016-03-24T06:37:39.000Z</published>
    <updated>2016-03-28T13:28:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="多线程的基本概念">多线程的基本概念</h3><ul>
<li>创建线程是有开销的,iOS下主要成本包括:内核数据结构（大约1KB）、栈空间(子线程512KB、主线程1MB,也可以使用-setStackSize:设置,但必须是4K的倍数,而且最小是16K),创建线程大约需要90毫秒的创建时间</li>
</ul>
<h3 id="多线程的实现方案">多线程的实现方案</h3><a id="more"></a>
<p><img src="http://7xk9ih.com1.z0.glb.clouddn.com/thread.png" alt=""></p>
<h3 id="pthread的使用">pthread的使用</h3><p><code>int pthread_create(pthread_t * __restrict, const pthread_attr_t * __restrict,
        void *(*)(void *), void * __restrict);</code><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> * run(<span class="keyword">void</span> *param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">50000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"------buttonClick---%zd--%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)buttonClick:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    pthread_t thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_t thread2;</span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="NSThread的使用">NSThread的使用</h3><ul>
<li>如何创建并管理NSThread</li>
</ul>
<p><code>+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;// 直接创建并启动</code></p>
<p><code>- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0);//创建线程但是没有启动</code></p>
<p><code>+ (NSThread *)currentThread;</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) object:<span class="string">@"jack"</span>];</span><br><span class="line"><span class="comment">// 线程名字</span></span><br><span class="line">thread<span class="variable">.name</span> = <span class="string">@"mc"</span>;</span><br><span class="line"><span class="comment">// thread 是否是主线程</span></span><br><span class="line">[thread isMainThread];</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">[thread start];</span><br><span class="line"><span class="comment">// 取消线程</span></span><br><span class="line">[thread cancel];</span><br><span class="line"><span class="comment">//线程是否正在执行</span></span><br><span class="line">[thread executing];</span><br><span class="line"><span class="comment">//线程是否完成</span></span><br><span class="line">[thread finished];</span><br><span class="line"><span class="comment">//线程是否被取消</span></span><br><span class="line">[thread cancelled];</span><br><span class="line"><span class="comment">// 方法是否在主线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> isMainThread];</span><br><span class="line"><span class="comment">// 直接退出线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> exit]; </span><br><span class="line"><span class="comment">// 让线程睡眠2秒（阻塞2秒）</span></span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">[<span class="built_in">NSThread</span> sleepUntilDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br></pre></td></tr></table></figure>
<ul>
<li><p>NSObject 线程分类</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">NSThreadPerformAdditions</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(nullable <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line">    <span class="comment">// equivalent to the first method with kCFRunLoopCommonModes</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(nullable <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(nullable <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(nullable <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line">    <span class="comment">// equivalent to the first method with kCFRunLoopCommonModes</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(nullable <span class="keyword">id</span>)arg <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取2个时间间隔</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDate</span> *begin = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSDate</span> *end = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, [end timeIntervalSinceDate:begin]);</span><br><span class="line"><span class="built_in">CFTimeInterval</span> begin = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"><span class="built_in">CFTimeInterval</span> end = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, end - begin);</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程安全</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saleTicket&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">@synchronized</span>(<span class="keyword">self</span>)&#123;</span><br><span class="line">            <span class="comment">// 先取出总数</span></span><br><span class="line">            <span class="built_in">NSInteger</span> count = <span class="keyword">self</span><span class="variable">.ticketCount</span>;</span><br><span class="line">             <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">self</span><span class="variable">.ticketCount</span> = count - <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@卖了一张票，还剩下%zd张"</span>, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>, <span class="keyword">self</span><span class="variable">.ticketCount</span>);</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"票已经卖完了"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="GCD">GCD</h3><ul>
<li>全称是Grand Central Dispatch,可译为”牛逼的中枢调度器”</li>
<li>GCD中有2个核心概念:任务-执行什么操作,队列-用来存放任务</li>
<li>GCD的使用就2个步骤<ul>
<li>定制任务(确定想做的事情)</li>
<li>将任务添加到队列中(GCD会自动将队列中的任务取出,放到对应的线程中执行,任务的取出遵循队列的FIFO)</li>
</ul>
</li>
</ul>
<h4 id="执行任务">执行任务</h4><ul>
<li>GCD中有2个用来执行任务的常用函数<ul>
<li>同步的方式执行任务(只能在当前线程中执行任务,不具备开启新线程的能力)<br><code>dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code></li>
<li>异步的方式执行任务(可以在新的线程中执行任务,具备开启新线程的能力)<br><code>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code></li>
<li><code>dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</code>在前面的任务执行结束后它才执行,而且它后面的任务等它执行完成之后才会执行,这个queue不能是全局的并发队列</li>
</ul>
</li>
</ul>
<h4 id="队列的类型">队列的类型</h4><ul>
<li>并发队列<ul>
<li>可以让多个任务并发(同时)执行(自动开启多个线程同时执行任务)</li>
<li>并发功能只有在异步(dispatch_async)函数下才有效</li>
</ul>
</li>
<li>串行队列<ul>
<li>让任务一个接着一个执行</li>
</ul>
</li>
</ul>
<h4 id="并发队列">并发队列</h4><ul>
<li>使用dispatch_queue_create函数创建队列</li>
<li>GCD默认已经提供全局的并发队列,供整个程序使用,可以无需手动创建<ul>
<li>使用dispatch_get_global_queue函数获取全局的并发队列<br><code>dispatch_queue_t
dispatch_get_global_queue(long identifier, unsigned long flags);//identifier队列的优先级  flags此参数无用,用0即可</code></li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 异步函数 + 并发队列:可以同时开启多条线程</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncConcurrent</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建一个并发队列</span></span><br><span class="line"><span class="comment">// label:队列名字</span></span><br><span class="line"><span class="comment">// attr:队列类型-DISPATCH_QUEUE_SERIAL  DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t attr);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span><br><span class="line"><span class="preprocessor">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span><br><span class="line"><span class="preprocessor">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span><br><span class="line"><span class="preprocessor">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br><span class="line"><span class="comment">// 获得全局的并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将任务加入队列</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 同步函数 + 并发队列:不会开启新的线程</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncConcurrent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.获得全局的并发队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 异步函数 + 串行队列:会开启新的线程,但是任务是串行的,执行完一个任务,再执行下一个任务</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncSerial</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建串行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mc.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 同步函数 + 串行队列:不会开启新的线程,在当前线程执行任务。任务是串行的,执行完一个任务,再执行下一个任务</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncSerial</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建串行队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mc.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 异步函数 + 主队列:只在主线程中执行任务</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncMain</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.获得主队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 同步函数 + 主队列:导致等待阻塞</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncMain</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 1.获得主队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.将任务加入队列</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>线程间通信<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="GCD的其它常用函数">GCD的其它常用函数</h4><ul>
<li><code>dispatch_barrier_async</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)barrier</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"mc"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----1-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----2-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----barrier-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----3-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----4-----%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>一次性代码,使用dispatch_once函数能保证某代码在程序运行过程中只被执行1次</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">//只执行1次的代码(这里是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>延迟执行</p>
<ul>
<li><code>- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</code></li>
<li><code>dispatch_after(dispatch_time_t when,dispatch_queue_t queue,dispatch_block_t block);</code></li>
<li><code>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</code></li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 延迟执行</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)delay</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(run) withObject:<span class="literal">nil</span> afterDelay:<span class="number">2.0</span>];</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"run-----"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>快速迭代: <code>dispatch_apply(size_t iterations, dispatch_queue_t queue,void (^block)(size_t));</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 快速迭代</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)apply</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *from = <span class="string">@"/Users/weifeng/Desktop/From"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *to = <span class="string">@"/Users/weifeng/Desktop/To"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSArray</span> *subpaths = [mgr subpathsAtPath:from];</span><br><span class="line">    </span><br><span class="line">    dispatch_apply(subpaths<span class="variable">.count</span>, queue, ^(size_t index) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *subpath = subpaths[index];</span><br><span class="line">        <span class="built_in">NSString</span> *fromFullpath = [from stringByAppendingPathComponent:subpath];</span><br><span class="line">        <span class="built_in">NSString</span> *toFullpath = [to stringByAppendingPathComponent:subpath];</span><br><span class="line">        <span class="comment">// 剪切</span></span><br><span class="line">        [mgr moveItemAtPath:fromFullpath toPath:toFullpath error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@---%@"</span>, [<span class="built_in">NSThread</span> currentThread], subpath);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列组">队列组</h4><ul>
<li><code>dispatch_group_async(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block);</code><br><code>dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block);</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)group</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建一个队列组</span></span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.下载图片1</span></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.image1</span> = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.下载图片2</span></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://pic38.nipic.com/20140228/5571398_215900721128_2.jpg"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.image2</span> = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.将图片1、图片2合成一张新的图片</span></span><br><span class="line">    dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">        <span class="comment">// 开启新的图形上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制图片</span></span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.image1</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)];</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.image2</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取得上下文中的图片</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结束上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程显示图片</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="comment">// 4.将新图片显示出来 </span></span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NSOperation">NSOperation</h4><ul>
<li><p>NSOperation的作用</p>
<ul>
<li>配合使用NSOperation和NSOperationQueue也能实现多线程编程</li>
</ul>
</li>
<li><p>NSOperation和NSOperationQueue实现多线程的具体步骤</p>
<ul>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperationQueue中NSOperation取出来</li>
<li>将取出的NSOperation封装的操作放到一条新线程中执行</li>
</ul>
</li>
</ul>
<h4 id="NSOperation的子类">NSOperation的子类</h4><ul>
<li><p>NSOperation是个抽象类,并不具备封装操作的能力,必须使用它的子类</p>
</li>
<li><p>使用NSOperation子类的方式有3种</p>
<ul>
<li>NSInvocationOperation</li>
<li>NSBlockOperation</li>
<li>自定义子类继承NSOperation,实现内部相应的方法</li>
</ul>
</li>
<li><p>将任务包装起来调用NSOperation start就可以执行任务了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invocationOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)blockOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="comment">// 在主线程</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载1------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加额外的任务(在子线程执行)</span></span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载2------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载3------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载4------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [op start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="NSOperationQueue">NSOperationQueue</h4><ul>
<li>NSOperationQueue的作用<ul>
<li>NSOperation可以调用start方法执行任务,但默认是同步执行的</li>
<li>如果将NSOperation添加到NSOperationQueue(操作队列)中,系统会自动异步执行NSOperation中的操作</li>
</ul>
</li>
</ul>
<h5 id="GCD的队列类型">GCD的队列类型</h5><ul>
<li>并发队列<ul>
<li>自己创建的</li>
<li>全局的</li>
</ul>
</li>
<li>串行队列<ul>
<li>主队列</li>
<li>自己创建的</li>
</ul>
</li>
</ul>
<h5 id="NSOperationQueue的队列类型">NSOperationQueue的队列类型</h5><ul>
<li><p>主队列</p>
<ul>
<li>[NSOperationQueue mainQueue]</li>
<li>凡是添加到主队列中的任务(NSOperation),都会放到主队列中执行</li>
</ul>
</li>
<li><p>非主队列(其它队列)</p>
<ul>
<li>[[NSOperationQueue alloc] init]</li>
<li>同时包含了:串行、并发功能</li>
<li>添加到这种队列中的任务(NSOperation),就会自动放到子线程中执行</li>
</ul>
</li>
<li><p>NSOperationQueue<br><code>- (void)addOperation:(NSOperation *)op;</code><br><code>- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait;</code><br><code>- (void)addOperationWithBlock:(void (^)(void))block;</code><br><code>@property (readonly) NSUInteger operationCount;//任务数量</code><br><code>@property NSInteger maxConcurrentOperationCount;//最大的并发数量,如果设置为1则是串行,为0则不执行任何任务</code><br><code>@property (getter=isSuspended) BOOL suspended;//获取或者设置是否挂起任务</code><br><code>@property (nullable, copy) NSString *name;//获取或者设置队列名字</code><br><code>- (void)cancelAllOperations;//取消所有任务,但是正在执行的不会被取消</code><br><code>- (void)waitUntilAllOperationsAreFinished;</code><br><code>+ (nullable NSOperationQueue *)currentQueue;当前队列</code><br><code>+ (NSOperationQueue *)mainQueue;//主队列</code></p>
</li>
</ul>
<ul>
<li><p>NSInvocationOperation<br><code>- (nullable instancetype)initWithTarget:(id)target selector:(SEL)sel object:(nullable id)arg;</code><br><code>- (instancetype)initWithInvocation:(NSInvocation *)inv</code></p>
</li>
<li><p>NSBlockOperation<br><code>+ (instancetype)blockOperationWithBlock:(void (^)(void))block;</code><br><code>- (void)addExecutionBlock:(void (^)(void))block;</code><br><code>@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks;</code></p>
</li>
<li><p>NSOperation<br><code>- (void)start;//执行任务</code><br><code>- (void)main;//自定义NSOperation需要重写该方法,将任务需要做的事情写到这个方法当中,官方建议在这个方法当中如果有耗时的操作使用isCancelled判断下是否需结束该任务</code><br><code>- (void)cancel;//取消任务</code><br><code>@property (readonly, getter=isExecuting) BOOL executing;</code><br><code>@property (readonly, getter=isFinished) BOOL finished;</code><br><code>- (void)addDependency:(NSOperation *)op;//添加任务依赖</code><br><code>- (void)removeDependency:(NSOperation *)op;//移除任务依赖</code><br><code>@property (nullable, copy) void (^completionBlock)(void);//监听任务的完成会执行这个block</code></p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)operationQueueTest&#123;</span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置最大并发操作数</span></span><br><span class="line">    <span class="comment">// queue.maxConcurrentOperationCount = 2;</span></span><br><span class="line">    queue<span class="variable">.maxConcurrentOperationCount</span> = <span class="number">1</span>; <span class="comment">// 就变成了串行队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建操作(任务)</span></span><br><span class="line">    <span class="comment">// 创建NSInvocationOperation</span></span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(download) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建NSBlockOperation</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download1 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [op1 addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download2 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加操作到队列中</span></span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download3 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加任务到队列中</span></span><br><span class="line">    [queue addOperation:op1]; <span class="comment">// [op1 start]</span></span><br><span class="line">    [queue addOperation:op2]; <span class="comment">// [op2 start]</span></span><br><span class="line">    [queue addOperation:[[MCOperation alloc] init]];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.queue</span><span class="variable">.isSuspended</span>) &#123;</span><br><span class="line">        <span class="comment">// 恢复队列，继续执行</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.queue</span><span class="variable">.suspended</span> = <span class="literal">NO</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 暂停（挂起）队列，暂停执行</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.queue</span><span class="variable">.suspended</span> = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.queue</span> cancelAllOperations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCOperation</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 需要执行的任务</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download1 -%zd-- %@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download2 -%zd-- %@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download3 -%zd-- %@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)operationDependency</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不能相互依赖</span></span><br><span class="line">    <span class="comment">// 可以在不同queue的NSOperation之间创建依赖关系</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download1----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download2----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download3----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op4 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"download4----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op5 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download5----%@"</span>, [<span class="built_in">NSThread</span>  currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 监听op5任务执行完毕会调用这个block</span></span><br><span class="line">    op5<span class="variable">.completionBlock</span> = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"op5执行完毕---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置依赖</span></span><br><span class="line">    [op3 addDependency:op1];</span><br><span class="line">    [op3 addDependency:op2];</span><br><span class="line">    [op3 addDependency:op4];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];</span><br><span class="line">    [queue addOperation:op4];</span><br><span class="line">    [queue addOperation:op5];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="线程之间的通讯">线程之间的通讯</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 线程之间的通信</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    [[[<span class="built_in">NSOperationQueue</span> alloc] init] addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">       <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg"</span>];</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 合成图片</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    __block <span class="built_in">UIImage</span> *image1 = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 下载图片1</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *download1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        image1 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    __block <span class="built_in">UIImage</span> *image2 = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 下载图片2</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *download2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 图片的网络路径</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://pic38.nipic.com/20140228/5571398_215900721128_2.jpg"</span>];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成图片</span></span><br><span class="line">        image2 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合成图片</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *combine = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="comment">// 开启新的图形上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制图片</span></span><br><span class="line">        [image1 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)];</span><br><span class="line">        image1 = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        [image2 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>)];</span><br><span class="line">        image2 = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取得上下文中的图片</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结束上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    [combine addDependency:download1];</span><br><span class="line">    [combine addDependency:download2];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:download1];</span><br><span class="line">    [queue addOperation:download2];</span><br><span class="line">    [queue addOperation:combine];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="多线程的基本概念">多线程的基本概念</h3><ul>
<li>创建线程是有开销的,iOS下主要成本包括:内核数据结构（大约1KB）、栈空间(子线程512KB、主线程1MB,也可以使用-setStackSize:设置,但必须是4K的倍数,而且最小是16K),创建线程大约需要90毫秒的创建时间</li>
</ul>
<h3 id="多线程的实现方案">多线程的实现方案</h3>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[const和指针]]></title>
    <link href="http://yoursite.com/2016/03/24/const_point/"/>
    <id>http://yoursite.com/2016/03/24/const_point/</id>
    <published>2016-03-24T05:44:56.000Z</published>
    <updated>2016-03-24T13:37:21.000Z</updated>
    <content type="html"><![CDATA[<h3 id="const和宏的区别">const和宏的区别</h3><ul>
<li><p>相同点:</p>
<ul>
<li>值是常量,不能动态更改 </li>
<li>更改后,其它使用到的地方会自动更改</li>
</ul>
</li>
<li><p>不同点:</p>
<ul>
<li>宏:会产生很多临时空间</li>
<li>const:<ul>
<li>只有一份内存</li>
<li>写在外面是全局常量</li>
<li>不能运行时修改常量值</li>
<li>加上static之后只能在本文件访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="const与指针">const与指针</h3><ul>
<li>看const右边整体是什么,什么就不能修改.<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p2;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 定义一个指针变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">NULL</span>;(等同于 <span class="keyword">int</span> <span class="keyword">const</span> *p = <span class="literal">NULL</span>;)</span><br><span class="line"><span class="comment">// p指向a</span></span><br><span class="line">p = &amp;a;(可以修改)</span><br><span class="line"><span class="comment">//*p = 20;(*p不能改,const后面是*p所以不能改)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;c;(p不能被修改,一开始指向什么,以后都不能更改)</span><br><span class="line">*p = <span class="number">30</span>;(但是可以修改它指向的变量c的值)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值传递比较有用,想让别人不更改你的值可以通过这种方式使用</span></span><br><span class="line"><span class="keyword">void</span> test(<span class="keyword">const</span> <span class="keyword">int</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//*p = 100;(不能修改*p的值)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修饰指针,指针不能更改</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> NAME = <span class="string">@""</span>;</span><br><span class="line"><span class="comment">//不能修改</span></span><br><span class="line"><span class="comment">//NAME = @"123";</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="const和宏的区别">const和宏的区别</h3><ul>
<li><p>相同点:</p>
<ul>
<li>值是常量,不能动态更改 </li>
<li>更改后,其它使用到的地方会自动更改</li>
</ul>
</li>
<li><p>不同点:</p>
<ul>
<li>宏:会产生很多临时空间</li>
<li>const:<ul>
<li>只有一份内存</li>
<li>写在外面是全局常量</li>
<li>不能运行时修改常量值</li>
<li>加上static之后只能在本文件访问</li>
</ul>
</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIScrollView常见功能]]></title>
    <link href="http://yoursite.com/2016/03/24/uiscrollview_common_feature/"/>
    <id>http://yoursite.com/2016/03/24/uiscrollview_common_feature/</id>
    <published>2016-03-24T05:25:49.000Z</published>
    <updated>2016-03-28T13:21:20.000Z</updated>
    <content type="html"><![CDATA[<h3 id="子控件悬停">子控件悬停</h3><ul>
<li>获取UIScrollView垂直方向上的滚动距离来动态调整子控件的frame并将子控件添加到最顶层父控件或者UIScrollView上</li>
</ul>
<h3 id="下拉放大">下拉放大</h3><ul>
<li>获取UIScrollView垂直方向上的滚动距离,计算一个scale值,通过改变控件的形变来实现缩放 </li>
</ul>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">UIScrollViewDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *redView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *blueView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIScrollView</span> *scrollView;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="number">0</span>, <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span><span class="variable">.blueView</span><span class="variable">.frame</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - <span class="title">&lt;UIScrollViewDelegate&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> imageH = <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> offsetY = scrollView<span class="variable">.contentOffset</span><span class="variable">.y</span>;</span><br><span class="line">    <span class="keyword">if</span> (offsetY &gt;= imageH) &#123;</span><br><span class="line">        <span class="comment">// 将红色控件添加到控制器的view中,设置Y值为0</span></span><br><span class="line">        <span class="built_in">CGRect</span> redF = <span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.frame</span>;</span><br><span class="line">        redF<span class="variable">.origin</span><span class="variable">.y</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.frame</span> = redF;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.view</span> addSubview:<span class="keyword">self</span><span class="variable">.redView</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将红色控件添加到scrollView中,设置Y值为图片的高度</span></span><br><span class="line">        <span class="built_in">CGRect</span> redF = <span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.frame</span>;</span><br><span class="line">        redF<span class="variable">.origin</span><span class="variable">.y</span> = <span class="number">140</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.redView</span><span class="variable">.frame</span> = redF;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.scrollView</span> addSubview:<span class="keyword">self</span><span class="variable">.redView</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> scale = <span class="number">1</span> - (offsetY / <span class="number">70</span>);</span><br><span class="line">    scale = (scale &gt;= <span class="number">1</span>) ? scale : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeScale</span>(scale, scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="UIScrollView内部子控件添加约束的注意点">UIScrollView内部子控件添加约束的注意点</h3><ul>
<li><p>子控件的尺寸不能通过UIScrollView来计算,可以考虑通过以下方式计算</p>
<ul>
<li>可以设置固定值（width==100,height==300）</li>
<li>可以相对于UIScrollView以外的其他控件来计算尺寸</li>
</ul>
</li>
<li><p>UIScrollView的frame应该通过子控件以外的其他控件来计算</p>
</li>
<li><p>UIScrollView的contentSize通过子控件来计算</p>
<ul>
<li>根据子控件的尺寸以及子控件与UIScrollView之间的间距</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="子控件悬停">子控件悬停</h3><ul>
<li>获取UIScrollView垂直方向上的滚动距离来动态调整子控件的frame并将子控件添加到最顶层父控件或者UIScrollView上</li>
</ul>
<h3 id="下拉放大">下拉放大</h3><ul>
<li>获取UIScrollView垂直方向上的滚动距离,计算一个scale值,通过改变控件的形变来实现缩放 </li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[网易新闻项目]]></title>
    <link href="http://yoursite.com/2016/03/24/ios_news/"/>
    <id>http://yoursite.com/2016/03/24/ios_news/</id>
    <published>2016-03-24T02:08:49.000Z</published>
    <updated>2016-03-24T13:20:49.000Z</updated>
    <content type="html"><![CDATA[<h3 id="网易新闻项目知识点">网易新闻项目知识点</h3><ul>
<li><p>自定义MCHomeViewController继承自UIViewController</p>
</li>
<li><p>Main.storyboard 添加导航控制器为初始化控制器,添加UIViewController为导航控制器的根控制器并设置其Class类型为MCHomeViewController,为UIViewController添加2个UIScrollView并设置好约束,设置contentScrollView代理为MCHomeViewController</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>自定义MCSocialViewController继承自UITableViewController并实现好数据源方法</p>
</li>
<li><p>在MCHomeViewController.m中初始化多个MCSocialViewController并通过addChildViewController方式添加到控制器中</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加子控制器</span></span><br><span class="line">    [<span class="keyword">self</span> setupChildVc];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加标题</span></span><br><span class="line">    [<span class="keyword">self</span> setupTitle];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认显示第0个子控制器</span></span><br><span class="line">    [<span class="keyword">self</span> scrollViewDidEndScrollingAnimation:<span class="keyword">self</span><span class="variable">.contentScrollView</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setupChildVc</span><br><span class="line">&#123;</span><br><span class="line">    MCSocialViewController *social0 = [[MCSocialViewController alloc] init];</span><br><span class="line">    social0<span class="variable">.title</span> = <span class="string">@"国际"</span>;</span><br><span class="line">    [<span class="keyword">self</span> addChildViewController:social0];</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为顶部的titleScrollView添加多个标题并设置其滚动视图的contentSize和contentScrollView的contentSize</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 添加标题</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setupTitle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义临时变量</span></span><br><span class="line">    <span class="built_in">CGFloat</span> labelW = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> labelY = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> labelH = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加label</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">        XMGHomeLabel *label = [[XMGHomeLabel alloc] init];</span><br><span class="line">        label<span class="variable">.text</span> = [<span class="keyword">self</span><span class="variable">.childViewControllers</span>[i] title];</span><br><span class="line">        <span class="built_in">CGFloat</span> labelX = i * labelW;</span><br><span class="line">        label<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(labelX, labelY, labelW, labelH);</span><br><span class="line">        [label addGestureRecognizer:[[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(labelClick:)]];</span><br><span class="line">        label<span class="variable">.tag</span> = i;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.titleScrollView</span> addSubview:label];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 最前面的label</span></span><br><span class="line">            label<span class="variable">.scale</span> = <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置contentSize</span></span><br><span class="line">	<span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="number">7</span> * labelW, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 这里设置contentScrollView.contentSize宽高不能根据self.contentScrollView.frame.size 因为viewDidLoad从storyboard加载的时候尺寸是600*600,在执行- (void)viewDidAppear:(BOOL)animated时候能得到真正的尺寸,并且contentScrollView添加过约束,所以最后才能得到其准确的frame</span></span><br><span class="line">	<span class="keyword">self</span><span class="variable">.contentScrollView</span><span class="variable">.contentSize</span> = <span class="built_in">CGSizeMake</span>(<span class="number">7</span> * [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理顶部标题点击事件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)labelClick:(<span class="built_in">UITapGestureRecognizer</span> *)tap</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出被点击label的索引</span></span><br><span class="line">    <span class="built_in">NSInteger</span> index = tap<span class="variable">.view</span><span class="variable">.tag</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让底部的内容scrollView滚动到对应位置</span></span><br><span class="line">    <span class="built_in">CGPoint</span> offset = <span class="keyword">self</span><span class="variable">.contentScrollView</span><span class="variable">.contentOffset</span>;</span><br><span class="line">    offset<span class="variable">.x</span> = index * <span class="keyword">self</span><span class="variable">.contentScrollView</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.contentScrollView</span> setContentOffset:offset animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理滚动动画结束后,显示对应位置的控制器并将对应位置的标题显示在中间</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * scrollView结束了滚动动画以后就会调用这个方法(比如- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;方法执行的动画完毕后)</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一些临时变量</span></span><br><span class="line">    <span class="built_in">CGFloat</span> width = scrollView<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> height = scrollView<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> offsetX = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前位置需要显示的控制器的索引</span></span><br><span class="line">    <span class="built_in">NSInteger</span> index = offsetX / width;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让对应的顶部标题居中显示</span></span><br><span class="line">    <span class="built_in">UILabel</span> *label = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span>[index];</span><br><span class="line">    <span class="built_in">CGPoint</span> titleOffset = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.contentOffset</span>;</span><br><span class="line">    titleOffset<span class="variable">.x</span> = label<span class="variable">.center</span><span class="variable">.x</span> - width * <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 左边超出处理</span></span><br><span class="line">    <span class="keyword">if</span> (titleOffset<span class="variable">.x</span> &lt; <span class="number">0</span>) titleOffset<span class="variable">.x</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 右边超出处理</span></span><br><span class="line">    <span class="built_in">CGFloat</span> maxTitleOffsetX = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.contentSize</span><span class="variable">.width</span> - width;</span><br><span class="line">    <span class="keyword">if</span> (titleOffset<span class="variable">.x</span> &gt; maxTitleOffsetX) titleOffset<span class="variable">.x</span> = maxTitleOffsetX;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.titleScrollView</span> setContentOffset:titleOffset animated:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让其他label回到最初的状态</span></span><br><span class="line">    <span class="keyword">for</span> (MCHomeLabel *otherLabel <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (otherLabel != label) otherLabel<span class="variable">.scale</span> = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出需要显示的控制器</span></span><br><span class="line">    <span class="built_in">UIViewController</span> *willShowVc = <span class="keyword">self</span><span class="variable">.childViewControllers</span>[index];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前位置的位置已经显示过了,就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ([willShowVc isViewLoaded]) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//if (willShowVc.view.superview) return;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加控制器的view到contentScrollView中;</span></span><br><span class="line">    willShowVc<span class="variable">.view</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(offsetX, <span class="number">0</span>, width, height);</span><br><span class="line">    [scrollView addSubview:willShowVc<span class="variable">.view</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理手指滑动松开scrollView后显示对应位置的控制器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 手指松开scrollView后,scrollView停止减速完毕就会调用这个</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> scrollViewDidEndScrollingAnimation:scrollView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理滚动contentScrollView时标题缩放变色</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 只要scrollView在滚动，就会调用</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span> / scrollView<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="keyword">if</span> (scale &lt; <span class="number">0</span> || scale &gt; <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span><span class="variable">.count</span> - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得需要操作的左边label</span></span><br><span class="line">    <span class="built_in">NSInteger</span> leftIndex = scale;</span><br><span class="line">    MCHomeLabel *leftLabel = <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span>[leftIndex];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得需要操作的右边label</span></span><br><span class="line">    <span class="built_in">NSInteger</span> rightIndex = leftIndex + <span class="number">1</span>;</span><br><span class="line">    MCHomeLabel *rightLabel = (rightIndex == <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span><span class="variable">.count</span>) ? <span class="literal">nil</span> : <span class="keyword">self</span><span class="variable">.titleScrollView</span><span class="variable">.subviews</span>[rightIndex];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右边比例</span></span><br><span class="line">    <span class="built_in">CGFloat</span> rightScale = scale - leftIndex;</span><br><span class="line">    <span class="comment">// 左边比例</span></span><br><span class="line">    <span class="built_in">CGFloat</span> leftScale = <span class="number">1</span> - rightScale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置label的比例</span></span><br><span class="line">    leftLabel<span class="variable">.scale</span> = leftScale;</span><br><span class="line">    rightLabel<span class="variable">.scale</span> = rightScale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装titleLabel</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCHomeLabel</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.font</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> colorWithRed:MCRed green:M<span class="built_in">CGreen</span> blue:MCBlue alpha:<span class="number">1.0</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.textAlignment</span> = <span class="built_in">NSTextAlignmentCenter</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.userInteractionEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setScale:(<span class="built_in">CGFloat</span>)scale</span><br><span class="line">&#123;</span><br><span class="line">    _scale = scale;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//      R G B</span></span><br><span class="line">    <span class="comment">// 默认：0.4 0.6 0.7</span></span><br><span class="line">    <span class="comment">// 红色：1   0   0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> red = MCRed + (<span class="number">1</span> - XMGRed) * scale;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = M<span class="built_in">CGreen</span> + (<span class="number">0</span> - XMGGreen) * scale;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = MCBlue + (<span class="number">0</span> - XMGBlue) * scale;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大小缩放比例</span></span><br><span class="line">    <span class="built_in">CGFloat</span> transformScale = <span class="number">1</span> + scale * <span class="number">0.3</span>; <span class="comment">// [1, 1.3]</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeScale</span>(transformScale, transformScale);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="网易新闻项目知识点">网易新闻项目知识点</h3><ul>
<li><p>自定义MCHomeViewController继承自UIViewController</p>
</li>
<li><p>Main.storyboard 添加导航控制器为初始化控制器,添加UIViewController为导航控制器的根控制器并设置其Class类型为MCHomeViewController,为UIViewController添加2个UIScrollView并设置好约束,设置contentScrollView代理为MCHomeViewController</p>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[static与copy关键字]]></title>
    <link href="http://yoursite.com/2016/03/23/static_copy/"/>
    <id>http://yoursite.com/2016/03/23/static_copy/</id>
    <published>2016-03-23T06:55:35.000Z</published>
    <updated>2016-03-25T13:16:53.000Z</updated>
    <content type="html"><![CDATA[<h3 id="static的作用">static的作用</h3><h4 id="修饰局部变量">修饰局部变量</h4><ul>
<li>让局部变量只初始化一次</li>
<li>局部变量在程序中只有一份内存</li>
<li>并不会改变局部变量的作用域,仅仅是改变了局部变量的生命周期(只到程序结束，这个局部变量才会销毁)</li>
</ul>
<a id="more"></a>
<h4 id="static修饰全局变量">static修饰全局变量</h4><ul>
<li>全局变量的作用域仅限于当前文件</li>
</ul>
<h4 id="全局变量">全局变量</h4><ul>
<li>作用范围:整个程序</li>
<li>外部通过extern来访问全局变量(例如:<code>extern int age;</code>)</li>
<li>任何全局变量是不安全的,随时都可能被外部修改</li>
</ul>
<h3 id="实现拷贝的方法">实现拷贝的方法</h3><ul>
<li><p>copy</p>
<ul>
<li>只会产生不可变的副本对象(比如NSString),如果对不可变对象调用copy,不会产生新对象(浅拷贝-指针拷贝),反之会产生新对象(深度拷贝-内容拷贝)</li>
</ul>
</li>
<li><p>mutableCopy</p>
<ul>
<li>只会产生可变的副本对象(比如NSMutableString),都会产生新对象(深度拷贝-内容拷贝)</li>
</ul>
</li>
<li><p>自定义对象的copy</p>
<ul>
<li>自定义对象需要遵守NSCopying协议实现下面的方法<br><code>- (id)copyWithZone:(nullable NSZone *)zone;</code><br><code>- (id)mutableCopyWithZone:(nullable NSZone *)zone;</code></li>
<li>copy 会调用自定义对象的 copyWithZone</li>
<li><p>mutableCopy 会调用自定义对象的 mutableCopyWithZone</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCPerson</span>() &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    MCPerson *person = [[MCPerson allocWithZone:zone] init];</span><br><span class="line">    person<span class="variable">.age</span> = <span class="keyword">self</span><span class="variable">.age</span>;</span><br><span class="line">    person<span class="variable">.money</span> = <span class="keyword">self</span><span class="variable">.money</span>;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>@property中的copy</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">//如果是strong则其set方法是:</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">//如果是copy则其set方法是:</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    _name = [name <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> copyProperty()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *string = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"jack"</span>];</span><br><span class="line">    </span><br><span class="line">    MCPerson *p = [[MCPerson alloc] init];</span><br><span class="line">    p<span class="variable">.name</span> = string;</span><br><span class="line">    <span class="comment">//[p setName:string];</span></span><br><span class="line">    </span><br><span class="line">    [string appendString:<span class="string">@" rose"</span>];</span><br><span class="line">    <span class="comment">//如果property中是strong 则输出是"jack rose",copy则输出"jack"</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, p<span class="variable">.name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** name属性值永远是不可变，所以定义为NSMutableString是不合理的 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableString</span> *name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="static的作用">static的作用</h3><h4 id="修饰局部变量">修饰局部变量</h4><ul>
<li>让局部变量只初始化一次</li>
<li>局部变量在程序中只有一份内存</li>
<li>并不会改变局部变量的作用域,仅仅是改变了局部变量的生命周期(只到程序结束，这个局部变量才会销毁)</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS父子控制器]]></title>
    <link href="http://yoursite.com/2016/03/23/parent_childs_vc/"/>
    <id>http://yoursite.com/2016/03/23/parent_childs_vc/</id>
    <published>2016-03-23T02:09:28.000Z</published>
    <updated>2016-03-23T13:46:23.000Z</updated>
    <content type="html"><![CDATA[<h3 id="父子控制器">父子控制器</h3><ul>
<li><p>UIViewController 添加子控制器<br><code>- (void)addChildViewController:(UIViewController *)childController</code></p>
</li>
<li><p>将当前控制器从父控制器中移除<br><code>- (void) removeFromParentViewController</code></p>
</li>
<li><p>获取当前控制器的所有子控制器<br><code>@property(nonatomic,readonly) NSArray&lt;__kindof UIViewController *&gt; *childViewControllers</code></p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>获取当前控制器的父控制器<br><code>@property(nullable,nonatomic,weak,readonly) UIViewController *parentViewController;</code></p>
</li>
<li><p>获取当前控制器的所属导航控制器<br>系统会通过父子关系的链条来找到它的导航控制器,如果找不到则<code>self.navigationController</code>的值为nil<br><code>@property(nullable, nonatomic,readonly,strong) UINavigationController *navigationController;</code></p>
</li>
<li><p><code>[self dismissViewControllerAnimated:YES completion:nil];</code> 系统会检测当前控制器是不是被Modal出来的,如果不是则会检测它的父控制器,如果都不是则不能dismiss.</p>
</li>
<li><p>默认情况下,所有控制器view的autoresizingMask属性都包含了UIViewAutoresizingFlexibleWidth和UIViewAutoresizingFlexibleHeight两个值.如果从xib中加载控制器 尺寸是600*600,往控制器里面添加子控制器或者view的时候可能导致看不见,这个时候需要关掉子控制器的自动伸缩功能<br><code>vc.view.autoresizingMask = UIViewAutoresizingNone;</code></p>
</li>
<li><p>当前控制器已经被添加到某个父控制器上或者从父控制器上移除的时候就会调用这个方法,如果是通过addChildViewController方式添加的子控制器是不会调用didMoveToParentViewController,但是可以在addChildViewController之后手动调用didMoveToParentViewController<br><code>- (void)didMoveToParentViewController:(nullable UIViewController *)parent</code></p>
</li>
<li><p>控制器automaticallyAdjustsScrollViewInsets属性默认值为YES,如果当前控制器是导航控制器并且第一个子View是UIScrollView则会自动调整第一个UIScrollView内边距,但是不会自动调整后面的UIScrollView内边距.如果第一个View不是UIScrollView则不会调整后面UIScrollView的内边距<br><code>self.automaticallyAdjustsScrollViewInsets = NO;//不会自动去调整uiscrollView的contentInset属性</code></p>
</li>
</ul>
<h3 id="转场动画">转场动画</h3><ul>
<li><p>动画效果:<br>@”cube” @”moveIn” @”reveal” @”fade”(default) @”pageCurl” @”pageUnCurl” @”suckEffect” @”rippleEffect” @”oglFlip” @”push”</p>
</li>
<li><p>动画方向:<br>kCATransitionFromRight;<br>kCATransitionFromLeft;<br>kCATransitionFromTop;<br>kCATransitionFromBottom;</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CATransition</span> *animation = [<span class="built_in">CATransition</span> animation];</span><br><span class="line">animation<span class="variable">.type</span> = <span class="string">@"cube"</span>;</span><br><span class="line">animation<span class="variable">.subtype</span> = index &gt; oldIndex ? k<span class="built_in">CATransitionFromRight</span> : k<span class="built_in">CATransitionFromLeft</span>;</span><br><span class="line">animation<span class="variable">.duration</span> = <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">//动画的开始与结束的快慢</span></span><br><span class="line">animation<span class="variable">.timingFunction</span> = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:k<span class="built_in">CAMediaTimingFunctionEaseInEaseOut</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.navigationController</span><span class="variable">.view</span><span class="variable">.layer</span> addAnimation:animation forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="父子控制器">父子控制器</h3><ul>
<li><p>UIViewController 添加子控制器<br><code>- (void)addChildViewController:(UIViewController *)childController</code></p>
</li>
<li><p>将当前控制器从父控制器中移除<br><code>- (void) removeFromParentViewController</code></p>
</li>
<li><p>获取当前控制器的所有子控制器<br><code>@property(nonatomic,readonly) NSArray&lt;__kindof UIViewController *&gt; *childViewControllers</code></p>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[彩票项目主要知识点]]></title>
    <link href="http://yoursite.com/2016/03/22/color_card/"/>
    <id>http://yoursite.com/2016/03/22/color_card/</id>
    <published>2016-03-22T01:00:00.000Z</published>
    <updated>2016-03-22T14:38:13.000Z</updated>
    <content type="html"><![CDATA[<h3 id="自定义UITabBar">自定义UITabBar</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUpTabBar</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    MCTabBar *tabBar = [[MCTabBar alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储UITabBarItem</span></span><br><span class="line">    tabBar<span class="variable">.items</span> = <span class="keyword">self</span><span class="variable">.items</span>;</span><br><span class="line">    </span><br><span class="line">    tabBar<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    tabBar<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除系统的tabBar,相当于将tabBar上的所有按钮移除</span></span><br><span class="line">	<span class="comment">//将一个控件从父控件中移除并不会马上销毁,一般在下一次运行循环的时候,就会判断这个对象有没有强引用,如果没有,才会销毁</span></span><br><span class="line">	<span class="comment">//[self.tabBar removeFromSuperview];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//tabBar.frame = self.tabBar.frame;</span></span><br><span class="line"></span><br><span class="line">    tabBar<span class="variable">.frame</span> = <span class="keyword">self</span><span class="variable">.tabBar</span><span class="variable">.bounds</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.tabBar</span> addSubview:tabBar];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把系统的tabBar上的按钮干掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *childView <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.tabBar</span><span class="variable">.subviews</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![childView isKindOfClass:[MCTabBar class]]) &#123;</span><br><span class="line">            [childView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="自定义导航控制器">自定义导航控制器</h3><ul>
<li><p>处理目标控制器滑动返回(整个页面都可以滑动返回)方式一</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用运行时机制获取某个类里面的属性</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCNavigationController</span> ()&lt;<span class="title">UIGestureRecognizerDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCNavigationController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止手势冲突</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.enabled</span> = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历某个类里面所有属性 Ivar:表示成员属性</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copyIvarList:只能获取哪个类下面的属性,并不会越界（不会把它的父类的属性给遍历出来）</span></span><br><span class="line">    <span class="comment">//Class:获取哪个类的成员属性</span></span><br><span class="line">    <span class="comment">//count:告诉你当前类里面成员属性的总数</span></span><br><span class="line">    <span class="comment">//返回成员属性的数组</span></span><br><span class="line">    Ivar *ivars = class_copyIvarList([<span class="built_in">UIGestureRecognizer</span> class], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">       <span class="comment">// 取出成员变量</span></span><br><span class="line">       Ivar ivar = ivars[i];</span><br><span class="line">            </span><br><span class="line">       <span class="comment">// 获取属性名</span></span><br><span class="line">       <span class="built_in">NSString</span> *ivarName = @(ivar_getName(ivar));</span><br><span class="line">            </span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,ivarName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//_targets:属性名 value</span></span><br><span class="line">    <span class="built_in">NSArray</span> *targets = [<span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span> valueForKeyPath:<span class="string">@"_targets"</span>];</span><br><span class="line">    <span class="keyword">id</span> objc = [targets firstObject];</span><br><span class="line">    <span class="keyword">id</span> target = [objc valueForKeyPath:<span class="string">@"_target"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其实target就是self.interactivePopGestureRecognizer.delegate</span></span><br><span class="line">    <span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:target action:<span class="keyword">@selector</span>(handleNavigationTransition:)];</span><br><span class="line">    </span><br><span class="line">    pan<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addGestureRecognizer:pan];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 手势代理方法</span></span><br><span class="line"><span class="comment">// 是否开始触发手势</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断下当前控制器是否是根控制器</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span><span class="variable">.topViewController</span> != [<span class="keyword">self</span><span class="variable">.viewControllers</span> firstObject]);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.viewControllers</span><span class="variable">.count</span> != <span class="number">0</span>) &#123; <span class="comment">// 非根控制器</span></span><br><span class="line">        viewController<span class="variable">.hidesBottomBarWhenPushed</span> = <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置导航条左边按钮的内容,把系统的返回按钮给覆盖,导航控制器的滑动返回功能就木有啦</span></span><br><span class="line">        viewController<span class="variable">.navigationItem</span><span class="variable">.leftBarButtonItem</span> = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"NavBack"</span>] style:<span class="built_in">UIBarButtonItemStyleBordered</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(back)];</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> pushViewController:viewController animated:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)back</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>处理目标控制器滑动返回(从左边沿滑动返回)方式二</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCNavigationController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> popDelegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCNavigationController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理做了一些滑动返回功能,而且做了一系列的判断</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.popDelegate</span> = <span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.delegate</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 导航控制器的代理方法</span></span><br><span class="line"><span class="comment">// 完全展示完调用</span></span><br><span class="line">- (<span class="keyword">void</span>)navigationController:(<span class="built_in">UINavigationController</span> *)navigationController didShowViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果展示的控制器是根控制器，就还原pop手势代理</span></span><br><span class="line">    <span class="keyword">if</span> (viewController == [<span class="keyword">self</span><span class="variable">.viewControllers</span> firstObject]) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.delegate</span> = <span class="keyword">self</span><span class="variable">.popDelegate</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复写导航控制器方法,push的时候隐藏底部UITabBar</span></span><br><span class="line">- (<span class="keyword">void</span>)pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.viewControllers</span><span class="variable">.count</span> != <span class="number">0</span>) &#123; <span class="comment">// 非根控制器</span></span><br><span class="line">        viewController<span class="variable">.hidesBottomBarWhenPushed</span> = <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置导航条左边按钮的内容,把系统的返回按钮给覆盖,导航控制器的滑动返回功能就木有啦</span></span><br><span class="line">        viewController<span class="variable">.navigationItem</span><span class="variable">.leftBarButtonItem</span> = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"NavBack"</span>] style:<span class="built_in">UIBarButtonItemStyleBordered</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(back)];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 就有滑动返回功能</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.interactivePopGestureRecognizer</span><span class="variable">.delegate</span> = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> pushViewController:viewController animated:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)back</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="自定义导航条样式">自定义导航条样式</h3><ul>
<li>修改导航条背景图片、文字颜色、标题、返回按钮<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果要设置导航条背景图片,必须使用UIBarMetricsDefault,默认导航控制器的子控制器的view尺寸会变化</span></span><br><span class="line"><span class="comment">//设置导航条背景图片一定要在导航条显示之前设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前类或者他的子类第一次使用的时候才会调用</span></span><br><span class="line">+ (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置导航条的内容</span></span><br><span class="line">    <span class="comment">//获取当前应用下所有的导航条,可能会修改系统相册的导航条,因此推荐使用下面的那种方式修改导航条样式</span></span><br><span class="line">    <span class="built_in">UINavigationBar</span> *bar = [<span class="built_in">UINavigationBar</span> appearance];</span><br><span class="line">    <span class="comment">//获取哪个类下的导航条</span></span><br><span class="line">    <span class="built_in">UINavigationBar</span> *bar = [<span class="built_in">UINavigationBar</span> appearanceWhenContainedIn:<span class="keyword">self</span>,<span class="literal">nil</span>];</span><br><span class="line">    [bar setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过setTintColor设置导航条文字的颜色</span></span><br><span class="line">    [bar setTintColor:[<span class="built_in">UIColor</span> whiteColor]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置导航条标题的颜色</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *titleAttr = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    titleAttr[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    <span class="comment">//titleAttr[NSFontAttributeName] = [NSFont systemFontOfSize:20];</span></span><br><span class="line">    titleAttr[<span class="built_in">NSFontAttributeName</span>] = [<span class="built_in">NSFont</span> boldSystemFontOfSize:<span class="number">20</span>];</span><br><span class="line">    [bar setTitleTextAttributes:(<span class="built_in">NSDictonary</span> *)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以调整返回按钮文字的偏移量</span></span><br><span class="line">    <span class="comment">//[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -100) forBarMetrics:UIBarMetricsDefault];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="我的彩票模块">我的彩票模块</h3><ul>
<li>设置导航条左右2边的按钮<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载类的时候调用</span></span><br><span class="line"><span class="comment">//当程序一启动的时候就会调用</span></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setUpNav</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//设置导航条左右2边的按钮</span></span><br><span class="line">	<span class="built_in">UIButton</span> *btn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">	[btn setTitle:<span class="string">@"客服"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">	[btn setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自适应尺寸</span></span><br><span class="line">	[btn sizeToFit];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UIBarButtonItem</span> *lefItem = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithCustomView:(<span class="built_in">UIView</span> *)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置左边</span></span><br><span class="line">	<span class="keyword">self</span><span class="variable">.navigationItem</span><span class="variable">.leftBarButtonItem</span> = leftItem;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>];</span><br><span class="line">	image = [image imageWithRenderingMode:<span class="built_in">UIImageRenderingModeAlwaysOriginal</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置右边</span></span><br><span class="line">	<span class="keyword">self</span><span class="variable">.navigationItem</span><span class="variable">.rightBarButtonItem</span> = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>] style:<span class="built_in">UIBarButtonItemStylePlain</span> target:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(settings)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@property 如果在分类里面只会生成get,set方法的声明,并不会生成成员属性和方法实现.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用pch">使用pch</h3><ul>
<li>配置.pch文件路径:配置预编译文件路径:Build Settings-&gt;Prefix Header-&gt;填写.pch文件的路径<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef __OBJC__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="购彩大厅模块">购彩大厅模块</h3><ul>
<li><p>自定义活动菜单</p>
<ul>
<li>添加蒙版-自定义半透明CoverView:<br>  1.设置frame为[UIScreen mainScreen].bounds;<br>  2.设置背景颜色为黑色<br>  3.透明度为0.7<br>  4.最后将其加到主窗口上</li>
<li>自定义ActiveMenuView<br>  1.使用xib设置宽高各位200<br>  2.添加ImageView为其添加相对于父控件上下左右为0的约束<br>  3.右上角加入取消按钮<br>  4.从xib加载自定义view<br>  5.修改形变  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1</span> animations:^&#123;</span><br><span class="line">	<span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">	transform = <span class="built_in">CGAffineTransformTranslate</span>(transform,<span class="keyword">self</span><span class="variable">.center</span><span class="variable">.x</span>+<span class="number">44</span>,-<span class="keyword">self</span><span class="variable">.center</span><span class="variable">.y</span>+<span class="number">44</span>);</span><br><span class="line">	transform = <span class="built_in">CGAffineTransformScale</span>(transform,<span class="number">0.01</span>,<span class="number">0.01</span>);</span><br><span class="line">	<span class="keyword">self</span><span class="variable">.transform</span> = transform;</span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished)&#123;</span><br><span class="line">	[<span class="keyword">self</span> removeFromSuperview];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>自定义pop菜单</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">rows = (count-<span class="number">1</span>) / cols + <span class="number">1</span>;</span><br><span class="line">menu<span class="variable">.transform</span> = <span class="built_in">CGAffineformMakeTranslation</span>(<span class="number">0</span>,-menu<span class="variable">.height</span>);</span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span> delay:<span class="number">0</span> usingSpringWithDamping:<span class="number">0.3</span> initialSpringVelocity:<span class="number">0</span> options:<span class="built_in">UIViewAnimationOptionCurveEaseInOut</span> animations:^&#123;</span><br><span class="line">	menu<span class="variable">.transform</span> = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//将menu添加到控制器view上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//隐藏menu</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1</span> animations:^&#123;</span><br><span class="line">	<span class="keyword">self</span><span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeTranslate</span>(<span class="number">0</span>,-<span class="keyword">self</span><span class="variable">.height</span>);</span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished)&#123;</span><br><span class="line">	[<span class="keyword">self</span> removeFromSuperview];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="竞技场模块">竞技场模块</h3><ul>
<li>修改导航条背景图片和自定义标题视图<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UISegmentedControl</span> *seg = [[<span class="built_in">UISegmentedControl</span> alloc] initWithItems:@[<span class="string">@"足球"</span>,<span class="string">@"篮球"</span>]];</span><br><span class="line">    seg<span class="variable">.width</span> += <span class="number">40</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置UISegmentedControl背景图片</span></span><br><span class="line">[seg setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"CPArenaSegmentBG"</span>] forState:<span class="built_in">UIControlStateNormal</span> barMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">[seg setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"CPArenaSegmentSelectedBG"</span>] forState:<span class="built_in">UIControlStateSelected</span> barMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">seg<span class="variable">.selectedSegmentIndex</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 设置边框颜色</span></span><br><span class="line">seg<span class="variable">.tintColor</span> = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0</span>/<span class="number">255.0</span> green:<span class="number">142</span>/<span class="number">255.0</span> blue:<span class="number">143</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">dict[<span class="built_in">NSForegroundColorAttributeName</span>] = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">[seg setTitleTextAttributes:dict forState:<span class="built_in">UIControlStateSelected</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">self</span><span class="variable">.navigationItem</span><span class="variable">.titleView</span> = seg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置导航条背景图片并处理图片拉伸</span></span><br><span class="line">+ (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前类下面的所有导航条去设置</span></span><br><span class="line">    <span class="built_in">UINavigationBar</span> *bar = [<span class="built_in">UINavigationBar</span> appearanceWhenContainedIn:<span class="keyword">self</span>, <span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    [bar setBackgroundImage:[<span class="built_in">UIImage</span> imageWithStretchableImageName:<span class="string">@"NLArenaNavBar64"</span>] forBarMetrics:<span class="built_in">UIBarMetricsDefault</span>];</span><br><span class="line">&#125;</span><br><span class="line">+ (instancetype)imageWithStretchableImageName:(<span class="built_in">NSString</span> *)imageName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">    <span class="keyword">return</span> [image stretchableImageWithLeftCapWidth:image<span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span> topCapHeight:image<span class="variable">.size</span><span class="variable">.height</span> * <span class="number">0.5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="发现模块">发现模块</h3><ul>
<li><p>从storyboard加载控制器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIStoryboard</span> *storyboard = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"MCDiscoverViewController"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">MCDiscoverViewController *discover = [storyboard instantiateInitialViewController];</span><br><span class="line"><span class="comment">//MCDiscoverViewController *discover = [storyboard instantiateViewControllerWithIdentifier:(NSString *)identifier];</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当push目标控制器之前隐藏底部UITabBar</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *vc = segue<span class="variable">.destinationViewController</span>;</span><br><span class="line">    </span><br><span class="line">    vc<span class="variable">.hidesBottomBarWhenPushed</span> = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为UIImageView加载多张图片动画</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:(nullable <span class="built_in">UIImage</span> *)image];</span><br><span class="line">imageView<span class="variable">.animationImages</span> = @[<span class="built_in">UIImage</span>,<span class="built_in">UIImage</span>];</span><br><span class="line">imageView<span class="variable">.animationDuration</span> = <span class="number">1</span>;</span><br><span class="line">[imageView startAnimating];</span><br></pre></td></tr></table></figure>
</li>
<li><p>xib中图片拉伸处理<br>选中图片,修改XCode右侧属性栏中Stretching<br>x:0.5 y:0.5 width:0 height:0<br>x为图片左边一半不拉伸,y为图片上边一半不拉伸,只拉伸中间1像素点.</p>
</li>
<li>处理按钮图片拉伸<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>];</span><br><span class="line">image = [image stretchableImageWithLeftCapWidth:image<span class="variable">.size</span><span class="variable">.width</span> * <span class="number">0.5</span> topCapHeight:image<span class="variable">.size</span><span class="variable">.height</span> * <span class="number">0.5</span>];</span><br><span class="line">[btn setBackgroundImage:image forState:<span class="built_in">UIControlStateNormal</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="比较APP版本">比较APP版本</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从info.plist获取用户最新的版本号</span></span><br><span class="line"><span class="built_in">NSString</span> *curVersion = [<span class="built_in">NSBundle</span> mainBundle]<span class="variable">.infoDictionary</span>[<span class="string">@"CFBundleShortVersionString"</span>];</span><br><span class="line"><span class="comment">// 获取上一次版本号</span></span><br><span class="line"><span class="built_in">NSString</span> *oldVersion = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:MCVersionKey];</span><br></pre></td></tr></table></figure>
<h3 id="自定义引导页">自定义引导页</h3><ul>
<li>继承UICollectionViewController</li>
<li>初始化的时候必须设置布局参数,通常使用系统提供的流水布局UICollectionViewFlowLayout</li>
<li>cell必须通过注册</li>
<li>自定义cell</li>
<li>实现UICollectionView数据源方法</li>
<li>封装Guide工具类,比较版本号,跳转到不同的页面</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 流水布局对象,设置cell的尺寸和位置</span></span><br><span class="line">    <span class="built_in">UICollectionViewFlowLayout</span> *layout  = [[<span class="built_in">UICollectionViewFlowLayout</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置滚动的方向</span></span><br><span class="line">    layout<span class="variable">.scrollDirection</span> = <span class="built_in">UICollectionViewScrollDirectionHorizontal</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置cell的尺寸</span></span><br><span class="line">    layout<span class="variable">.itemSize</span> = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span>;</span><br><span class="line">    <span class="comment">// 设置cell之间间距</span></span><br><span class="line">    layout<span class="variable">.minimumInteritemSpacing</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置行距</span></span><br><span class="line">    layout<span class="variable">.minimumLineSpacing</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置每一组的内间距</span></span><br><span class="line">    <span class="comment">//layout.sectionInset = UIEdgeInsetsMake(0, 10, 0, 10);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  [<span class="keyword">super</span> initWithCollectionViewLayout:layout];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.bounces</span> = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.showsHorizontalScrollIndicator</span> = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.pagingEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册cell</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> registerClass:[MCNewFeatureCell class] forCellWithReuseIdentifier:ID];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> setUpAllChildView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - UICollectionView有多少组</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInCollectionView:(<span class="built_in">UICollectionView</span> *)collectionView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 返回第section组有多少个cell</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView numberOfItemsInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 返回每个cell长什么样</span></span><br><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    MCNewFeatureCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:ID forIndexPath:indexPath];</span><br><span class="line">    <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"guide%ldBackground"</span>,indexPath<span class="variable">.item</span> + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    cell<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 添加所有子控件</span></span><br><span class="line">- (<span class="keyword">void</span>)setUpAllChildView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// guide1</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *guide = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"guide1"</span>]];</span><br><span class="line">    _guideView = guide;</span><br><span class="line">    guide<span class="variable">.centetX</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centetX</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> addSubview:guide];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// guideLine</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *guideLine = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"guideLine"</span>]];</span><br><span class="line">    guideLine<span class="variable">.x</span> -= <span class="number">170</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> addSubview:guideLine];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// largerText</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *largerText = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"guideLargeText1"</span>]];</span><br><span class="line">    largerText<span class="variable">.centetX</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centetX</span>;</span><br><span class="line">    largerText<span class="variable">.centetY</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.height</span> * <span class="number">0.7</span>;</span><br><span class="line">    _guideLargetView = largerText;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> addSubview:largerText];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// smallText</span></span><br><span class="line">    <span class="built_in">UIImageView</span> *smallText = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"guideSmallText1"</span>]];</span><br><span class="line">    _guideSmallView = smallText;</span><br><span class="line">    smallText<span class="variable">.centetX</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.centetX</span>;</span><br><span class="line">    smallText<span class="variable">.centetY</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.height</span> * <span class="number">0.8</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> addSubview:smallText];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减速完成</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</span><br><span class="line">    <span class="comment">// 获取当前x偏移量</span></span><br><span class="line">    <span class="built_in">CGFloat</span> curOffsetX = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取差值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> delta = curOffsetX - _lastOffsetX;</span><br><span class="line">    </span><br><span class="line">    _guideView<span class="variable">.x</span> += <span class="number">2</span> *  delta;</span><br><span class="line">    _guideLargetView<span class="variable">.x</span> += <span class="number">2</span> * delta;</span><br><span class="line">    _guideSmallView<span class="variable">.x</span> +=  <span class="number">2</span> * delta;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.25</span> animations:^&#123;</span><br><span class="line">        _guideView<span class="variable">.x</span> -=  delta;</span><br><span class="line">        _guideLargetView<span class="variable">.x</span> -= delta;</span><br><span class="line">        _guideSmallView<span class="variable">.x</span> -=   delta;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> page = curOffsetX / <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.width</span> + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改控件的内容</span></span><br><span class="line">    _guideView<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"guide%d"</span>,page]];</span><br><span class="line">    _lastOffsetX = curOffsetX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义cell继承自UICollectionViewCell</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCNewFeatureCell</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCNewFeatureCell</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImageView</span> *)imageView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_imageView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">UIImageView</span> *imageV = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="keyword">self</span><span class="variable">.bounds</span>];</span><br><span class="line">        </span><br><span class="line">        _imageView = imageV;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.contentView</span> addSubview:imageV];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _imageView;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    _image = image;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.imageView</span><span class="variable">.image</span> = image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="设置模块">设置模块</h3><ul>
<li><p>封装一个设置控制器的基类(MCBaseSettingViewController)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MCBaseSettingViewController</span> : <span class="title">UITableViewController</span></span></span><br><span class="line"><span class="comment">// 记录当前tableView的所有数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *groups;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>封装不同类型的item模型(image、title、subTitle、itemOpertionBlock、跳转的控制器Class、UISwitch状态)</p>
</li>
<li>封装group模型(items、headTitle、footTitle)</li>
<li>自定义cell</li>
<li>实现数据源方法和代理方法(点击不同的item执行不同的block来处理跳转)<br><code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath</code></li>
</ul>
<h3 id="Block">Block</h3><ul>
<li>block会把代码里所有强指针全部强引用</li>
<li><p>处理block引起的循环引用的问题,需要将所有block代码里面的self转为弱引用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typeof获取括号里面的类型</span></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>block内部对外部的变量只可以读取;</p>
</li>
<li>默认情况下,block内部不能修改外面的变量，修改编译器就会报错；</li>
<li>给局部变量加上__block关键字,这个局部变量可以在block内部修改。</li>
</ul>
<h3 id="JSON解析与KVC">JSON解析与KVC</h3><ul>
<li><p>使用NSJSONSerialization解析json</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *filePath =  [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"help.json"</span> ofType:<span class="literal">nil</span>];      </span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:filePath];</span><br><span class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingAllowFragments</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>kvc 处理字典转模型</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果模型中的key与字典中的key不一致时,需要重写模型中的</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MCHtmlItem</span></span></span><br><span class="line">+ (instancetype)itemWithDict:(<span class="built_in">NSDictionary</span> *)dict</span><br><span class="line">&#123;</span><br><span class="line">    MCHtmlItem *item = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    [item setValuesForKeysWithDictionary:dict];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历字典里面的所有key去模型中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"id"</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> setValue:value forKeyPath:<span class="string">@"ID"</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">super</span> setValue:value forKey:key];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面这个方式使用起来有很多弊端.</span></span><br><span class="line"><span class="comment">//所以我们为NSObject做一个分类,来反向查询字典并为model属性赋值</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Model</span>)</span></span><br><span class="line"></span><br><span class="line">+ (instancetype)objcWithDict:(<span class="built_in">NSDictionary</span> *)dict mapDict:(<span class="built_in">NSDictionary</span> *)mapDict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历模型中属性</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Ivar *ivars = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 属性名称</span></span><br><span class="line">        <span class="built_in">NSString</span> *ivarName = @(ivar_getName(ivar));</span><br><span class="line">        </span><br><span class="line">        ivarName = [ivarName substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">id</span> value = dict[ivarName];</span><br><span class="line">        <span class="comment">// 需要由外界通知内部,模型中属性名对应字典里面的哪个key</span></span><br><span class="line">        <span class="comment">// ID -&gt; id</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapDict) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *keyName = mapDict[ivarName];</span><br><span class="line">                </span><br><span class="line">            value = dict[keyName];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">            [objc setValue:value forKeyPath:ivarName];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> objc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="自定义UITabBar">自定义UITabBar</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setUpTabBar</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    MCTabBar *tabBar = [[MCTabBar alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储UITabBarItem</span></span><br><span class="line">    tabBar<span class="variable">.items</span> = <span class="keyword">self</span><span class="variable">.items</span>;</span><br><span class="line">    </span><br><span class="line">    tabBar<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    tabBar<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除系统的tabBar,相当于将tabBar上的所有按钮移除</span></span><br><span class="line">	<span class="comment">//将一个控件从父控件中移除并不会马上销毁,一般在下一次运行循环的时候,就会判断这个对象有没有强引用,如果没有,才会销毁</span></span><br><span class="line">	<span class="comment">//[self.tabBar removeFromSuperview];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//tabBar.frame = self.tabBar.frame;</span></span><br><span class="line"></span><br><span class="line">    tabBar<span class="variable">.frame</span> = <span class="keyword">self</span><span class="variable">.tabBar</span><span class="variable">.bounds</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.tabBar</span> addSubview:tabBar];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把系统的tabBar上的按钮干掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *childView <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.tabBar</span><span class="variable">.subviews</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![childView isKindOfClass:[MCTabBar class]]) &#123;</span><br><span class="line">            [childView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS数据存储]]></title>
    <link href="http://yoursite.com/2016/03/17/ios_save_data/"/>
    <id>http://yoursite.com/2016/03/17/ios_save_data/</id>
    <published>2016-03-17T12:00:00.000Z</published>
    <updated>2016-03-19T10:17:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="如何定义block">如何定义block</h3><ul>
<li>快捷键inline<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">returnType(^blockName)(parameterTypes) = ^(parameters) &#123;</span><br><span class="line">        statements</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h3 id="iOS应用数据存储的常用方式">iOS应用数据存储的常用方式</h3><ul>
<li>XML属性列表(plist)归档</li>
<li>Preference(偏好设置)</li>
<li>NSKeyedArchiver归档(NSCoding)</li>
<li>SQLite3</li>
<li>Core Data</li>
</ul>
<h3 id="应用沙盒">应用沙盒</h3><p>应用沙盒的文件系统目录</p>
<ul>
<li>应用程序包:包含了所有的资源文件和可执行文件</li>
<li>Documents:保持应用运行时生成的需要持久化的数据,iTunes同步设备时会备份该目录.</li>
<li>Library<ul>
<li>Caches:保存应用运行时生成的需要持久化的数据,iTunes同步设备时不会备份该目录.一般存储体积大、不需要备份的非重要数据</li>
<li>Preferences:保存应用的所有偏好设置,iOS的Settings(设置)应用会在该目录中查找应用的设置信息.iTunes同步设备时会备份该目录</li>
</ul>
</li>
<li>tmp:保存应用运行时所需要的临时数据,使用完毕后再将相应的文件从该目录删除.应用没有运行时,系统也可能会清除该目录下的文件,iTunes同步设备时不会备份该目录</li>
</ul>
<h5 id="模拟器应用沙盒的根路径在:(apple是用户名,8-0是模拟器版本)">模拟器应用沙盒的根路径在:(apple是用户名,8.0是模拟器版本)</h5><p><code>/Users/apple/Library/Application Support/iPhone Simulator/8.0/Applications</code></p>
<h5 id="获取应用的文件夹(应用沙盒)">获取应用的文件夹(应用沙盒)</h5><p><code>NSString *homePath = NSHomeDirectory();</code></p>
<h5 id="获取沙盒中的文件夹">获取沙盒中的文件夹</h5><p><code>NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory,NSSearchPathDomainMask domainMask,BOOL expandTilde);</code></p>
<p>NSSearchPathDirectory:搜索的目录 <code>NSCacheDirectory</code><br>NSSearchPathDomainMask:搜索的范围 <code>NSUserDomainMask</code>:表示在用户的手机上查找<br>expandTilde:是否展开全路径,如果没展开,应用的沙盒路径就是~</p>
<h5 id="获取Cache文件夹">获取Cache文件夹</h5><p><code>NSSearchPathForDirectoriesInDomains(NSCacheDirectory,NSUserDomainMask,YES)</code></p>
<h5 id="获取Documents文件夹">获取Documents文件夹</h5><p><code>NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)</code></p>
<h5 id="获取tmp临时文件夹">获取tmp临时文件夹</h5><p><code>NSTemporaryDirectory()</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Cache文件夹路径</span></span><br><span class="line"><span class="built_in">NSString</span> *cachePath = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCacheDirectory</span>,<span class="built_in">NSUserDomainMask</span>,<span class="literal">YES</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//拼接文件名</span></span><br><span class="line"><span class="built_in">NSString</span> *filePath = [cachePath stringByAppendingPathComponent:<span class="string">@"arr.plist"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *arr = @[<span class="string">@"A"</span>,<span class="string">@"123"</span>];</span><br><span class="line"><span class="comment">//写入plist文件</span></span><br><span class="line">[arr writeToFile:filePath atomically:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取plist中的内容</span></span><br><span class="line">[<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</span><br><span class="line"></span><br><span class="line"><span class="comment">//plist 不能存储自定义对象</span></span><br></pre></td></tr></table></figure>
<h3 id="偏好设置存储">偏好设置存储</h3><ul>
<li>存放在<code>Library/Preferences/xxx.plist</code><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">[userDefaults setObject:<span class="string">@"value"</span> forKey:<span class="string">@"key"</span>];</span><br><span class="line">[userDefaults setBOOL:<span class="literal">YES</span> forKey:<span class="string">@"key"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在iOS7之前,默认不会马上将数据写到文件中</span></span><br><span class="line"><span class="comment">// 这个方法会立即将缓存中的数据写入到文件中</span></span><br><span class="line">[userDefaults synchronize];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从偏好设置中读取数据</span></span><br><span class="line"><span class="built_in">NSString</span> *value = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:<span class="string">@"key"</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="NSKeyedArchiver归档和NSKeyedUnarchiver解档">NSKeyedArchiver归档和NSKeyedUnarchiver解档</h3><ul>
<li><p>归档(<code>NSKeyedArchiver</code>)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Cache文件夹路径</span></span><br><span class="line"><span class="built_in">NSString</span> *cachePath = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCacheDirectory</span>,<span class="built_in">NSUserDomainMask</span>,<span class="literal">YES</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//拼接文件名</span></span><br><span class="line"><span class="built_in">NSString</span> *filePath = [cachePath stringByAppendingPathComponent:<span class="string">@"person.data"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义对象想要归档,必须遵守NSCoding协议,实现协议方法</span></span><br><span class="line"><span class="comment">//- (void)encodeWithCoder:(NSCoder *)aCoder : 用来描述当前对象的哪些属性需要归档</span></span><br><span class="line"><span class="comment">//[aCoder encodeObject:(id) forKey:(NSString *)];</span></span><br><span class="line"><span class="comment">//[aCoder encodeInt:(int) forKey:(NSString *)];</span></span><br><span class="line"></span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">//将自定义对象归档</span></span><br><span class="line">[<span class="built_in">NSKeyedArchiver</span> archiveRootObject:p toFile:filePath];</span><br></pre></td></tr></table></figure>
</li>
<li><p>解档(<code>NSKeyedUnarchiver</code>)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:(<span class="built_in">NSString</span> *)];</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义对象想要解档,必须遵守NSCoding协议,实现协议方法</span></span><br><span class="line"><span class="comment">//- (id)initWithCoder:(NSCoder *)aDecoder: 用来描述当前对象的哪些属性需要解档,当解档对象的时候调用</span></span><br><span class="line"><span class="comment">//解析文件会调用这个方法</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> init])&#123;</span><br><span class="line">		<span class="comment">//一定要给成员变量赋值</span></span><br><span class="line">		_xxx = [aCoder decodeObjectForKey:(<span class="built_in">NSString</span> *)];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义View,从xib加载的时候系统会自动调用initWithCoder方法</span></span><br><span class="line"><span class="comment">//只要父类遵守了NSCoding协议就要调用initWithCoder</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder])&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过代码初始化的时候,调用init方法,底层会调用initWithFrame</span></span><br><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">self</span>=[<span class="keyword">super</span> initWithFrame:frame])&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="如何定义block">如何定义block</h3><ul>
<li>快捷键inline<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">returnType(^blockName)(parameterTypes) = ^(parameters) &#123;</span><br><span class="line">        statements</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS界面跳转传值]]></title>
    <link href="http://yoursite.com/2016/03/14/contact/"/>
    <id>http://yoursite.com/2016/03/14/contact/</id>
    <published>2016-03-14T14:00:00.000Z</published>
    <updated>2016-03-20T06:34:57.000Z</updated>
    <content type="html"><![CDATA[<h3 id="监听文本框内容改变">监听文本框内容改变</h3><ul>
<li><code>[UITextField addTarget:self action:@selector(textChange) forControlEvents:UIControlEventEditingChanged];</code></li>
</ul>
<h3 id="什么是Segue">什么是Segue</h3><ul>
<li>Storyboard上每一根用来界面跳转的线,都是一个UIStoryboardSegue对象(简称Segue)</li>
</ul>
<a id="more"></a>
<h3 id="Segue的属性">Segue的属性</h3><ul>
<li>每一个Segue对象都有3个属性<ul>
<li>唯一标识 <code>@property (nonatomic, readonly) NSString *identifier;</code></li>
<li>来源控制器 <code>@property (nonatomic, readonly) id sourceViewController;</code></li>
<li>目的控制器 <code>@property (nonatomic, readonly) id destinationViewController;</code></li>
</ul>
</li>
</ul>
<h3 id="Segue的类型">Segue的类型</h3><ul>
<li>根据Segue的执行(跳转)时刻,Segue可以分为2大类型<ul>
<li>自动型:点击某个控件后(比如按钮),自动执行Segue,自动完成界面跳转</li>
<li>手动型:需要通过写代码手动执行Segue,才能完成界面跳转</li>
</ul>
</li>
</ul>
<h3 id="自动型">自动型</h3><ul>
<li>按住Control键,直接从控件拖线到目标控制器</li>
<li>如果点击某个控件后,不需要做任何判断,一定要跳转到下一个界面,建议使用”自动型Segue”</li>
</ul>
<h3 id="手动型Segue">手动型Segue</h3><ul>
<li>按住Control键,从来源控制器拖线到目标控制器</li>
<li>手动型的Segue需要设置一个标识</li>
<li>在恰当的时刻,使用perform方法执行对应的Segue<br><code>[self performSegueWithIdentifier:@&quot;login2contacts&quot; sender:nil];</code><br><code>Segue必须由来源控制器来执行,也就是说,这个perform方法必须由来源控制器来调用</code></li>
<li>如果点击某个控件后,需要做一些判断,也就是说,满足一定条件后才能跳转到下一个界面,建议使用”手动型Segue”</li>
</ul>
<h3 id="performSegueWithIdentifier:sender:"><code>performSegueWithIdentifier:sender:</code></h3><ul>
<li>利用<code>performSegueWithIdentifier:sender:</code>方法可以执行某个Segue,完成界面跳转</li>
<li><p>接下来研究<code>performSegueWithIdentifier:sender:</code>方法的完整执行过程</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个self是来源控制器</span></span><br><span class="line">[<span class="keyword">self</span> performSegueWithIdentifier:<span class="string">@"login2contacts"</span> sender:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>根据identifier去storyboard中找到对应的线,新建UIStoryboardSegue对象<br>设置Segue对象的sourceViewController(来源控制器)<br>新建并且设置Segue对象的destinationViewController(目标控制器)</li>
<li>调用sourceViewController的下面方法,做一些跳转前的准备工作并且传人创建好的Segue对象<br><code>- (void)prepareForSegue:(UIStoryboard *)segue sender:(id)sender;</code><br>这个sender是当初<code>performSegueWithIdentifier:sender:</code>中传人的sender</li>
<li><p>调用Segue对象的<code>- (void)perform</code>方法开始执行界面跳转操作</p>
<ul>
<li><p>如果segue的style是push</p>
<ul>
<li>取得sourceViewController所在的UINavigationController</li>
<li>调用UINavigationController的push方法将destinationViewController压人栈中,完成跳转.</li>
</ul>
</li>
<li><p>如果segue的style是modal</p>
<pre><code><span class="bullet">- </span>调用sourceViewController的presentViewController方法将destinationViewController展示出来
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Modal">Modal</h3><ul>
<li>除了push之外,还有另外一种控制器的切换方式,那就是Modal</li>
<li>任何控制器都能通过Modal的形式展示出来</li>
<li>Modal的默认效果: 新控制器从屏幕的最底部网上钻,直到盖住之前的控制器为止</li>
<li>以Modal的形式展示控制器<br><code>- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^)(void))completion</code></li>
<li>取消modal出的控制器<br><code>- (void)dismissViewControllerAnimated:(BOOL) completion:(void (^)(void))completion</code></li>
</ul>
<h5 id="modal的过程和原理:">modal的过程和原理:</h5><ul>
<li>在iOS8之后modal出来的控制器view加到的是UITransitionView上,之前是加在UIWindow上</li>
<li>UIWindow的rootViewController 强引用了 ViewController 而 ViewController的视图被自身的view属性强引用了</li>
<li>被modal出来的View controller会被来源控制器中的 presentedViewController属性强引用保存起来</li>
<li>当modal出View controller时,来源控制器的view会从UIWindow中移出</li>
<li>View controller中的 presentedViewController 与 presentingViewController属性</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="监听文本框内容改变">监听文本框内容改变</h3><ul>
<li><code>[UITextField addTarget:self action:@selector(textChange) forControlEvents:UIControlEventEditingChanged];</code></li>
</ul>
<h3 id="什么是Segue">什么是Segue</h3><ul>
<li>Storyboard上每一根用来界面跳转的线,都是一个UIStoryboardSegue对象(简称Segue)</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS多控制器]]></title>
    <link href="http://yoursite.com/2016/03/13/multi_viewcontroller/"/>
    <id>http://yoursite.com/2016/03/13/multi_viewcontroller/</id>
    <published>2016-03-13T14:05:07.000Z</published>
    <updated>2016-03-22T14:33:46.000Z</updated>
    <content type="html"><![CDATA[<h3 id="多控制器">多控制器</h3><ul>
<li>UINavigationController</li>
<li>UITabBarController</li>
</ul>
<h3 id="UINavigationController的简单使用">UINavigationController的简单使用</h3><ul>
<li>UINavigationController的使用步骤<ul>
<li>初始化UINavigationController</li>
<li>设置UIWindow的rootViewController为UINavigationController</li>
<li>根据具体情况,通过push方法添加对应个数的子控制器</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="UINavigationController的子控制器">UINavigationController的子控制器</h3><ul>
<li>UINavigationController以栈的形式保存子控制器<br><code>@property(nonatomic,copy) NSArray *viewControllers;</code><br><code>@property(nonatomic,readonly) NSArray *childViewControllers;</code></li>
<li>使用push方法能将某个控制器压入栈<br><code>- (void)pushViewController:(UIViewController *)viewController
animated:(BOOL)animated;</code></li>
<li>使用pop方法可以移除控制器<ul>
<li>将栈顶的控制器移除(不是马上将控制器销毁,而是等到动画结束后才销毁)<br><code>- (UIViewController *)popViewControllerAnimated:(BOOL)animated;</code></li>
<li>回到指定的子控制器<br><code>- (NSArray *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated;</code></li>
<li>回到根控制器(栈底控制器)<br><code>- (NSArray *)popToRootViewControllerAnimated:(BOOL)animated;</code></li>
</ul>
</li>
</ul>
<h3 id="如何修改导航栏的内容">如何修改导航栏的内容</h3><ul>
<li>导航栏的内容由栈顶控制器的navigationItem属性决定<br><code>self.navigationItem.title</code><br><code>self.title</code></li>
<li>UINavigationItem: 控制导航条的内容</li>
<li>UIBarButtonItem: 控制导航条上面按钮的内容</li>
<li>UINavigationItem有以下属性影响着导航栏的内容<ul>
<li>左上角的返回按钮<br><code>@property(nonatomic,retain) UIBarButtonItem *backBarButtonItem;</code></li>
<li>中间的标题视图<br><code>@property(nonatomic,retain) UIView *titleView;</code></li>
<li>中间的标题文字<br><code>@property(nonatomic,copy) NSString *title;</code></li>
<li>左上角的视图<br><code>@property(nonatomic,retain) UIBarButtonItem *leftBarButtonItem;</code></li>
<li>UIBarButtonItem <em>rightBarButtonItem 右上角的视图<br>`@property(nonatomic,retain) UIBarButtonItem </em>rightBarButtonItem;`</li>
<li>自定义<br><code>[[UIBarButtonItem alloc] initWithCustomView:(UIView *)]</code></li>
</ul>
</li>
</ul>
<h3 id="控制器View的生命周期顺序">控制器View的生命周期顺序</h3><ul>
<li><code>- (void)viewDidLoad</code></li>
<li><code>- (void)viewWillAppear:(BOOL)animated</code></li>
<li><code>- (void)viewWillLayoutSubviews</code></li>
<li><code>- (void)viewDidLayoutSubviews</code></li>
<li><code>- (void)viewDidAppear:(BOOL)animated</code></li>
<li><code>- (void)viewWillDisappear:(BOOL)animated</code></li>
<li><code>- (void)viewDidDisappear:(BOOL)animated</code></li>
<li>当控制器的view旋转的时候调用 <code>- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator</code></li>
<li>在非ARC中<ul>
<li>view即将销毁 <code>- (void)viewWillUnload</code></li>
<li>view完全销毁 <code>- (void)viewDidUnload</code> 在这个方法中管理内存,清空界面的数据.</li>
</ul>
</li>
</ul>
<h3 id="UITabBarController的view结构">UITabBarController的view结构</h3><ul>
<li>UITabBar 高度为49</li>
<li>存放子控制器的view</li>
<li>UITabBarController控制器的view不是懒加载,在创建控制器的时候就会加载</li>
</ul>
<h4 id="UITabBarController的简单使用">UITabBarController的简单使用</h4><ul>
<li>初始化UITabBarController</li>
<li>设置UIWindow的rootViewController为UITabBarController</li>
<li><p>根据具体情况,通过addChildViewController方法添加对应个数的子控制器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line"><span class="built_in">UITabBarController</span> *tabBarVC = [[<span class="built_in">UITabBarController</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置窗口的根控制器</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = tabBarVC;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIViewController</span> *vc = [[<span class="built_in">UIViewController</span> alloc] init];</span><br><span class="line">vc<span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置按钮上面的内容</span></span><br><span class="line">vc<span class="variable">.tabBarItem</span><span class="variable">.title</span> = <span class="string">@"消息"</span>;</span><br><span class="line">vc<span class="variable">.tabBarItem</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>];</span><br><span class="line">vc<span class="variable">.tabBarItem</span><span class="variable">.selectedImage</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@""</span>];</span><br><span class="line">vc<span class="variable">.tabBarItem</span><span class="variable">.badgeValue</span> = <span class="string">@"10"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加子控制器</span></span><br><span class="line">[tabBarVC addChildViewController:vc];</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示窗口</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br></pre></td></tr></table></figure>
</li>
<li><p>UITabBar</p>
<ul>
<li>如果UITabBarController有N个子控制器,那么UITabBar内部就会有N个UITabBarButton作为子控件</li>
<li>UITabBarButton里面显示什么内容,由对应子控制器的tabBarItem属性决定</li>
<li>UITabBarItem有以下属性影响着UITabBarButton的内容<ul>
<li>标题文字<br><code>@property(nonatomic,copy)NSString *title;</code></li>
<li>图标<br><code>@property(nonatomic,retain)UIImage *image;</code></li>
<li>选中时的图标<br><code>@property(nonatomic,retain)UIImage *selectedImage;</code></li>
<li>提醒数字<br><code>@property(nonatomic,copy)NSString *badgeValue;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="多控制器">多控制器</h3><ul>
<li>UINavigationController</li>
<li>UITabBarController</li>
</ul>
<h3 id="UINavigationController的简单使用">UINavigationController的简单使用</h3><ul>
<li>UINavigationController的使用步骤<ul>
<li>初始化UINavigationController</li>
<li>设置UIWindow的rootViewController为UINavigationController</li>
<li>根据具体情况,通过push方法添加对应个数的子控制器</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS创建控制器]]></title>
    <link href="http://yoursite.com/2016/03/13/create_viewcontroller/"/>
    <id>http://yoursite.com/2016/03/13/create_viewcontroller/</id>
    <published>2016-03-13T02:00:07.000Z</published>
    <updated>2016-03-13T14:11:22.000Z</updated>
    <content type="html"><![CDATA[<h3 id="如何创建一个控制器">如何创建一个控制器</h3><ul>
<li><p>控制器常见的创建方式有以下几种</p>
<ul>
<li><p>通过storyboard创建</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建窗口</span></span><br><span class="line">   <span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载storyboard</span></span><br><span class="line"><span class="built_in">UIStoryboard</span> *storyboard = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过storyboard实例化控制器</span></span><br><span class="line"><span class="comment">// instantiateInitialViewController: 加载箭头指向的控制器</span></span><br><span class="line"><span class="comment">// instantiateViewControllerWithIdentifier:(NSString *)identifier:通过Storyboard ID标识符来创建控制器</span></span><br><span class="line"><span class="built_in">UIViewController</span> *vc = [storyboard instantiateInitialViewController];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将控制器设置为窗口的根控制器</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = vc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示主窗口</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接创建<br><code>UIViewController *vc = [[UIViewController alloc] init];</code></p>
</li>
<li>指定xib文件创建<figure class="highlight"><table><tr><td class="code"><pre><span class="line">创建xib并添加一个view</span><br><span class="line">为文件的拥有者绑定Class(即设置File's Owner的Class类型 MCViewController)</span><br><span class="line">设置文件的拥有者Outlets view</span><br><span class="line">MCViewController *vc = [[MCViewController alloc] initWithNibName:@"MCViewController" bundle:nil];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="了解控制器的View是如何创建的">了解控制器的View是如何创建的</h3><h4 id="UIViewController中的-_(void)loadView方法">UIViewController中的<code>- (void)loadView</code>方法</h4><ul>
<li>loadView的作用: 自定义控制器的view</li>
<li>loadView什么时候调用: 第一次使用控制器的view的时候调用</li>
<li>注意: 在这个方法中如果没有自定义view,就不能获取控制器的view</li>
<li>一旦重写了这个方法,就不要调用[super loadView]</li>
<li>如果重写了这个方法,就不会去加载storyboard描述的控制器的View<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loadView&#123;</span><br><span class="line">	<span class="comment">// 系统默认的做法,加载storyboard或者xib描述的控制器的view</span></span><br><span class="line">	<span class="comment">//[super loadView];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不能通过这种方式设置背景颜色,会导致死循环</span></span><br><span class="line">	<span class="comment">// self.view.backgroundColor = [UIColor redColor];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建控制器view</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span> = [[<span class="built_in">UIView</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> purpleColor];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//系统内部可能是这样实现的</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_view == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> loadView];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> viewDidLoad];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="控制器view的创建(xib)">控制器view的创建(xib)</h4><ul>
<li>加载跟类名相同的xib</li>
<li>如果描述控制器View的xib跟控制器的类名相同,就会去加载</li>
<li>只有控制器的init方法底层会调用initWithNibName:bundle:</li>
<li>只要通过initWithNibName:bundle:初始化控制器,并且nibName为nil,就会执行以下几步.(例如:MCViewController类型)<ul>
<li>1.寻找有没有跟控制器类名同名但是不带Controller的xib,如果有就会去加载（MCView.xib）</li>
<li>2.寻找有没有跟控制器类名同名的xib,如果有就会去加载(MCViewController.xib)</li>
<li>3.如果都没有找到,创建空的view</li>
</ul>
</li>
<li>默认控制器view的颜色为几乎透明色</li>
</ul>
<h4 id="控制器view的懒加载">控制器view的懒加载</h4><ul>
<li>创建UIViewController控制器,控制器的view并没有创建</li>
<li><p>控制器的view懒加载:第一次使用的时候才会去加载,并不是创建UIViewController控制器的时候去加载</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line"><span class="built_in">UIViewController</span> *vc = [[ViewController alloc] init];</span><br><span class="line"><span class="comment">//第一次使用的时候会去加载view</span></span><br><span class="line">vc<span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = vc;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果控制器是窗口的根控制器就可以不用设置尺寸</p>
</li>
<li>在viewDidLoad中打印控制器的尺寸不准确,通常在viewDidAppear</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="如何创建一个控制器">如何创建一个控制器</h3><ul>
<li><p>控制器常见的创建方式有以下几种</p>
<ul>
<li><p>通过storyboard创建</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建窗口</span></span><br><span class="line">   <span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载storyboard</span></span><br><span class="line"><span class="built_in">UIStoryboard</span> *storyboard = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过storyboard实例化控制器</span></span><br><span class="line"><span class="comment">// instantiateInitialViewController: 加载箭头指向的控制器</span></span><br><span class="line"><span class="comment">// instantiateViewControllerWithIdentifier:(NSString *)identifier:通过Storyboard ID标识符来创建控制器</span></span><br><span class="line"><span class="built_in">UIViewController</span> *vc = [storyboard instantiateInitialViewController];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将控制器设置为窗口的根控制器</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = vc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示主窗口</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接创建<br><code>UIViewController *vc = [[UIViewController alloc] init];</code></p>
</li>
<li>指定xib文件创建<figure class="highlight"><table><tr><td class="code"><pre><span class="line">创建xib并添加一个view</span><br><span class="line">为文件的拥有者绑定Class(即设置File's Owner的Class类型 MCViewController)</span><br><span class="line">设置文件的拥有者Outlets view</span><br><span class="line">MCViewController *vc = [[MCViewController alloc] initWithNibName:@"MCViewController" bundle:nil];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS之UIWindow]]></title>
    <link href="http://yoursite.com/2016/03/12/uiwindow/"/>
    <id>http://yoursite.com/2016/03/12/uiwindow/</id>
    <published>2016-03-12T02:00:00.000Z</published>
    <updated>2016-03-13T14:12:23.000Z</updated>
    <content type="html"><![CDATA[<h3 id="UIWindow">UIWindow</h3><ul>
<li>UIWindow是一种特殊的UIView,通常在一个app中一般都会有一个UIWindow</li>
<li>iOS程序启动完毕后,创建的第一个视图控件就是UIWindow,接着创建控制器的view,最后将控制器的view添加到UIWindow上,于是控制器的view就显示在屏幕上了</li>
<li>一个iOS程序之所以能显示到屏幕上,完全是因为它有UIWindow</li>
<li>也就说,没有UIWindow,就看不见任何UI界面</li>
<li>键盘和状态栏都是窗口而UIAlertView不是窗口</li>
<li>窗口是有层级关系的.(UIWindowLevel:UIWindowLevelNormal &lt; UIWindowLevelStatusBar &lt; UIWindowLevelAlert)</li>
</ul>
<a id="more"></a>
<h3 id="iOS_App启动加载过程">iOS App启动加载过程</h3><p>main函数是程序的主入口,调用UIApplicationMain函数做的事情:</p>
<ul>
<li>创建UIApplication</li>
<li>创建UIApplicationDelegate,并且成为UIApplication代理</li>
<li>开启主运行循环,保持程序一直在运行</li>
<li>加载info.plist,判断有没有指定main.stroyboard,指定了就加载 </li>
<li>加载main.stroyboard做的事情:<ul>
<li>创建窗口</li>
<li>加载main.storyboard,并且加载main.storyboard指定的控制器</li>
<li>把新创建的控制器作为窗口的跟控制器,让窗口显示出来</li>
</ul>
</li>
<li>如果info.plist没有指定’Main storyboard file base name’,则不会创建窗口<br>需要在app启动完成方法中创建窗口然后创建窗口的根控制器最后再显示窗口</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1.创建窗口,注意窗口必须要有尺寸,尺寸跟屏幕一样大的尺寸,窗口不要被释放</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建窗口的根控制器</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"></span><br><span class="line"><span class="comment">// application.windows:只要一给delegate的window属性赋值,就会添加到windows数组</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,application<span class="variable">.windows</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIViewController</span> *vc = [[<span class="built_in">UIViewController</span> alloc] init];</span><br><span class="line"></span><br><span class="line">vc<span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果设置窗口的根控制器,默认就会把控制器的view添加到窗口上</span></span><br><span class="line"><span class="comment">//设置窗口的根控制器,默认就有旋转功能</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = vc;<span class="comment">//底层相当于[self.window addSubview:vc.view];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.显示窗口</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible]; <span class="comment">//makeKeyAndVisible 相当于 成为App的主窗口([UIApplication sharedApplication].keyWindow)并显示 设置self.window.hidden = NO;</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="UIWindow">UIWindow</h3><ul>
<li>UIWindow是一种特殊的UIView,通常在一个app中一般都会有一个UIWindow</li>
<li>iOS程序启动完毕后,创建的第一个视图控件就是UIWindow,接着创建控制器的view,最后将控制器的view添加到UIWindow上,于是控制器的view就显示在屏幕上了</li>
<li>一个iOS程序之所以能显示到屏幕上,完全是因为它有UIWindow</li>
<li>也就说,没有UIWindow,就看不见任何UI界面</li>
<li>键盘和状态栏都是窗口而UIAlertView不是窗口</li>
<li>窗口是有层级关系的.(UIWindowLevel:UIWindowLevelNormal &lt; UIWindowLevelStatusBar &lt; UIWindowLevelAlert)</li>
</ul>]]>
    
    </summary>
    
  </entry>
  
</feed>